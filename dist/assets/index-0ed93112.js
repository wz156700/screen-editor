import { u as Lu, r as ce, o as zt, c as fe, a as Vt, t as Tn, b as Jt, _ as Ci, i as xa, d as le, e as Fu, f as Re, g as ye, w as Oe, F as Xi, h as Ki, j as qe, k as wn, n as si, l as yi, p as Pu, m as Ru, q as La, s as Sc, v as Tc, x as Js, y as ha, z as Ec, E as Ws, A as Ns, B as Ic, C as Qu, D as Bc, G as kc, H as Mc, I as Ds, J as Oc } from "./index-52dfe5e3.js"; import { v as Dc } from "./v4-a960c1f4.js"; const Lc = "/td-visual-editor/assets/logo-d44a6753.png"; const Fc = { class: "td-editorMain-top" }, Pc = Vt("img", { src: Lc }, null, -1), Rc = Vt("div", { class: "td-editorMain-top-left-name" }, "AP-Editor 可视化编辑器", -1), Qc = [Pc, Rc], Wc = { class: "td-editorMain-top-middle" }, Nc = { class: "td-editorMain-top-right" }, Yc = Vt("span", null, "保存", -1), Vc = Vt("span", null, "预览", -1), zc = { __name: "index", props: ["domInfo"], emits: ["saveItem", "previewItem"], setup(v, { emit: h }) { const b = Lu(), E = () => { h("saveItem") }, k = () => { h("previewItem") }, _ = () => { b.push("/") }; return (S, d) => { const a = ce("EditorIcon"); return zt(), fe("div", Fc, [Vt("div", { class: "td-editorMain-top-left", onClick: _ }, Qc), Vt("div", Wc, Tn(v.domInfo.name), 1), Vt("div", Nc, [Vt("div", { class: "td-editorMain-top-right-item", onClick: E }, [Jt(a, { name: "save" }), Yc]), Vt("div", { class: "td-editorMain-top-right-item", onClick: k }, [Jt(a, { name: "share" }), Vc])])]) } } }; const Uc = { class: "image-preview-list" }, Hc = { class: "image-preview-list-title" }, Gc = { class: "image-preview-list-image" }, jc = ["src", "title"], Xc = { __name: "ImageItem", props: { itemData: Object }, setup(v) { const h = v, b = xa("draggable", null), E = () => { b(h.itemData) }; return (k, _) => (zt(), fe("div", { class: "image-preview", draggable: !0, onDragstart: E }, [Vt("div", Uc, [Vt("div", Hc, Tn(h.itemData.name), 1), Vt("div", Gc, [h.itemData.image ? Re("", !0) : (zt(), le(Fu(h.itemData.type), { key: 0 })), h.itemData.image ? (zt(), fe("img", { key: 1, src: h.itemData.image, title: h.itemData.name }, null, 8, jc)) : Re("", !0)])])], 32)) } }, Kc = Ci(Xc, [["__scopeId", "data-v-fa6f2eb9"]]), vn = { __name: "rightCom", props: { menuList: { type: Array } }, setup(v) { const h = ye([1]); return (b, E) => { const k = ce("el-collapse-item"), _ = ce("el-collapse"); return zt(), le(_, { modelValue: h.value, "onUpdate:modelValue": E[0] || (E[0] = S => h.value = S) }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(v.menuList, (S, d) => (zt(), le(k, { key: d, title: S.name, name: S.value }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(S.children, (a, l) => (zt(), le(Kc, { key: l, itemData: a, style: { width: "100%", height: "220px" } }, null, 8, ["itemData"]))), 128))]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 }, 8, ["modelValue"]) } } }, Wu = [{ name: "示例组件", value: 1, children: [{ type: "BarChart1", mark: "BarChart1", fabricType: "rect", width: 450, height: 150, name: "图表示例1", uuid: "A1" }, { type: "LineChart2", mark: "LineChart2", fabricType: "rect", width: 450, height: 150, name: "图表示例2", uuid: "A2" }] }], qc = "/td-visual-editor/assets/BorderBox1-52297d78.png", Jc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAr4AAAEICAYAAAC5/PeAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGTGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIzLTEyLTA1VDE2OjE3OjA1KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIzLTEyLTA1VDE2OjE3OjA1KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMy0xMi0wNVQxNjoxNzowNSswODowMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3NmE4ZjU4ZS1mYWNmLTg3NDgtODNjYS1hMTE1MDM4OGNlYTIiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpiY2Q1MjE0Yi1mZTU5LTYzNDAtOTViZC1iYzhlYTU5ZDhhMWUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphNjUwNDA2MS02YTEwLTIzNDEtYjhiZi1jMjA2ZmU0NmJmYzkiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphNjUwNDA2MS02YTEwLTIzNDEtYjhiZi1jMjA2ZmU0NmJmYzkiIHN0RXZ0OndoZW49IjIwMjMtMTItMDVUMTY6MTc6MDUrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMS4wIChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NzZhOGY1OGUtZmFjZi04NzQ4LTgzY2EtYTExNTAzODhjZWEyIiBzdEV2dDp3aGVuPSIyMDIzLTEyLTA1VDE2OjE3OjA1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDxyZGY6QmFnPiA8cmRmOmxpPjI2NDk1Q0M3MDRBQUYxNTI3MkZBRTdDQkZFQzA4MEZFPC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Hioa4QAACUVJREFUeNrt3c2PE2UcwPGZ2ZV02Y3LkWACEl+IsISDrn+FiYlHgxjCRXlRD3LSm97EGEWQi8G36M3ExH9CVw+EwgEvSCJn14CtSGfs09mBbrdrO31Z2O3nkzTd37YPHaqJX59MO3GWZREAAGx1ibcAAADhCwAA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", Zc = "data:image/png;base64,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", $c = "data:image/png;base64,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", td = "/td-visual-editor/assets/BorderBox5-9104d26a.png", ed = "/td-visual-editor/assets/BorderBox6-6e4f4172.png", id = "/td-visual-editor/assets/BorderBox7-ec59f5f3.png", rd = "/td-visual-editor/assets/BorderBox8-367d0242.png", nd = "/td-visual-editor/assets/BorderBox9-68b76553.png", ad = "/td-visual-editor/assets/BorderBox10-7172c2c0.png", sd = "/td-visual-editor/assets/BorderBox11-417ad50c.png", od = "data:image/png;base64,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", ld = "/td-visual-editor/assets/BorderBox13-a85e1a3e.png", ud = "data:image/png;base64,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", fd = "data:image/png;base64,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", hd = "data:image/png;base64,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", cd = "data:image/png;base64,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", dd = "data:image/png;base64,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", gd = "/td-visual-editor/assets/Decoration11-8dc892da.png", pd = "/td-visual-editor/assets/Decoration12-b391feba.png", vd = "data:image/png;base64,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", Nu = [{ name: "DataV边框组件", value: 1, children: [{ type: "BorderBox1", mark: "BorderBox1", fabricType: "rect", width: 450, height: 150, name: "边框-1", image: qc, uuid: "B1" }, { type: "BorderBox2", mark: "BorderBox2", fabricType: "rect", width: 450, height: 150, name: "边框-2", image: Jc, uuid: "B2" }, { type: "BorderBox3", mark: "BorderBox3", fabricType: "rect", width: 450, height: 150, name: "边框-3", image: Zc, uuid: "B3" }, { type: "BorderBox4", mark: "BorderBox4", fabricType: "rect", width: 450, height: 150, name: "边框-4", image: $c, uuid: "B4" }, { type: "BorderBox5", mark: "BorderBox5", fabricType: "rect", width: 450, height: 150, name: "边框-5", image: td, uuid: "B5" }, { type: "BorderBox6", mark: "BorderBox6", fabricType: "rect", width: 450, height: 150, name: "边框-6", image: ed, uuid: "B6" }, { type: "BorderBox7", mark: "BorderBox7", fabricType: "rect", width: 450, height: 150, name: "边框-7", image: id, uuid: "B7" }, { type: "BorderBox8", mark: "BorderBox8", fabricType: "rect", width: 450, height: 150, name: "边框-8", image: rd, uuid: "B8" }, { type: "BorderBox9", mark: "BorderBox9", fabricType: "rect", width: 450, height: 150, name: "边框-9", image: nd, uuid: "B9" }, { type: "BorderBox10", mark: "BorderBox10", fabricType: "rect", width: 450, height: 150, name: "边框-10", image: ad, uuid: "B10" }, { type: "BorderBox11", mark: "BorderBox11", fabricType: "rect", width: 450, height: 150, name: "边框-11", image: sd, uuid: "B11" }, { type: "BorderBox12", mark: "BorderBox12", fabricType: "rect", width: 450, height: 150, name: "边框-12", image: od, uuid: "B12" }, { type: "BorderBox13", mark: "BorderBox13", fabricType: "rect", width: 450, height: 150, name: "边框-13", image: ld, uuid: "B13" }] }, { name: "DataV装饰组件", value: 2, children: [{ type: "Decoration1", mark: "Decoration1", fabricType: "rect", width: 250, height: 150, name: "装饰条1", image: ud, uuid: "B21" }, { type: "Decoration3", mark: "Decoration3", fabricType: "rect", width: 250, height: 150, name: "装饰条3", image: fd, uuid: "B23" }, { type: "Decoration5", mark: "Decoration5", fabricType: "rect", width: 250, height: 150, name: "装饰条5", uuid: "B25" }, { type: "Decoration6", mark: "Decoration6", fabricType: "rect", width: 250, height: 150, name: "装饰条6", image: hd, uuid: "B26" }, { type: "Decoration7", mark: "Decoration7", fabricType: "rect", width: 250, height: 150, name: "装饰条7", image: cd, uuid: "B27" }, { type: "Decoration8", mark: "Decoration8", fabricType: "rect", width: 250, height: 150, name: "装饰条8", image: dd, uuid: "B28" }, { type: "Decoration11", mark: "Decoration11", fabricType: "rect", width: 250, height: 80, name: "装饰条11", image: gd, uuid: "B211" }, { type: "Decoration12", mark: "Decoration12", fabricType: "rect", width: 250, height: 250, name: "装饰条12", image: pd, uuid: "B212" }] }, { name: "信息组件", value: 3, children: [{ type: "apWviewText1", mark: "apWviewText1", fabricType: "rect", width: 250, height: 100, name: "文本1", image: vd, uuid: "C1" }] }], Yu = [{ name: "地图组件", value: 1, children: [{ type: "Map1", mark: "Map1", fabricType: "rect", width: 450, height: 450, name: "地图-1", uuid: "D1" }] }], Vu = [], zu = []; const md = { class: "history" }, yd = ["onClick"], Ad = ["title"], Cd = ["src"], bd = { class: "history-list-name" }, wd = { __name: "historyList", props: { domData: { type: Object, required: !0 }, selectId: { type: Array, default: [] } }, emits: ["selectItem"], setup(v, { emit: h }) { const b = v, E = [...Wu, ...Nu, ...Yu, ...Vu, ...zu], k = qe(() => b.selectId ? b.selectId : []), _ = ye([]), S = l => { _.value = []; for (let c in l) for (let r = 0; r < E.length; r++)for (let i = 0; i < E[r].children.length; i++)E[r].children[i].uuid == l[c].componentsuuid && _.value.push({ ...l[c], image: E[r].children[i].image || "" }) }, d = qe(() => b.domData ? b.domData : {}); wn(() => d.value, l => { S(l) }, { deep: !0, immediate: !0 }); const a = l => { h("selectItem", l) }; return (l, c) => (zt(), fe("div", md, [(zt(!0), fe(Xi, null, Ki(_.value, r => (zt(), fe("div", { class: si(["history-list", k.value.includes(r.uuid) ? "history-list-active" : ""]), key: r.uuid, onClick: i => a(r) }, [Vt("div", { class: "history-list-image", title: r.name }, [r.image ? (zt(), fe("img", { key: 0, src: r.image }, null, 8, Cd)) : Re("", !0)], 8, Ad), Vt("div", bd, Tn(r.name), 1)], 10, yd))), 128))])) } }, xd = Ci(wd, [["__scopeId", "data-v-26df2564"]]); const En = v => (Pu("data-v-ebf768c5"), v = v(), Ru(), v), _d = { class: "td-editorLeft" }, Sd = { class: "td-editorLeft-name" }, Td = En(() => Vt("span", null, "组件管理", -1)), Ed = { class: "td-editorLeft-content" }, Id = { class: "td-editorLeft-content-left" }, Bd = En(() => Vt("span", null, "最近", -1)), kd = En(() => Vt("span", null, "图表", -1)), Md = En(() => Vt("span", null, "小组件", -1)), Od = En(() => Vt("span", null, "地图", -1)), Dd = { class: "td-editorLeft-content-right" }, Ld = { class: "td-editorLeft-content-right-box" }, Fd = { __name: "index", props: { domData: { type: Object, required: !0 }, selectId: { type: Array, default: [] } }, emits: ["selectItem"], setup(v, { emit: h }) { const b = ye("analysis"), E = _ => { b.value = _ }, k = _ => { h("selectItem", _) }; return (_, S) => { const d = ce("EditorIcon"), a = ce("el-scrollbar"); return zt(), fe("div", _d, [Vt("div", Sd, [Td, Jt(d, { name: "left", size: "16px" })]), Vt("div", Ed, [Vt("div", Id, [Vt("div", { class: si(["td-editorLeft-content-left-item", b.value === "history" ? "is-active" : ""]), onClick: S[0] || (S[0] = l => E("history")) }, [Jt(d, { name: "history", size: "16px" }), Bd], 2), Vt("div", { class: si(["td-editorLeft-content-left-item", b.value === "analysis" ? "is-active" : ""]), onClick: S[1] || (S[1] = l => E("analysis")) }, [Jt(d, { name: "analysis", size: "16px" }), kd], 2), Vt("div", { class: si(["td-editorLeft-content-left-item", b.value === "components" ? "is-active" : ""]), onClick: S[2] || (S[2] = l => E("components")) }, [Jt(d, { name: "components", size: "16px" }), Md], 2), Vt("div", { class: si(["td-editorLeft-content-left-item", b.value === "map" ? "is-active" : ""]), onClick: S[3] || (S[3] = l => E("map")) }, [Jt(d, { name: "history", size: "16px" }), Od], 2)]), Vt("div", Dd, [Jt(a, { height: "100%" }, { default: Oe(() => [Vt("div", Ld, [b.value === "history" ? (zt(), le(xd, { key: 0, domData: v.domData, onSelectItem: k, selectId: v.selectId }, null, 8, ["domData", "selectId"])) : Re("", !0), b.value === "map" ? (zt(), le(vn, { key: 1, menuList: yi(Yu) }, null, 8, ["menuList"])) : Re("", !0), b.value === "analysis" ? (zt(), le(vn, { key: 2, menuList: yi(Wu) }, null, 8, ["menuList"])) : Re("", !0), b.value === "components" ? (zt(), le(vn, { key: 3, menuList: yi(Nu) }, null, 8, ["menuList"])) : Re("", !0), b.value === "hTitle" ? (zt(), le(vn, { key: 4, menuList: yi(Vu) }, null, 8, ["menuList"])) : Re("", !0), b.value === "material" ? (zt(), le(vn, { key: 5, menuList: yi(zu) }, null, 8, ["menuList"])) : Re("", !0)])]), _: 1 })])])]) } } }, Pd = Ci(Fd, [["__scopeId", "data-v-ebf768c5"]]); function ya(v, h) { return v == null || h == null ? NaN : v < h ? -1 : v > h ? 1 : v >= h ? 0 : NaN } function Rd(v, h) { return v == null || h == null ? NaN : h < v ? -1 : h > v ? 1 : h >= v ? 0 : NaN } function Uu(v) { let h, b, E; v.length !== 2 ? (h = ya, b = (d, a) => ya(v(d), a), E = (d, a) => v(d) - a) : (h = v === ya || v === Rd ? v : Qd, b = v, E = v); function k(d, a, l = 0, c = d.length) { if (l < c) { if (h(a, a) !== 0) return c; do { const r = l + c >>> 1; b(d[r], a) < 0 ? l = r + 1 : c = r } while (l < c) } return l } function _(d, a, l = 0, c = d.length) { if (l < c) { if (h(a, a) !== 0) return c; do { const r = l + c >>> 1; b(d[r], a) <= 0 ? l = r + 1 : c = r } while (l < c) } return l } function S(d, a, l = 0, c = d.length) { const r = k(d, a, l, c - 1); return r > l && E(d[r - 1], a) > -E(d[r], a) ? r - 1 : r } return { left: k, center: S, right: _ } } function Qd() { return 0 } function Wd(v) { return v === null ? NaN : +v } const Nd = Uu(ya), Yd = Nd.right; Uu(Wd).center; const Vd = Yd, zd = Math.sqrt(50), Ud = Math.sqrt(10), Hd = Math.sqrt(2); function _a(v, h, b) { const E = (h - v) / Math.max(0, b), k = Math.floor(Math.log10(E)), _ = E / Math.pow(10, k), S = _ >= zd ? 10 : _ >= Ud ? 5 : _ >= Hd ? 2 : 1; let d, a, l; return k < 0 ? (l = Math.pow(10, -k) / S, d = Math.round(v * l), a = Math.round(h * l), d / l < v && ++d, a / l > h && --a, l = -l) : (l = Math.pow(10, k) * S, d = Math.round(v / l), a = Math.round(h / l), d * l < v && ++d, a * l > h && --a), a < d && .5 <= b && b < 2 ? _a(v, h, b * 2) : [d, a, l] } function Gd(v, h, b) { if (h = +h, v = +v, b = +b, !(b > 0)) return []; if (v === h) return [v]; const E = h < v, [k, _, S] = E ? _a(h, v, b) : _a(v, h, b); if (!(_ >= k)) return []; const d = _ - k + 1, a = new Array(d); if (E) if (S < 0) for (let l = 0; l < d; ++l)a[l] = (_ - l) / -S; else for (let l = 0; l < d; ++l)a[l] = (_ - l) * S; else if (S < 0) for (let l = 0; l < d; ++l)a[l] = (k + l) / -S; else for (let l = 0; l < d; ++l)a[l] = (k + l) * S; return a } function Ys(v, h, b) { return h = +h, v = +v, b = +b, _a(v, h, b)[2] } function jd(v, h, b) { h = +h, v = +v, b = +b; const E = h < v, k = E ? Ys(h, v, b) : Ys(v, h, b); return (E ? -1 : 1) * (k < 0 ? 1 / -k : k) } function Xd(v) { return v } var Aa = 1, Ls = 2, ou = 3, yn = 4, lu = 1e-6; function Kd(v) { return "translate(" + v + ",0)" } function qd(v) { return "translate(0," + v + ")" } function Jd(v) { return h => +v(h) } function Zd(v, h) { return h = Math.max(0, v.bandwidth() - h * 2) / 2, v.round() && (h = Math.round(h)), b => +v(b) + h } function $d() { return !this.__axis } function Hu(v, h) { var b = [], E = null, k = null, _ = 6, S = 6, d = 3, a = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : .5, l = v === Aa || v === yn ? -1 : 1, c = v === yn || v === Ls ? "x" : "y", r = v === Aa || v === ou ? Kd : qd; function i(n) { var o = E ?? (h.ticks ? h.ticks.apply(h, b) : h.domain()), p = k ?? (h.tickFormat ? h.tickFormat.apply(h, b) : Xd), f = Math.max(_, 0) + d, m = h.range(), y = +m[0] + a, C = +m[m.length - 1] + a, x = (h.bandwidth ? Zd : Jd)(h.copy(), a), I = n.selection ? n.selection() : n, D = I.selectAll(".domain").data([null]), P = I.selectAll(".tick").data(o, h).order(), z = P.exit(), et = P.enter().append("g").attr("class", "tick"), tt = P.select("line"), st = P.select("text"); D = D.merge(D.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), P = P.merge(et), tt = tt.merge(et.append("line").attr("stroke", "currentColor").attr(c + "2", l * _)), st = st.merge(et.append("text").attr("fill", "currentColor").attr(c, l * f).attr("dy", v === Aa ? "0em" : v === ou ? "0.71em" : "0.32em")), n !== I && (D = D.transition(n), P = P.transition(n), tt = tt.transition(n), st = st.transition(n), z = z.transition(n).attr("opacity", lu).attr("transform", function (dt) { return isFinite(dt = x(dt)) ? r(dt + a) : this.getAttribute("transform") }), et.attr("opacity", lu).attr("transform", function (dt) { var q = this.parentNode.__axis; return r((q && isFinite(q = q(dt)) ? q : x(dt)) + a) })), z.remove(), D.attr("d", v === yn || v === Ls ? S ? "M" + l * S + "," + y + "H" + a + "V" + C + "H" + l * S : "M" + a + "," + y + "V" + C : S ? "M" + y + "," + l * S + "V" + a + "H" + C + "V" + l * S : "M" + y + "," + a + "H" + C), P.attr("opacity", 1).attr("transform", function (dt) { return r(x(dt) + a) }), tt.attr(c + "2", l * _), st.attr(c, l * f).text(p), I.filter($d).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", v === Ls ? "start" : v === yn ? "end" : "middle"), I.each(function () { this.__axis = x }) } return i.scale = function (n) { return arguments.length ? (h = n, i) : h }, i.ticks = function () { return b = Array.from(arguments), i }, i.tickArguments = function (n) { return arguments.length ? (b = n == null ? [] : Array.from(n), i) : b.slice() }, i.tickValues = function (n) { return arguments.length ? (E = n == null ? null : Array.from(n), i) : E && E.slice() }, i.tickFormat = function (n) { return arguments.length ? (k = n, i) : k }, i.tickSize = function (n) { return arguments.length ? (_ = S = +n, i) : _ }, i.tickSizeInner = function (n) { return arguments.length ? (_ = +n, i) : _ }, i.tickSizeOuter = function (n) { return arguments.length ? (S = +n, i) : S }, i.tickPadding = function (n) { return arguments.length ? (d = +n, i) : d }, i.offset = function (n) { return arguments.length ? (a = +n, i) : a }, i } function tg(v) { return Hu(Aa, v) } function eg(v) { return Hu(yn, v) } var ig = { value: () => { } }; function Gu() { for (var v = 0, h = arguments.length, b = {}, E; v < h; ++v) { if (!(E = arguments[v] + "") || E in b || /[\s.]/.test(E)) throw new Error("illegal type: " + E); b[E] = [] } return new Ca(b) } function Ca(v) { this._ = v } function rg(v, h) { return v.trim().split(/^|\s+/).map(function (b) { var E = "", k = b.indexOf("."); if (k >= 0 && (E = b.slice(k + 1), b = b.slice(0, k)), b && !h.hasOwnProperty(b)) throw new Error("unknown type: " + b); return { type: b, name: E } }) } Ca.prototype = Gu.prototype = { constructor: Ca, on: function (v, h) { var b = this._, E = rg(v + "", b), k, _ = -1, S = E.length; if (arguments.length < 2) { for (; ++_ < S;)if ((k = (v = E[_]).type) && (k = ng(b[k], v.name))) return k; return } if (h != null && typeof h != "function") throw new Error("invalid callback: " + h); for (; ++_ < S;)if (k = (v = E[_]).type) b[k] = uu(b[k], v.name, h); else if (h == null) for (k in b) b[k] = uu(b[k], v.name, null); return this }, copy: function () { var v = {}, h = this._; for (var b in h) v[b] = h[b].slice(); return new Ca(v) }, call: function (v, h) { if ((k = arguments.length - 2) > 0) for (var b = new Array(k), E = 0, k, _; E < k; ++E)b[E] = arguments[E + 2]; if (!this._.hasOwnProperty(v)) throw new Error("unknown type: " + v); for (_ = this._[v], E = 0, k = _.length; E < k; ++E)_[E].value.apply(h, b) }, apply: function (v, h, b) { if (!this._.hasOwnProperty(v)) throw new Error("unknown type: " + v); for (var E = this._[v], k = 0, _ = E.length; k < _; ++k)E[k].value.apply(h, b) } }; function ng(v, h) { for (var b = 0, E = v.length, k; b < E; ++b)if ((k = v[b]).name === h) return k.value } function uu(v, h, b) { for (var E = 0, k = v.length; E < k; ++E)if (v[E].name === h) { v[E] = ig, v = v.slice(0, E).concat(v.slice(E + 1)); break } return b != null && v.push({ name: h, value: b }), v } var Vs = "http://www.w3.org/1999/xhtml"; const fu = { svg: "http://www.w3.org/2000/svg", xhtml: Vs, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }; function Fa(v) { var h = v += "", b = h.indexOf(":"); return b >= 0 && (h = v.slice(0, b)) !== "xmlns" && (v = v.slice(b + 1)), fu.hasOwnProperty(h) ? { space: fu[h], local: v } : v } function ag(v) { return function () { var h = this.ownerDocument, b = this.namespaceURI; return b === Vs && h.documentElement.namespaceURI === Vs ? h.createElement(v) : h.createElementNS(b, v) } } function sg(v) { return function () { return this.ownerDocument.createElementNS(v.space, v.local) } } function ju(v) { var h = Fa(v); return (h.local ? sg : ag)(h) } function og() { } function Zs(v) { return v == null ? og : function () { return this.querySelector(v) } } function lg(v) { typeof v != "function" && (v = Zs(v)); for (var h = this._groups, b = h.length, E = new Array(b), k = 0; k < b; ++k)for (var _ = h[k], S = _.length, d = E[k] = new Array(S), a, l, c = 0; c < S; ++c)(a = _[c]) && (l = v.call(a, a.__data__, c, _)) && ("__data__" in a && (l.__data__ = a.__data__), d[c] = l); return new Je(E, this._parents) } function ug(v) { return v == null ? [] : Array.isArray(v) ? v : Array.from(v) } function fg() { return [] } function Xu(v) { return v == null ? fg : function () { return this.querySelectorAll(v) } } function hg(v) { return function () { return ug(v.apply(this, arguments)) } } function cg(v) { typeof v == "function" ? v = hg(v) : v = Xu(v); for (var h = this._groups, b = h.length, E = [], k = [], _ = 0; _ < b; ++_)for (var S = h[_], d = S.length, a, l = 0; l < d; ++l)(a = S[l]) && (E.push(v.call(a, a.__data__, l, S)), k.push(a)); return new Je(E, k) } function Ku(v) { return function () { return this.matches(v) } } function qu(v) { return function (h) { return h.matches(v) } } var dg = Array.prototype.find; function gg(v) { return function () { return dg.call(this.children, v) } } function pg() { return this.firstElementChild } function vg(v) { return this.select(v == null ? pg : gg(typeof v == "function" ? v : qu(v))) } var mg = Array.prototype.filter; function yg() { return Array.from(this.children) } function Ag(v) { return function () { return mg.call(this.children, v) } } function Cg(v) { return this.selectAll(v == null ? yg : Ag(typeof v == "function" ? v : qu(v))) } function bg(v) { typeof v != "function" && (v = Ku(v)); for (var h = this._groups, b = h.length, E = new Array(b), k = 0; k < b; ++k)for (var _ = h[k], S = _.length, d = E[k] = [], a, l = 0; l < S; ++l)(a = _[l]) && v.call(a, a.__data__, l, _) && d.push(a); return new Je(E, this._parents) } function Ju(v) { return new Array(v.length) } function wg() { return new Je(this._enter || this._groups.map(Ju), this._parents) } function Sa(v, h) { this.ownerDocument = v.ownerDocument, this.namespaceURI = v.namespaceURI, this._next = null, this._parent = v, this.__data__ = h } Sa.prototype = { constructor: Sa, appendChild: function (v) { return this._parent.insertBefore(v, this._next) }, insertBefore: function (v, h) { return this._parent.insertBefore(v, h) }, querySelector: function (v) { return this._parent.querySelector(v) }, querySelectorAll: function (v) { return this._parent.querySelectorAll(v) } }; function xg(v) { return function () { return v } } function _g(v, h, b, E, k, _) { for (var S = 0, d, a = h.length, l = _.length; S < l; ++S)(d = h[S]) ? (d.__data__ = _[S], E[S] = d) : b[S] = new Sa(v, _[S]); for (; S < a; ++S)(d = h[S]) && (k[S] = d) } function Sg(v, h, b, E, k, _, S) { var d, a, l = new Map, c = h.length, r = _.length, i = new Array(c), n; for (d = 0; d < c; ++d)(a = h[d]) && (i[d] = n = S.call(a, a.__data__, d, h) + "", l.has(n) ? k[d] = a : l.set(n, a)); for (d = 0; d < r; ++d)n = S.call(v, _[d], d, _) + "", (a = l.get(n)) ? (E[d] = a, a.__data__ = _[d], l.delete(n)) : b[d] = new Sa(v, _[d]); for (d = 0; d < c; ++d)(a = h[d]) && l.get(i[d]) === a && (k[d] = a) } function Tg(v) { return v.__data__ } function Eg(v, h) { if (!arguments.length) return Array.from(this, Tg); var b = h ? Sg : _g, E = this._parents, k = this._groups; typeof v != "function" && (v = xg(v)); for (var _ = k.length, S = new Array(_), d = new Array(_), a = new Array(_), l = 0; l < _; ++l) { var c = E[l], r = k[l], i = r.length, n = Ig(v.call(c, c && c.__data__, l, E)), o = n.length, p = d[l] = new Array(o), f = S[l] = new Array(o), m = a[l] = new Array(i); b(c, r, p, f, m, n, h); for (var y = 0, C = 0, x, I; y < o; ++y)if (x = p[y]) { for (y >= C && (C = y + 1); !(I = f[C]) && ++C < o;); x._next = I || null } } return S = new Je(S, E), S._enter = d, S._exit = a, S } function Ig(v) { return typeof v == "object" && "length" in v ? v : Array.from(v) } function Bg() { return new Je(this._exit || this._groups.map(Ju), this._parents) } function kg(v, h, b) { var E = this.enter(), k = this, _ = this.exit(); return typeof v == "function" ? (E = v(E), E && (E = E.selection())) : E = E.append(v + ""), h != null && (k = h(k), k && (k = k.selection())), b == null ? _.remove() : b(_), E && k ? E.merge(k).order() : k } function Mg(v) { for (var h = v.selection ? v.selection() : v, b = this._groups, E = h._groups, k = b.length, _ = E.length, S = Math.min(k, _), d = new Array(k), a = 0; a < S; ++a)for (var l = b[a], c = E[a], r = l.length, i = d[a] = new Array(r), n, o = 0; o < r; ++o)(n = l[o] || c[o]) && (i[o] = n); for (; a < k; ++a)d[a] = b[a]; return new Je(d, this._parents) } function Og() { for (var v = this._groups, h = -1, b = v.length; ++h < b;)for (var E = v[h], k = E.length - 1, _ = E[k], S; --k >= 0;)(S = E[k]) && (_ && S.compareDocumentPosition(_) ^ 4 && _.parentNode.insertBefore(S, _), _ = S); return this } function Dg(v) { v || (v = Lg); function h(r, i) { return r && i ? v(r.__data__, i.__data__) : !r - !i } for (var b = this._groups, E = b.length, k = new Array(E), _ = 0; _ < E; ++_) { for (var S = b[_], d = S.length, a = k[_] = new Array(d), l, c = 0; c < d; ++c)(l = S[c]) && (a[c] = l); a.sort(h) } return new Je(k, this._parents).order() } function Lg(v, h) { return v < h ? -1 : v > h ? 1 : v >= h ? 0 : NaN } function Fg() { var v = arguments[0]; return arguments[0] = this, v.apply(null, arguments), this } function Pg() { return Array.from(this) } function Rg() { for (var v = this._groups, h = 0, b = v.length; h < b; ++h)for (var E = v[h], k = 0, _ = E.length; k < _; ++k) { var S = E[k]; if (S) return S } return null } function Qg() { let v = 0; for (const h of this) ++v; return v } function Wg() { return !this.node() } function Ng(v) { for (var h = this._groups, b = 0, E = h.length; b < E; ++b)for (var k = h[b], _ = 0, S = k.length, d; _ < S; ++_)(d = k[_]) && v.call(d, d.__data__, _, k); return this } function Yg(v) { return function () { this.removeAttribute(v) } } function Vg(v) { return function () { this.removeAttributeNS(v.space, v.local) } } function zg(v, h) { return function () { this.setAttribute(v, h) } } function Ug(v, h) { return function () { this.setAttributeNS(v.space, v.local, h) } } function Hg(v, h) { return function () { var b = h.apply(this, arguments); b == null ? this.removeAttribute(v) : this.setAttribute(v, b) } } function Gg(v, h) { return function () { var b = h.apply(this, arguments); b == null ? this.removeAttributeNS(v.space, v.local) : this.setAttributeNS(v.space, v.local, b) } } function jg(v, h) { var b = Fa(v); if (arguments.length < 2) { var E = this.node(); return b.local ? E.getAttributeNS(b.space, b.local) : E.getAttribute(b) } return this.each((h == null ? b.local ? Vg : Yg : typeof h == "function" ? b.local ? Gg : Hg : b.local ? Ug : zg)(b, h)) } function Zu(v) { return v.ownerDocument && v.ownerDocument.defaultView || v.document && v || v.defaultView } function Xg(v) { return function () { this.style.removeProperty(v) } } function Kg(v, h, b) { return function () { this.style.setProperty(v, h, b) } } function qg(v, h, b) { return function () { var E = h.apply(this, arguments); E == null ? this.style.removeProperty(v) : this.style.setProperty(v, E, b) } } function Jg(v, h, b) { return arguments.length > 1 ? this.each((h == null ? Xg : typeof h == "function" ? qg : Kg)(v, h, b ?? "")) : Pr(this.node(), v) } function Pr(v, h) { return v.style.getPropertyValue(h) || Zu(v).getComputedStyle(v, null).getPropertyValue(h) } function Zg(v) { return function () { delete this[v] } } function $g(v, h) { return function () { this[v] = h } } function tp(v, h) { return function () { var b = h.apply(this, arguments); b == null ? delete this[v] : this[v] = b } } function ep(v, h) { return arguments.length > 1 ? this.each((h == null ? Zg : typeof h == "function" ? tp : $g)(v, h)) : this.node()[v] } function $u(v) { return v.trim().split(/^|\s+/) } function $s(v) { return v.classList || new tf(v) } function tf(v) { this._node = v, this._names = $u(v.getAttribute("class") || "") } tf.prototype = { add: function (v) { var h = this._names.indexOf(v); h < 0 && (this._names.push(v), this._node.setAttribute("class", this._names.join(" "))) }, remove: function (v) { var h = this._names.indexOf(v); h >= 0 && (this._names.splice(h, 1), this._node.setAttribute("class", this._names.join(" "))) }, contains: function (v) { return this._names.indexOf(v) >= 0 } }; function ef(v, h) { for (var b = $s(v), E = -1, k = h.length; ++E < k;)b.add(h[E]) } function rf(v, h) { for (var b = $s(v), E = -1, k = h.length; ++E < k;)b.remove(h[E]) } function ip(v) { return function () { ef(this, v) } } function rp(v) { return function () { rf(this, v) } } function np(v, h) { return function () { (h.apply(this, arguments) ? ef : rf)(this, v) } } function td(v, h) { var b = $u(v + ""); if (arguments.length < 2) { for (var E = $s(this.node()), k = -1, _ = b.length; ++k < _;)if (!E.contains(b[k])) return !1; return !0 } return this.each((typeof h == "function" ? np : h ? ip : rp)(b, h)) } function sp() { this.textContent = "" } function op(v) { return function () { this.textContent = v } } function lp(v) { return function () { var h = v.apply(this, arguments); this.textContent = h ?? "" } } function up(v) { return arguments.length ? this.each(v == null ? sp : (typeof v == "function" ? lp : op)(v)) : this.node().textContent } function fp() { this.innerHTML = "" } function hp(v) { return function () { this.innerHTML = v } } function cp(v) { return function () { var h = v.apply(this, arguments); this.innerHTML = h ?? "" } } function dp(v) { return arguments.length ? this.each(v == null ? fp : (typeof v == "function" ? cp : hp)(v)) : this.node().innerHTML } function gp() { this.nextSibling && this.parentNode.appendChild(this) } function pp() { return this.each(gp) } function vp() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild) } function mp() { return this.each(vp) } function yp(v) { var h = typeof v == "function" ? v : ju(v); return this.select(function () { return this.appendChild(h.apply(this, arguments)) }) } function Ap() { return null } function Cp(v, h) { var b = typeof v == "function" ? v : ju(v), E = h == null ? Ap : typeof h == "function" ? h : Zs(h); return this.select(function () { return this.insertBefore(b.apply(this, arguments), E.apply(this, arguments) || null) }) } function bp() { var v = this.parentNode; v && v.removeChild(this) } function wp() { return this.each(bp) } function xp() { var v = this.cloneNode(!1), h = this.parentNode; return h ? h.insertBefore(v, this.nextSibling) : v } function _p() { var v = this.cloneNode(!0), h = this.parentNode; return h ? h.insertBefore(v, this.nextSibling) : v } function Sp(v) { return this.select(v ? _p : xp) } function Tp(v) { return arguments.length ? this.property("__data__", v) : this.node().__data__ } function Ep(v) { return function (h) { v.call(this, h, this.__data__) } } function Ip(v) { return v.trim().split(/^|\s+/).map(function (h) { var b = "", E = h.indexOf("."); return E >= 0 && (b = h.slice(E + 1), h = h.slice(0, E)), { type: h, name: b } }) } function Bp(v) { return function () { var h = this.__on; if (h) { for (var b = 0, E = -1, k = h.length, _; b < k; ++b)_ = h[b], (!v.type || _.type === v.type) && _.name === v.name ? this.removeEventListener(_.type, _.listener, _.options) : h[++E] = _; ++E ? h.length = E : delete this.__on } } } function kp(v, h, b) { return function () { var E = this.__on, k, _ = Ep(h); if (E) { for (var S = 0, d = E.length; S < d; ++S)if ((k = E[S]).type === v.type && k.name === v.name) { this.removeEventListener(k.type, k.listener, k.options), this.addEventListener(k.type, k.listener = _, k.options = b), k.value = h; return } } this.addEventListener(v.type, _, b), k = { type: v.type, name: v.name, value: h, listener: _, options: b }, E ? E.push(k) : this.__on = [k] } } function Mp(v, h, b) { var E = Ip(v + ""), k, _ = E.length, S; if (arguments.length < 2) { var d = this.node().__on; if (d) { for (var a = 0, l = d.length, c; a < l; ++a)for (k = 0, c = d[a]; k < _; ++k)if ((S = E[k]).type === c.type && S.name === c.name) return c.value } return } for (d = h ? kp : Bp, k = 0; k < _; ++k)this.each(d(E[k], h, b)); return this } function nf(v, h, b) { var E = Zu(v), k = E.CustomEvent; typeof k == "function" ? k = new k(h, b) : (k = E.document.createEvent("Event"), b ? (k.initEvent(h, b.bubbles, b.cancelable), k.detail = b.detail) : k.initEvent(h, !1, !1)), v.dispatchEvent(k) } function Op(v, h) { return function () { return nf(this, v, h) } } function Dp(v, h) { return function () { return nf(this, v, h.apply(this, arguments)) } } function Lp(v, h) { return this.each((typeof h == "function" ? Dp : Op)(v, h)) } function* Fp() { for (var v = this._groups, h = 0, b = v.length; h < b; ++h)for (var E = v[h], k = 0, _ = E.length, S; k < _; ++k)(S = E[k]) && (yield S) } var af = [null]; function Je(v, h) { this._groups = v, this._parents = h } function In() { return new Je([[document.documentElement]], af) } function Pp() { return this } Je.prototype = In.prototype = { constructor: Je, select: lg, selectAll: cg, selectChild: vg, selectChildren: Cg, filter: bg, data: Eg, enter: wg, exit: Bg, join: kg, merge: Mg, selection: Pp, order: Og, sort: Dg, call: Fg, nodes: Pg, node: Rg, size: Qg, empty: Wg, each: Ng, attr: jg, style: Jg, property: ep, classed: td, text: up, html: dp, raise: pp, lower: mp, append: yp, insert: Cp, remove: wp, clone: Sp, datum: Tp, on: Mp, dispatch: Lp, [Symbol.iterator]: Fp }; function Rp(v) { return typeof v == "string" ? new Je([[document.querySelector(v)]], [document.documentElement]) : new Je([[v]], af) } function to(v, h, b) { v.prototype = h.prototype = b, b.constructor = v } function sf(v, h) { var b = Object.create(v.prototype); for (var E in h) b[E] = h[E]; return b } function Bn() { } var xn = .7, Ta = 1 / xn, Fr = "\\s*([+-]?\\d+)\\s*", _n = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ai = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Qp = /^#([0-9a-f]{3,8})$/, Wp = new RegExp(`^rgb\\(${Fr},${Fr},${Fr}\\)$`), Np = new RegExp(`^rgb\\(${Ai},${Ai},${Ai}\\)$`), Yp = new RegExp(`^rgba\\(${Fr},${Fr},${Fr},${_n}\\)$`), Vp = new RegExp(`^rgba\\(${Ai},${Ai},${Ai},${_n}\\)$`), zp = new RegExp(`^hsl\\(${_n},${Ai},${Ai}\\)$`), Up = new RegExp(`^hsla\\(${_n},${Ai},${Ai},${_n}\\)$`), hu = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; to(Bn, ur, { copy(v) { return Object.assign(new this.constructor, this, v) }, displayable() { return this.rgb().displayable() }, hex: cu, formatHex: cu, formatHex8: Hp, formatHsl: Gp, formatRgb: du, toString: du }); function cu() { return this.rgb().formatHex() } function Hp() { return this.rgb().formatHex8() } function Gp() { return of(this).formatHsl() } function du() { return this.rgb().formatRgb() } function ur(v) { var h, b; return v = (v + "").trim().toLowerCase(), (h = Qp.exec(v)) ? (b = h[1].length, h = parseInt(h[1], 16), b === 6 ? gu(h) : b === 3 ? new je(h >> 8 & 15 | h >> 4 & 240, h >> 4 & 15 | h & 240, (h & 15) << 4 | h & 15, 1) : b === 8 ? ca(h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, (h & 255) / 255) : b === 4 ? ca(h >> 12 & 15 | h >> 8 & 240, h >> 8 & 15 | h >> 4 & 240, h >> 4 & 15 | h & 240, ((h & 15) << 4 | h & 15) / 255) : null) : (h = Wp.exec(v)) ? new je(h[1], h[2], h[3], 1) : (h = Np.exec(v)) ? new je(h[1] * 255 / 100, h[2] * 255 / 100, h[3] * 255 / 100, 1) : (h = Yp.exec(v)) ? ca(h[1], h[2], h[3], h[4]) : (h = Vp.exec(v)) ? ca(h[1] * 255 / 100, h[2] * 255 / 100, h[3] * 255 / 100, h[4]) : (h = zp.exec(v)) ? mu(h[1], h[2] / 100, h[3] / 100, 1) : (h = Up.exec(v)) ? mu(h[1], h[2] / 100, h[3] / 100, h[4]) : hu.hasOwnProperty(v) ? gu(hu[v]) : v === "transparent" ? new je(NaN, NaN, NaN, 0) : null } function gu(v) { return new je(v >> 16 & 255, v >> 8 & 255, v & 255, 1) } function ca(v, h, b, E) { return E <= 0 && (v = h = b = NaN), new je(v, h, b, E) } function jp(v) { return v instanceof Bn || (v = ur(v)), v ? (v = v.rgb(), new je(v.r, v.g, v.b, v.opacity)) : new je } function zs(v, h, b, E) { return arguments.length === 1 ? jp(v) : new je(v, h, b, E ?? 1) } function je(v, h, b, E) { this.r = +v, this.g = +h, this.b = +b, this.opacity = +E } to(je, zs, sf(Bn, { brighter(v) { return v = v == null ? Ta : Math.pow(Ta, v), new je(this.r * v, this.g * v, this.b * v, this.opacity) }, darker(v) { return v = v == null ? xn : Math.pow(xn, v), new je(this.r * v, this.g * v, this.b * v, this.opacity) }, rgb() { return this }, clamp() { return new je(lr(this.r), lr(this.g), lr(this.b), Ea(this.opacity)) }, displayable() { return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1 }, hex: pu, formatHex: pu, formatHex8: Xp, formatRgb: vu, toString: vu })); function pu() { return `#${or(this.r)}${or(this.g)}${or(this.b)}` } function Xp() { return `#${or(this.r)}${or(this.g)}${or(this.b)}${or((isNaN(this.opacity) ? 1 : this.opacity) * 255)}` } function vu() { const v = Ea(this.opacity); return `${v === 1 ? "rgb(" : "rgba("}${lr(this.r)}, ${lr(this.g)}, ${lr(this.b)}${v === 1 ? ")" : `, ${v})`}` } function Ea(v) { return isNaN(v) ? 1 : Math.max(0, Math.min(1, v)) } function lr(v) { return Math.max(0, Math.min(255, Math.round(v) || 0)) } function or(v) { return v = lr(v), (v < 16 ? "0" : "") + v.toString(16) } function mu(v, h, b, E) { return E <= 0 ? v = h = b = NaN : b <= 0 || b >= 1 ? v = h = NaN : h <= 0 && (v = NaN), new li(v, h, b, E) } function of(v) { if (v instanceof li) return new li(v.h, v.s, v.l, v.opacity); if (v instanceof Bn || (v = ur(v)), !v) return new li; if (v instanceof li) return v; v = v.rgb(); var h = v.r / 255, b = v.g / 255, E = v.b / 255, k = Math.min(h, b, E), _ = Math.max(h, b, E), S = NaN, d = _ - k, a = (_ + k) / 2; return d ? (h === _ ? S = (b - E) / d + (b < E) * 6 : b === _ ? S = (E - h) / d + 2 : S = (h - b) / d + 4, d /= a < .5 ? _ + k : 2 - _ - k, S *= 60) : d = a > 0 && a < 1 ? 0 : S, new li(S, d, a, v.opacity) } function Kp(v, h, b, E) { return arguments.length === 1 ? of(v) : new li(v, h, b, E ?? 1) } function li(v, h, b, E) { this.h = +v, this.s = +h, this.l = +b, this.opacity = +E } to(li, Kp, sf(Bn, { brighter(v) { return v = v == null ? Ta : Math.pow(Ta, v), new li(this.h, this.s, this.l * v, this.opacity) }, darker(v) { return v = v == null ? xn : Math.pow(xn, v), new li(this.h, this.s, this.l * v, this.opacity) }, rgb() { var v = this.h % 360 + (this.h < 0) * 360, h = isNaN(v) || isNaN(this.s) ? 0 : this.s, b = this.l, E = b + (b < .5 ? b : 1 - b) * h, k = 2 * b - E; return new je(Fs(v >= 240 ? v - 240 : v + 120, k, E), Fs(v, k, E), Fs(v < 120 ? v + 240 : v - 120, k, E), this.opacity) }, clamp() { return new li(yu(this.h), da(this.s), da(this.l), Ea(this.opacity)) }, displayable() { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 }, formatHsl() { const v = Ea(this.opacity); return `${v === 1 ? "hsl(" : "hsla("}${yu(this.h)}, ${da(this.s) * 100}%, ${da(this.l) * 100}%${v === 1 ? ")" : `, ${v})`}` } })); function yu(v) { return v = (v || 0) % 360, v < 0 ? v + 360 : v } function da(v) { return Math.max(0, Math.min(1, v || 0)) } function Fs(v, h, b) { return (v < 60 ? h + (b - h) * v / 60 : v < 180 ? b : v < 240 ? h + (b - h) * (240 - v) / 60 : h) * 255 } const eo = v => () => v; function qp(v, h) { return function (b) { return v + b * h } } function Jp(v, h, b) { return v = Math.pow(v, b), h = Math.pow(h, b) - v, b = 1 / b, function (E) { return Math.pow(v + E * h, b) } } function Zp(v) { return (v = +v) == 1 ? lf : function (h, b) { return b - h ? Jp(h, b, v) : eo(isNaN(h) ? b : h) } } function lf(v, h) { var b = h - v; return b ? qp(v, b) : eo(isNaN(v) ? h : v) } const Ia = function v(h) { var b = Zp(h); function E(k, _) { var S = b((k = zs(k)).r, (_ = zs(_)).r), d = b(k.g, _.g), a = b(k.b, _.b), l = lf(k.opacity, _.opacity); return function (c) { return k.r = S(c), k.g = d(c), k.b = a(c), k.opacity = l(c), k + "" } } return E.gamma = v, E }(1); function $p(v, h) { h || (h = []); var b = v ? Math.min(h.length, v.length) : 0, E = h.slice(), k; return function (_) { for (k = 0; k < b; ++k)E[k] = v[k] * (1 - _) + h[k] * _; return E } } function tv(v) { return ArrayBuffer.isView(v) && !(v instanceof DataView) } function ev(v, h) { var b = h ? h.length : 0, E = v ? Math.min(b, v.length) : 0, k = new Array(E), _ = new Array(b), S; for (S = 0; S < E; ++S)k[S] = io(v[S], h[S]); for (; S < b; ++S)_[S] = h[S]; return function (d) { for (S = 0; S < E; ++S)_[S] = k[S](d); return _ } } function iv(v, h) { var b = new Date; return v = +v, h = +h, function (E) { return b.setTime(v * (1 - E) + h * E), b } } function oi(v, h) { return v = +v, h = +h, function (b) { return v * (1 - b) + h * b } } function rv(v, h) { var b = {}, E = {}, k; (v === null || typeof v != "object") && (v = {}), (h === null || typeof h != "object") && (h = {}); for (k in h) k in v ? b[k] = io(v[k], h[k]) : E[k] = h[k]; return function (_) { for (k in b) E[k] = b[k](_); return E } } var Us = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Ps = new RegExp(Us.source, "g"); function nv(v) { return function () { return v } } function av(v) { return function (h) { return v(h) + "" } } function uf(v, h) { var b = Us.lastIndex = Ps.lastIndex = 0, E, k, _, S = -1, d = [], a = []; for (v = v + "", h = h + ""; (E = Us.exec(v)) && (k = Ps.exec(h));)(_ = k.index) > b && (_ = h.slice(b, _), d[S] ? d[S] += _ : d[++S] = _), (E = E[0]) === (k = k[0]) ? d[S] ? d[S] += k : d[++S] = k : (d[++S] = null, a.push({ i: S, x: oi(E, k) })), b = Ps.lastIndex; return b < h.length && (_ = h.slice(b), d[S] ? d[S] += _ : d[++S] = _), d.length < 2 ? a[0] ? av(a[0].x) : nv(h) : (h = a.length, function (l) { for (var c = 0, r; c < h; ++c)d[(r = a[c]).i] = r.x(l); return d.join("") }) } function io(v, h) { var b = typeof h, E; return h == null || b === "boolean" ? eo(h) : (b === "number" ? oi : b === "string" ? (E = ur(h)) ? (h = E, Ia) : uf : h instanceof ur ? Ia : h instanceof Date ? iv : tv(h) ? $p : Array.isArray(h) ? ev : typeof h.valueOf != "function" && typeof h.toString != "function" || isNaN(h) ? rv : oi)(v, h) } function sv(v, h) { return v = +v, h = +h, function (b) { return Math.round(v * (1 - b) + h * b) } } var Au = 180 / Math.PI, Hs = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }; function ff(v, h, b, E, k, _) { var S, d, a; return (S = Math.sqrt(v * v + h * h)) && (v /= S, h /= S), (a = v * b + h * E) && (b -= v * a, E -= h * a), (d = Math.sqrt(b * b + E * E)) && (b /= d, E /= d, a /= d), v * E < h * b && (v = -v, h = -h, a = -a, S = -S), { translateX: k, translateY: _, rotate: Math.atan2(h, v) * Au, skewX: Math.atan(a) * Au, scaleX: S, scaleY: d } } var ga; function ov(v) { const h = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(v + ""); return h.isIdentity ? Hs : ff(h.a, h.b, h.c, h.d, h.e, h.f) } function lv(v) { return v == null || (ga || (ga = document.createElementNS("http://www.w3.org/2000/svg", "g")), ga.setAttribute("transform", v), !(v = ga.transform.baseVal.consolidate())) ? Hs : (v = v.matrix, ff(v.a, v.b, v.c, v.d, v.e, v.f)) } function hf(v, h, b, E) { function k(l) { return l.length ? l.pop() + " " : "" } function _(l, c, r, i, n, o) { if (l !== r || c !== i) { var p = n.push("translate(", null, h, null, b); o.push({ i: p - 4, x: oi(l, r) }, { i: p - 2, x: oi(c, i) }) } else (r || i) && n.push("translate(" + r + h + i + b) } function S(l, c, r, i) { l !== c ? (l - c > 180 ? c += 360 : c - l > 180 && (l += 360), i.push({ i: r.push(k(r) + "rotate(", null, E) - 2, x: oi(l, c) })) : c && r.push(k(r) + "rotate(" + c + E) } function d(l, c, r, i) { l !== c ? i.push({ i: r.push(k(r) + "skewX(", null, E) - 2, x: oi(l, c) }) : c && r.push(k(r) + "skewX(" + c + E) } function a(l, c, r, i, n, o) { if (l !== r || c !== i) { var p = n.push(k(n) + "scale(", null, ",", null, ")"); o.push({ i: p - 4, x: oi(l, r) }, { i: p - 2, x: oi(c, i) }) } else (r !== 1 || i !== 1) && n.push(k(n) + "scale(" + r + "," + i + ")") } return function (l, c) { var r = [], i = []; return l = v(l), c = v(c), _(l.translateX, l.translateY, c.translateX, c.translateY, r, i), S(l.rotate, c.rotate, r, i), d(l.skewX, c.skewX, r, i), a(l.scaleX, l.scaleY, c.scaleX, c.scaleY, r, i), l = c = null, function (n) { for (var o = -1, p = i.length, f; ++o < p;)r[(f = i[o]).i] = f.x(n); return r.join("") } } } var uv = hf(ov, "px, ", "px)", "deg)"), fv = hf(lv, ", ", ")", ")"), Rr = 0, An = 0, mn = 0, cf = 1e3, Ba, Cn, ka = 0, fr = 0, Pa = 0, Sn = typeof performance == "object" && performance.now ? performance : Date, df = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (v) { setTimeout(v, 17) }; function ro() { return fr || (df(hv), fr = Sn.now() + Pa) } function hv() { fr = 0 } function Ma() { this._call = this._time = this._next = null } Ma.prototype = gf.prototype = { constructor: Ma, restart: function (v, h, b) { if (typeof v != "function") throw new TypeError("callback is not a function"); b = (b == null ? ro() : +b) + (h == null ? 0 : +h), !this._next && Cn !== this && (Cn ? Cn._next = this : Ba = this, Cn = this), this._call = v, this._time = b, Gs() }, stop: function () { this._call && (this._call = null, this._time = 1 / 0, Gs()) } }; function gf(v, h, b) { var E = new Ma; return E.restart(v, h, b), E } function cv() { ro(), ++Rr; for (var v = Ba, h; v;)(h = fr - v._time) >= 0 && v._call.call(void 0, h), v = v._next; --Rr } function Cu() { fr = (ka = Sn.now()) + Pa, Rr = An = 0; try { cv() } finally { Rr = 0, gv(), fr = 0 } } function dv() { var v = Sn.now(), h = v - ka; h > cf && (Pa -= h, ka = v) } function gv() { for (var v, h = Ba, b, E = 1 / 0; h;)h._call ? (E > h._time && (E = h._time), v = h, h = h._next) : (b = h._next, h._next = null, h = v ? v._next = b : Ba = b); Cn = v, Gs(E) } function Gs(v) { if (!Rr) { An && (An = clearTimeout(An)); var h = v - fr; h > 24 ? (v < 1 / 0 && (An = setTimeout(Cu, v - Sn.now() - Pa)), mn && (mn = clearInterval(mn))) : (mn || (ka = Sn.now(), mn = setInterval(dv, cf)), Rr = 1, df(Cu)) } } function bu(v, h, b) { var E = new Ma; return h = h == null ? 0 : +h, E.restart(k => { E.stop(), v(k + h) }, h, b), E } var pv = Gu("start", "end", "cancel", "interrupt"), vv = [], pf = 0, wu = 1, js = 2, ba = 3, xu = 4, Xs = 5, wa = 6; function Ra(v, h, b, E, k, _) { var S = v.__transition; if (!S) v.__transition = {}; else if (b in S) return; mv(v, b, { name: h, index: E, group: k, on: pv, tween: vv, time: _.time, delay: _.delay, duration: _.duration, ease: _.ease, timer: null, state: pf }) } function no(v, h) { var b = ui(v, h); if (b.state > pf) throw new Error("too late; already scheduled"); return b } function bi(v, h) { var b = ui(v, h); if (b.state > ba) throw new Error("too late; already running"); return b } function ui(v, h) { var b = v.__transition; if (!b || !(b = b[h])) throw new Error("transition not found"); return b } function mv(v, h, b) { var E = v.__transition, k; E[h] = b, b.timer = gf(_, 0, b.time); function _(l) { b.state = wu, b.timer.restart(S, b.delay, b.time), b.delay <= l && S(l - b.delay) } function S(l) { var c, r, i, n; if (b.state !== wu) return a(); for (c in E) if (n = E[c], n.name === b.name) { if (n.state === ba) return bu(S); n.state === xu ? (n.state = wa, n.timer.stop(), n.on.call("interrupt", v, v.__data__, n.index, n.group), delete E[c]) : +c < h && (n.state = wa, n.timer.stop(), n.on.call("cancel", v, v.__data__, n.index, n.group), delete E[c]) } if (bu(function () { b.state === ba && (b.state = xu, b.timer.restart(d, b.delay, b.time), d(l)) }), b.state = js, b.on.call("start", v, v.__data__, b.index, b.group), b.state === js) { for (b.state = ba, k = new Array(i = b.tween.length), c = 0, r = -1; c < i; ++c)(n = b.tween[c].value.call(v, v.__data__, b.index, b.group)) && (k[++r] = n); k.length = r + 1 } } function d(l) { for (var c = l < b.duration ? b.ease.call(null, l / b.duration) : (b.timer.restart(a), b.state = Xs, 1), r = -1, i = k.length; ++r < i;)k[r].call(v, c); b.state === Xs && (b.on.call("end", v, v.__data__, b.index, b.group), a()) } function a() { b.state = wa, b.timer.stop(), delete E[h]; for (var l in E) return; delete v.__transition } } function yv(v, h) { var b = v.__transition, E, k, _ = !0, S; if (b) { h = h == null ? null : h + ""; for (S in b) { if ((E = b[S]).name !== h) { _ = !1; continue } k = E.state > js && E.state < Xs, E.state = wa, E.timer.stop(), E.on.call(k ? "interrupt" : "cancel", v, v.__data__, E.index, E.group), delete b[S] } _ && delete v.__transition } } function Av(v) { return this.each(function () { yv(this, v) }) } function Cv(v, h) { var b, E; return function () { var k = bi(this, v), _ = k.tween; if (_ !== b) { E = b = _; for (var S = 0, d = E.length; S < d; ++S)if (E[S].name === h) { E = E.slice(), E.splice(S, 1); break } } k.tween = E } } function bv(v, h, b) { var E, k; if (typeof b != "function") throw new Error; return function () { var _ = bi(this, v), S = _.tween; if (S !== E) { k = (E = S).slice(); for (var d = { name: h, value: b }, a = 0, l = k.length; a < l; ++a)if (k[a].name === h) { k[a] = d; break } a === l && k.push(d) } _.tween = k } } function wv(v, h) { var b = this._id; if (v += "", arguments.length < 2) { for (var E = ui(this.node(), b).tween, k = 0, _ = E.length, S; k < _; ++k)if ((S = E[k]).name === v) return S.value; return null } return this.each((h == null ? Cv : bv)(b, v, h)) } function ao(v, h, b) { var E = v._id; return v.each(function () { var k = bi(this, E); (k.value || (k.value = {}))[h] = b.apply(this, arguments) }), function (k) { return ui(k, E).value[h] } } function vf(v, h) { var b; return (typeof h == "number" ? oi : h instanceof ur ? Ia : (b = ur(h)) ? (h = b, Ia) : uf)(v, h) } function xv(v) { return function () { this.removeAttribute(v) } } function _v(v) { return function () { this.removeAttributeNS(v.space, v.local) } } function Sv(v, h, b) { var E, k = b + "", _; return function () { var S = this.getAttribute(v); return S === k ? null : S === E ? _ : _ = h(E = S, b) } } function Tv(v, h, b) { var E, k = b + "", _; return function () { var S = this.getAttributeNS(v.space, v.local); return S === k ? null : S === E ? _ : _ = h(E = S, b) } } function Ev(v, h, b) { var E, k, _; return function () { var S, d = b(this), a; return d == null ? void this.removeAttribute(v) : (S = this.getAttribute(v), a = d + "", S === a ? null : S === E && a === k ? _ : (k = a, _ = h(E = S, d))) } } function Iv(v, h, b) { var E, k, _; return function () { var S, d = b(this), a; return d == null ? void this.removeAttributeNS(v.space, v.local) : (S = this.getAttributeNS(v.space, v.local), a = d + "", S === a ? null : S === E && a === k ? _ : (k = a, _ = h(E = S, d))) } } function Bv(v, h) { var b = Fa(v), E = b === "transform" ? fv : vf; return this.attrTween(v, typeof h == "function" ? (b.local ? Iv : Ev)(b, E, ao(this, "attr." + v, h)) : h == null ? (b.local ? _v : xv)(b) : (b.local ? Tv : Sv)(b, E, h)) } function kv(v, h) { return function (b) { this.setAttribute(v, h.call(this, b)) } } function Mv(v, h) { return function (b) { this.setAttributeNS(v.space, v.local, h.call(this, b)) } } function Ov(v, h) { var b, E; function k() { var _ = h.apply(this, arguments); return _ !== E && (b = (E = _) && Mv(v, _)), b } return k._value = h, k } function Dv(v, h) { var b, E; function k() { var _ = h.apply(this, arguments); return _ !== E && (b = (E = _) && kv(v, _)), b } return k._value = h, k } function Lv(v, h) { var b = "attr." + v; if (arguments.length < 2) return (b = this.tween(b)) && b._value; if (h == null) return this.tween(b, null); if (typeof h != "function") throw new Error; var E = Fa(v); return this.tween(b, (E.local ? Ov : Dv)(E, h)) } function Fv(v, h) { return function () { no(this, v).delay = +h.apply(this, arguments) } } function Pv(v, h) { return h = +h, function () { no(this, v).delay = h } } function Rv(v) { var h = this._id; return arguments.length ? this.each((typeof v == "function" ? Fv : Pv)(h, v)) : ui(this.node(), h).delay } function Qv(v, h) { return function () { bi(this, v).duration = +h.apply(this, arguments) } } function Wv(v, h) { return h = +h, function () { bi(this, v).duration = h } } function Nv(v) { var h = this._id; return arguments.length ? this.each((typeof v == "function" ? Qv : Wv)(h, v)) : ui(this.node(), h).duration } function Yv(v, h) { if (typeof h != "function") throw new Error; return function () { bi(this, v).ease = h } } function Vv(v) { var h = this._id; return arguments.length ? this.each(Yv(h, v)) : ui(this.node(), h).ease } function zv(v, h) { return function () { var b = h.apply(this, arguments); if (typeof b != "function") throw new Error; bi(this, v).ease = b } } function Uv(v) { if (typeof v != "function") throw new Error; return this.each(zv(this._id, v)) } function Hv(v) { typeof v != "function" && (v = Ku(v)); for (var h = this._groups, b = h.length, E = new Array(b), k = 0; k < b; ++k)for (var _ = h[k], S = _.length, d = E[k] = [], a, l = 0; l < S; ++l)(a = _[l]) && v.call(a, a.__data__, l, _) && d.push(a); return new Di(E, this._parents, this._name, this._id) } function Gv(v) { if (v._id !== this._id) throw new Error; for (var h = this._groups, b = v._groups, E = h.length, k = b.length, _ = Math.min(E, k), S = new Array(E), d = 0; d < _; ++d)for (var a = h[d], l = b[d], c = a.length, r = S[d] = new Array(c), i, n = 0; n < c; ++n)(i = a[n] || l[n]) && (r[n] = i); for (; d < E; ++d)S[d] = h[d]; return new Di(S, this._parents, this._name, this._id) } function jv(v) { return (v + "").trim().split(/^|\s+/).every(function (h) { var b = h.indexOf("."); return b >= 0 && (h = h.slice(0, b)), !h || h === "start" }) } function Xv(v, h, b) { var E, k, _ = jv(h) ? no : bi; return function () { var S = _(this, v), d = S.on; d !== E && (k = (E = d).copy()).on(h, b), S.on = k } } function Kv(v, h) { var b = this._id; return arguments.length < 2 ? ui(this.node(), b).on.on(v) : this.each(Xv(b, v, h)) } function qv(v) { return function () { var h = this.parentNode; for (var b in this.__transition) if (+b !== v) return; h && h.removeChild(this) } } function Jv() { return this.on("end.remove", qv(this._id)) } function Zv(v) { var h = this._name, b = this._id; typeof v != "function" && (v = Zs(v)); for (var E = this._groups, k = E.length, _ = new Array(k), S = 0; S < k; ++S)for (var d = E[S], a = d.length, l = _[S] = new Array(a), c, r, i = 0; i < a; ++i)(c = d[i]) && (r = v.call(c, c.__data__, i, d)) && ("__data__" in c && (r.__data__ = c.__data__), l[i] = r, Ra(l[i], h, b, i, l, ui(c, b))); return new Di(_, this._parents, h, b) } function $v(v) { var h = this._name, b = this._id; typeof v != "function" && (v = Xu(v)); for (var E = this._groups, k = E.length, _ = [], S = [], d = 0; d < k; ++d)for (var a = E[d], l = a.length, c, r = 0; r < l; ++r)if (c = a[r]) { for (var i = v.call(c, c.__data__, r, a), n, o = ui(c, b), p = 0, f = i.length; p < f; ++p)(n = i[p]) && Ra(n, h, b, p, i, o); _.push(i), S.push(c) } return new Di(_, S, h, b) } var tm = In.prototype.constructor; function em() { return new tm(this._groups, this._parents) } function im(v, h) { var b, E, k; return function () { var _ = Pr(this, v), S = (this.style.removeProperty(v), Pr(this, v)); return _ === S ? null : _ === b && S === E ? k : k = h(b = _, E = S) } } function mf(v) { return function () { this.style.removeProperty(v) } } function rm(v, h, b) { var E, k = b + "", _; return function () { var S = Pr(this, v); return S === k ? null : S === E ? _ : _ = h(E = S, b) } } function nm(v, h, b) { var E, k, _; return function () { var S = Pr(this, v), d = b(this), a = d + ""; return d == null && (a = d = (this.style.removeProperty(v), Pr(this, v))), S === a ? null : S === E && a === k ? _ : (k = a, _ = h(E = S, d)) } } function am(v, h) { var b, E, k, _ = "style." + h, S = "end." + _, d; return function () { var a = bi(this, v), l = a.on, c = a.value[_] == null ? d || (d = mf(h)) : void 0; (l !== b || k !== c) && (E = (b = l).copy()).on(S, k = c), a.on = E } } function sm(v, h, b) { var E = (v += "") == "transform" ? uv : vf; return h == null ? this.styleTween(v, im(v, E)).on("end.style." + v, mf(v)) : typeof h == "function" ? this.styleTween(v, nm(v, E, ao(this, "style." + v, h))).each(am(this._id, v)) : this.styleTween(v, rm(v, E, h), b).on("end.style." + v, null) } function om(v, h, b) { return function (E) { this.style.setProperty(v, h.call(this, E), b) } } function lm(v, h, b) { var E, k; function _() { var S = h.apply(this, arguments); return S !== k && (E = (k = S) && om(v, S, b)), E } return _._value = h, _ } function um(v, h, b) { var E = "style." + (v += ""); if (arguments.length < 2) return (E = this.tween(E)) && E._value; if (h == null) return this.tween(E, null); if (typeof h != "function") throw new Error; return this.tween(E, lm(v, h, b ?? "")) } function fm(v) { return function () { this.textContent = v } } function hm(v) { return function () { var h = v(this); this.textContent = h ?? "" } } function cm(v) { return this.tween("text", typeof v == "function" ? hm(ao(this, "text", v)) : fm(v == null ? "" : v + "")) } function dm(v) { return function (h) { this.textContent = v.call(this, h) } } function gm(v) { var h, b; function E() { var k = v.apply(this, arguments); return k !== b && (h = (b = k) && dm(k)), h } return E._value = v, E } function pm(v) { var h = "text"; if (arguments.length < 1) return (h = this.tween(h)) && h._value; if (v == null) return this.tween(h, null); if (typeof v != "function") throw new Error; return this.tween(h, gm(v)) } function vm() { for (var v = this._name, h = this._id, b = yf(), E = this._groups, k = E.length, _ = 0; _ < k; ++_)for (var S = E[_], d = S.length, a, l = 0; l < d; ++l)if (a = S[l]) { var c = ui(a, h); Ra(a, v, b, l, S, { time: c.time + c.delay + c.duration, delay: 0, duration: c.duration, ease: c.ease }) } return new Di(E, this._parents, v, b) } function mm() { var v, h, b = this, E = b._id, k = b.size(); return new Promise(function (_, S) { var d = { value: S }, a = { value: function () { --k === 0 && _() } }; b.each(function () { var l = bi(this, E), c = l.on; c !== v && (h = (v = c).copy(), h._.cancel.push(d), h._.interrupt.push(d), h._.end.push(a)), l.on = h }), k === 0 && _() }) } var ym = 0; function Di(v, h, b, E) { this._groups = v, this._parents = h, this._name = b, this._id = E } function yf() { return ++ym } var Oi = In.prototype; Di.prototype = { constructor: Di, select: Zv, selectAll: $v, selectChild: Oi.selectChild, selectChildren: Oi.selectChildren, filter: Hv, merge: Gv, selection: em, transition: vm, call: Oi.call, nodes: Oi.nodes, node: Oi.node, size: Oi.size, empty: Oi.empty, each: Oi.each, on: Kv, attr: Bv, attrTween: Lv, style: sm, styleTween: um, text: cm, textTween: pm, remove: Jv, tween: wv, delay: Rv, duration: Nv, ease: Vv, easeVarying: Uv, end: mm, [Symbol.iterator]: Oi[Symbol.iterator] }; function Am(v) { return ((v *= 2) <= 1 ? v * v * v : (v -= 2) * v * v + 2) / 2 } var Cm = { time: null, delay: 0, duration: 250, ease: Am }; function bm(v, h) { for (var b; !(b = v.__transition) || !(b = b[h]);)if (!(v = v.parentNode)) throw new Error(`transition ${h} not found`); return b } function wm(v) { var h, b; v instanceof Di ? (h = v._id, v = v._name) : (h = yf(), (b = Cm).time = ro(), v = v == null ? null : v + ""); for (var E = this._groups, k = E.length, _ = 0; _ < k; ++_)for (var S = E[_], d = S.length, a, l = 0; l < d; ++l)(a = S[l]) && Ra(a, v, h, l, S, b || bm(a, h)); return new Di(E, this._parents, v, h) } In.prototype.interrupt = Av; In.prototype.transition = wm; function xm(v) { return Math.abs(v = Math.round(v)) >= 1e21 ? v.toLocaleString("en").replace(/,/g, "") : v.toString(10) } function Oa(v, h) { if ((b = (v = h ? v.toExponential(h - 1) : v.toExponential()).indexOf("e")) < 0) return null; var b, E = v.slice(0, b); return [E.length > 1 ? E[0] + E.slice(2) : E, +v.slice(b + 1)] } function Qr(v) { return v = Oa(Math.abs(v)), v ? v[1] : NaN } function _m(v, h) { return function (b, E) { for (var k = b.length, _ = [], S = 0, d = v[0], a = 0; k > 0 && d > 0 && (a + d + 1 > E && (d = Math.max(1, E - a)), _.push(b.substring(k -= d, k + d)), !((a += d + 1) > E));)d = v[S = (S + 1) % v.length]; return _.reverse().join(h) } } function Sm(v) { return function (h) { return h.replace(/[0-9]/g, function (b) { return v[+b] }) } } var Tm = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i; function Da(v) { if (!(h = Tm.exec(v))) throw new Error("invalid format: " + v); var h; return new so({ fill: h[1], align: h[2], sign: h[3], symbol: h[4], zero: h[5], width: h[6], comma: h[7], precision: h[8] && h[8].slice(1), trim: h[9], type: h[10] }) } Da.prototype = so.prototype; function so(v) { this.fill = v.fill === void 0 ? " " : v.fill + "", this.align = v.align === void 0 ? ">" : v.align + "", this.sign = v.sign === void 0 ? "-" : v.sign + "", this.symbol = v.symbol === void 0 ? "" : v.symbol + "", this.zero = !!v.zero, this.width = v.width === void 0 ? void 0 : +v.width, this.comma = !!v.comma, this.precision = v.precision === void 0 ? void 0 : +v.precision, this.trim = !!v.trim, this.type = v.type === void 0 ? "" : v.type + "" } so.prototype.toString = function () { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type }; function Em(v) { t: for (var h = v.length, b = 1, E = -1, k; b < h; ++b)switch (v[b]) { case ".": E = k = b; break; case "0": E === 0 && (E = b), k = b; break; default: if (!+v[b]) break t; E > 0 && (E = 0); break }return E > 0 ? v.slice(0, E) + v.slice(k + 1) : v } var Af; function Im(v, h) { var b = Oa(v, h); if (!b) return v + ""; var E = b[0], k = b[1], _ = k - (Af = Math.max(-8, Math.min(8, Math.floor(k / 3))) * 3) + 1, S = E.length; return _ === S ? E : _ > S ? E + new Array(_ - S + 1).join("0") : _ > 0 ? E.slice(0, _) + "." + E.slice(_) : "0." + new Array(1 - _).join("0") + Oa(v, Math.max(0, h + _ - 1))[0] } function _u(v, h) { var b = Oa(v, h); if (!b) return v + ""; var E = b[0], k = b[1]; return k < 0 ? "0." + new Array(-k).join("0") + E : E.length > k + 1 ? E.slice(0, k + 1) + "." + E.slice(k + 1) : E + new Array(k - E.length + 2).join("0") } const Su = { "%": (v, h) => (v * 100).toFixed(h), b: v => Math.round(v).toString(2), c: v => v + "", d: xm, e: (v, h) => v.toExponential(h), f: (v, h) => v.toFixed(h), g: (v, h) => v.toPrecision(h), o: v => Math.round(v).toString(8), p: (v, h) => _u(v * 100, h), r: _u, s: Im, X: v => Math.round(v).toString(16).toUpperCase(), x: v => Math.round(v).toString(16) }; function Tu(v) { return v } var Eu = Array.prototype.map, Iu = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]; function Bm(v) { var h = v.grouping === void 0 || v.thousands === void 0 ? Tu : _m(Eu.call(v.grouping, Number), v.thousands + ""), b = v.currency === void 0 ? "" : v.currency[0] + "", E = v.currency === void 0 ? "" : v.currency[1] + "", k = v.decimal === void 0 ? "." : v.decimal + "", _ = v.numerals === void 0 ? Tu : Sm(Eu.call(v.numerals, String)), S = v.percent === void 0 ? "%" : v.percent + "", d = v.minus === void 0 ? "−" : v.minus + "", a = v.nan === void 0 ? "NaN" : v.nan + ""; function l(r) { r = Da(r); var i = r.fill, n = r.align, o = r.sign, p = r.symbol, f = r.zero, m = r.width, y = r.comma, C = r.precision, x = r.trim, I = r.type; I === "n" ? (y = !0, I = "g") : Su[I] || (C === void 0 && (C = 12), x = !0, I = "g"), (f || i === "0" && n === "=") && (f = !0, i = "0", n = "="); var D = p === "$" ? b : p === "#" && /[boxX]/.test(I) ? "0" + I.toLowerCase() : "", P = p === "$" ? E : /[%p]/.test(I) ? S : "", z = Su[I], et = /[defgprs%]/.test(I); C = C === void 0 ? 6 : /[gprs]/.test(I) ? Math.max(1, Math.min(21, C)) : Math.max(0, Math.min(20, C)); function tt(st) { var dt = D, q = P, ct, W, Dt; if (I === "c") q = z(st) + q, st = ""; else { st = +st; var Lt = st < 0 || 1 / st < 0; if (st = isNaN(st) ? a : z(Math.abs(st), C), x && (st = Em(st)), Lt && +st == 0 && o !== "+" && (Lt = !1), dt = (Lt ? o === "(" ? o : d : o === "-" || o === "(" ? "" : o) + dt, q = (I === "s" ? Iu[8 + Af / 3] : "") + q + (Lt && o === "(" ? ")" : ""), et) { for (ct = -1, W = st.length; ++ct < W;)if (Dt = st.charCodeAt(ct), 48 > Dt || Dt > 57) { q = (Dt === 46 ? k + st.slice(ct + 1) : st.slice(ct)) + q, st = st.slice(0, ct); break } } } y && !f && (st = h(st, 1 / 0)); var it = dt.length + st.length + q.length, O = it < m ? new Array(m - it + 1).join(i) : ""; switch (y && f && (st = h(O + st, O.length ? m - q.length : 1 / 0), O = ""), n) { case "<": st = dt + st + q + O; break; case "=": st = dt + O + st + q; break; case "^": st = O.slice(0, it = O.length >> 1) + dt + st + q + O.slice(it); break; default: st = O + dt + st + q; break }return _(st) } return tt.toString = function () { return r + "" }, tt } function c(r, i) { var n = l((r = Da(r), r.type = "f", r)), o = Math.max(-8, Math.min(8, Math.floor(Qr(i) / 3))) * 3, p = Math.pow(10, -o), f = Iu[8 + o / 3]; return function (m) { return n(p * m) + f } } return { format: l, formatPrefix: c } } var pa, Cf, bf; km({ thousands: ",", grouping: [3], currency: ["$", ""] }); function km(v) { return pa = Bm(v), Cf = pa.format, bf = pa.formatPrefix, pa } function Mm(v) { return Math.max(0, -Qr(Math.abs(v))) } function Om(v, h) { return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Qr(h) / 3))) * 3 - Qr(Math.abs(v))) } function Dm(v, h) { return v = Math.abs(v), h = Math.abs(h) - v, Math.max(0, Qr(h) - Qr(v)) + 1 } function Lm(v, h) { switch (arguments.length) { case 0: break; case 1: this.range(v); break; default: this.range(h).domain(v); break }return this } function Fm(v) { return function () { return v } } function Pm(v) { return +v } var Bu = [0, 1]; function Lr(v) { return v } function Ks(v, h) { return (h -= v = +v) ? function (b) { return (b - v) / h } : Fm(isNaN(h) ? NaN : .5) } function Rm(v, h) { var b; return v > h && (b = v, v = h, h = b), function (E) { return Math.max(v, Math.min(h, E)) } } function Qm(v, h, b) { var E = v[0], k = v[1], _ = h[0], S = h[1]; return k < E ? (E = Ks(k, E), _ = b(S, _)) : (E = Ks(E, k), _ = b(_, S)), function (d) { return _(E(d)) } } function Wm(v, h, b) { var E = Math.min(v.length, h.length) - 1, k = new Array(E), _ = new Array(E), S = -1; for (v[E] < v[0] && (v = v.slice().reverse(), h = h.slice().reverse()); ++S < E;)k[S] = Ks(v[S], v[S + 1]), _[S] = b(h[S], h[S + 1]); return function (d) { var a = Vd(v, d, 1, E) - 1; return _[a](k[a](d)) } } function Nm(v, h) { return h.domain(v.domain()).range(v.range()).interpolate(v.interpolate()).clamp(v.clamp()).unknown(v.unknown()) } function Ym() { var v = Bu, h = Bu, b = io, E, k, _, S = Lr, d, a, l; function c() { var i = Math.min(v.length, h.length); return S !== Lr && (S = Rm(v[0], v[i - 1])), d = i > 2 ? Wm : Qm, a = l = null, r } function r(i) { return i == null || isNaN(i = +i) ? _ : (a || (a = d(v.map(E), h, b)))(E(S(i))) } return r.invert = function (i) { return S(k((l || (l = d(h, v.map(E), oi)))(i))) }, r.domain = function (i) { return arguments.length ? (v = Array.from(i, Pm), c()) : v.slice() }, r.range = function (i) { return arguments.length ? (h = Array.from(i), c()) : h.slice() }, r.rangeRound = function (i) { return h = Array.from(i), b = sv, c() }, r.clamp = function (i) { return arguments.length ? (S = i ? !0 : Lr, c()) : S !== Lr }, r.interpolate = function (i) { return arguments.length ? (b = i, c()) : b }, r.unknown = function (i) { return arguments.length ? (_ = i, r) : _ }, function (i, n) { return E = i, k = n, c() } } function Vm() { return Ym()(Lr, Lr) } function zm(v, h, b, E) { var k = jd(v, h, b), _; switch (E = Da(E ?? ",f"), E.type) { case "s": { var S = Math.max(Math.abs(v), Math.abs(h)); return E.precision == null && !isNaN(_ = Om(k, S)) && (E.precision = _), bf(E, S) } case "": case "e": case "g": case "p": case "r": { E.precision == null && !isNaN(_ = Dm(k, Math.max(Math.abs(v), Math.abs(h)))) && (E.precision = _ - (E.type === "e")); break } case "f": case "%": { E.precision == null && !isNaN(_ = Mm(k)) && (E.precision = _ - (E.type === "%") * 2); break } }return Cf(E) } function Um(v) { var h = v.domain; return v.ticks = function (b) { var E = h(); return Gd(E[0], E[E.length - 1], b ?? 10) }, v.tickFormat = function (b, E) { var k = h(); return zm(k[0], k[k.length - 1], b ?? 10, E) }, v.nice = function (b) { b == null && (b = 10); var E = h(), k = 0, _ = E.length - 1, S = E[k], d = E[_], a, l, c = 10; for (d < S && (l = S, S = d, d = l, l = k, k = _, _ = l); c-- > 0;) { if (l = Ys(S, d, b), l === a) return E[k] = S, E[_] = d, h(E); if (l > 0) S = Math.floor(S / l) * l, d = Math.ceil(d / l) * l; else if (l < 0) S = Math.ceil(S * l) / l, d = Math.floor(d * l) / l; else break; a = l } return v }, v } function qs() { var v = Vm(); return v.copy = function () { return Nm(v, qs()) }, Lm.apply(v, arguments), Um(v) } function bn(v, h, b) { this.k = v, this.x = h, this.y = b } bn.prototype = { constructor: bn, scale: function (v) { return v === 1 ? this : new bn(this.k * v, this.x, this.y) }, translate: function (v, h) { return v === 0 & h === 0 ? this : new bn(this.k, this.x + this.k * v, this.y + this.k * h) }, apply: function (v) { return [v[0] * this.k + this.x, v[1] * this.k + this.y] }, applyX: function (v) { return v * this.k + this.x }, applyY: function (v) { return v * this.k + this.y }, invert: function (v) { return [(v[0] - this.x) / this.k, (v[1] - this.y) / this.k] }, invertX: function (v) { return (v - this.x) / this.k }, invertY: function (v) { return (v - this.y) / this.k }, rescaleX: function (v) { return v.copy().domain(v.range().map(this.invertX, this).map(v.invert, v)) }, rescaleY: function (v) { return v.copy().domain(v.range().map(this.invertY, this).map(v.invert, v)) }, toString: function () { return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")" } }; bn.prototype; const Hm = { __name: "editorRods", props: { positionInfo: { type: Object, default: { w: 0, h: 0, left: 0, top: 0 } } }, setup(v) { const h = v, b = S => parseInt(S / 50), E = ye(null), k = () => { E.value && (E.value.innerHTML = null), _(E.value.offsetHeight, E.value.offsetWidth) }, _ = (S, d) => { var a = Rp(".td-editor-rod-main").append("svg").attr("width", d).attr("height", S).style("background-color", "#1F1F1F"); const l = qs().domain([-h.positionInfo.left, h.positionInfo.w - h.positionInfo.left]).range([0, d - 40]), c = qs().domain([-h.positionInfo.top, h.positionInfo.h - h.positionInfo.top]).range([0, S - 40]), r = tg(l).ticks(b(d)), i = eg(c).ticks(b(S)); a.append("g").call(r).attr("transform", "translate(40, 40)"), a.append("g").call(i).attr("transform", "translate(40, 40)") }; return La(() => { k() }), wn(() => h.positionInfo, () => { k() }, { deep: !0 }), (S, d) => (zt(), fe("div", { class: "td-editor-rod-main", ref_key: "apEditorRod", ref: E }, null, 512)) } }, Gm = Ci(Hm, [["__scopeId", "data-v-af524f6d"]]); var ne = {}; const jm = {}, Xm = Object.freeze(Object.defineProperty({ __proto__: null, default: jm }, Symbol.toStringTag, { value: "Module" })), Rs = Sc(Xm); (function (v) {/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */var h = h || { version: "5.3.0" }; if (v.fabric = h, typeof document < "u" && typeof window < "u") document instanceof (typeof HTMLDocument < "u" ? HTMLDocument : Document) ? h.document = document : h.document = document.implementation.createHTMLDocument(""), h.window = window; else { var b = Rs, E = new b.JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), { features: { FetchExternalResources: ["img"] }, resources: "usable" }).window; h.document = E.document, h.jsdomImplForWrapper = Rs.implForWrapper, h.nodeCanvas = Rs.Canvas, h.window = E, DOMParser = h.window.DOMParser } h.isTouchSupported = "ontouchstart" in h.window || "ontouchstart" in h.document || h.window && h.window.navigator && h.window.navigator.maxTouchPoints > 0, h.isLikelyNode = typeof Buffer < "u" && typeof window > "u", h.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], h.DPI = 96, h.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", h.commaWsp = "(?:\\s+,?\\s*|,\\s*)", h.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig, h.reNonWord = /[ \n\.,;!\?\-]/, h.fontPaths = {}, h.iMatrix = [1, 0, 0, 1, 0, 0], h.svgNS = "http://www.w3.org/2000/svg", h.perfLimitSizeTotal = 2097152, h.maxCacheSideLimit = 4096, h.minCacheSideLimit = 256, h.charWidthsCache = {}, h.textureSize = 2048, h.disableStyleCopyPaste = !1, h.enableGLFiltering = !0, h.devicePixelRatio = h.window.devicePixelRatio || h.window.webkitDevicePixelRatio || h.window.mozDevicePixelRatio || 1, h.browserShadowBlurConstant = 1, h.arcToSegmentsCache = {}, h.boundsOfCurveCache = {}, h.cachesBoundsOfCurve = !0, h.forceGLPutImageData = !1, h.initFilterBackend = function () { if (h.enableGLFiltering && h.isWebglSupported && h.isWebglSupported(h.textureSize)) return console.log("max texture size: " + h.maxTextureSize), new h.WebglFilterBackend({ tileSize: h.textureSize }); if (h.Canvas2dFilterBackend) return new h.Canvas2dFilterBackend }, typeof document < "u" && typeof window < "u" && (window.fabric = h), function () { function d(n, o) { if (this.__eventListeners[n]) { var p = this.__eventListeners[n]; o ? p[p.indexOf(o)] = !1 : h.util.array.fill(p, !1) } } function a(n, o) { if (this.__eventListeners || (this.__eventListeners = {}), arguments.length === 1) for (var p in n) this.on(p, n[p]); else this.__eventListeners[n] || (this.__eventListeners[n] = []), this.__eventListeners[n].push(o); return this } function l(n, o) { var p = function () { o.apply(this, arguments), this.off(n, p) }.bind(this); this.on(n, p) } function c(n, o) { if (arguments.length === 1) for (var p in n) l.call(this, p, n[p]); else l.call(this, n, o); return this } function r(n, o) { if (!this.__eventListeners) return this; if (arguments.length === 0) for (n in this.__eventListeners) d.call(this, n); else if (arguments.length === 1 && typeof arguments[0] == "object") for (var p in n) d.call(this, p, n[p]); else d.call(this, n, o); return this } function i(n, o) { if (!this.__eventListeners) return this; var p = this.__eventListeners[n]; if (!p) return this; for (var f = 0, m = p.length; f < m; f++)p[f] && p[f].call(this, o || {}); return this.__eventListeners[n] = p.filter(function (y) { return y !== !1 }), this } h.Observable = { fire: i, on: a, once: c, off: r } }(), h.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var d = 0, a = arguments.length; d < a; d++)this._onObjectAdded(arguments[d]); return this.renderOnAddRemove && this.requestRenderAll(), this }, insertAt: function (d, a, l) { var c = this._objects; return l ? c[a] = d : c.splice(a, 0, d), this._onObjectAdded && this._onObjectAdded(d), this.renderOnAddRemove && this.requestRenderAll(), this }, remove: function () { for (var d = this._objects, a, l = !1, c = 0, r = arguments.length; c < r; c++)a = d.indexOf(arguments[c]), a !== -1 && (l = !0, d.splice(a, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[c])); return this.renderOnAddRemove && l && this.requestRenderAll(), this }, forEachObject: function (d, a) { for (var l = this.getObjects(), c = 0, r = l.length; c < r; c++)d.call(a, l[c], c, l); return this }, getObjects: function (d) { return typeof d > "u" ? this._objects.concat() : this._objects.filter(function (a) { return a.type === d }) }, item: function (d) { return this._objects[d] }, isEmpty: function () { return this._objects.length === 0 }, size: function () { return this._objects.length }, contains: function (d, a) { return this._objects.indexOf(d) > -1 ? !0 : a ? this._objects.some(function (l) { return typeof l.contains == "function" && l.contains(d, !0) }) : !1 }, complexity: function () { return this._objects.reduce(function (d, a) { return d += a.complexity ? a.complexity() : 0, d }, 0) } }, h.CommonMethods = { _setOptions: function (d) { for (var a in d) this.set(a, d[a]) }, _initGradient: function (d, a) { d && d.colorStops && !(d instanceof h.Gradient) && this.set(a, new h.Gradient(d)) }, _initPattern: function (d, a, l) { d && d.source && !(d instanceof h.Pattern) ? this.set(a, new h.Pattern(d, l)) : l && l() }, _setObject: function (d) { for (var a in d) this._set(a, d[a]) }, set: function (d, a) { return typeof d == "object" ? this._setObject(d) : this._set(d, a), this }, _set: function (d, a) { this[d] = a }, toggle: function (d) { var a = this.get(d); return typeof a == "boolean" && this.set(d, !a), this }, get: function (d) { return this[d] } }, function (d) {
  var a = Math.sqrt, l = Math.atan2, c = Math.pow, r = Math.PI / 180, i = Math.PI / 2; h.util = {
    cos: function (n) { if (n === 0) return 1; n < 0 && (n = -n); var o = n / i; switch (o) { case 1: case 3: return 0; case 2: return -1 }return Math.cos(n) }, sin: function (n) { if (n === 0) return 0; var o = n / i, p = 1; switch (n < 0 && (p = -1), o) { case 1: return p; case 2: return 0; case 3: return -p }return Math.sin(n) }, removeFromArray: function (n, o) { var p = n.indexOf(o); return p !== -1 && n.splice(p, 1), n }, getRandomInt: function (n, o) { return Math.floor(Math.random() * (o - n + 1)) + n }, degreesToRadians: function (n) { return n * r }, radiansToDegrees: function (n) { return n / r }, rotatePoint: function (n, o, p) { var f = new h.Point(n.x - o.x, n.y - o.y), m = h.util.rotateVector(f, p); return new h.Point(m.x, m.y).addEquals(o) }, rotateVector: function (n, o) { var p = h.util.sin(o), f = h.util.cos(o), m = n.x * f - n.y * p, y = n.x * p + n.y * f; return { x: m, y } }, createVector: function (n, o) { return new h.Point(o.x - n.x, o.y - n.y) }, calcAngleBetweenVectors: function (n, o) { return Math.acos((n.x * o.x + n.y * o.y) / (Math.hypot(n.x, n.y) * Math.hypot(o.x, o.y))) }, getHatVector: function (n) { return new h.Point(n.x, n.y).multiply(1 / Math.hypot(n.x, n.y)) }, getBisector: function (n, o, p) { var f = h.util.createVector(n, o), m = h.util.createVector(n, p), y = h.util.calcAngleBetweenVectors(f, m), C = h.util.calcAngleBetweenVectors(h.util.rotateVector(f, y), m), x = y * (C === 0 ? 1 : -1) / 2; return { vector: h.util.getHatVector(h.util.rotateVector(f, x)), angle: y } }, projectStrokeOnPoints: function (n, o, p) { var f = [], m = o.strokeWidth / 2, y = o.strokeUniform ? new h.Point(1 / o.scaleX, 1 / o.scaleY) : new h.Point(1, 1), C = function (x) { var I = m / Math.hypot(x.x, x.y); return new h.Point(x.x * I * y.x, x.y * I * y.y) }; return n.length <= 1 || n.forEach(function (x, I) { var D = new h.Point(x.x, x.y), P, z; I === 0 ? (z = n[I + 1], P = p ? C(h.util.createVector(z, D)).addEquals(D) : n[n.length - 1]) : I === n.length - 1 ? (P = n[I - 1], z = p ? C(h.util.createVector(P, D)).addEquals(D) : n[0]) : (P = n[I - 1], z = n[I + 1]); var et = h.util.getBisector(D, P, z), tt = et.vector, st = et.angle, dt, q; if (o.strokeLineJoin === "miter" && (dt = -m / Math.sin(st / 2), q = new h.Point(tt.x * dt * y.x, tt.y * dt * y.y), Math.hypot(q.x, q.y) / m <= o.strokeMiterLimit)) { f.push(D.add(q)), f.push(D.subtract(q)); return } dt = -m * Math.SQRT2, q = new h.Point(tt.x * dt * y.x, tt.y * dt * y.y), f.push(D.add(q)), f.push(D.subtract(q)) }), f }, transformPoint: function (n, o, p) { return p ? new h.Point(o[0] * n.x + o[2] * n.y, o[1] * n.x + o[3] * n.y) : new h.Point(o[0] * n.x + o[2] * n.y + o[4], o[1] * n.x + o[3] * n.y + o[5]) }, makeBoundingBoxFromPoints: function (n, o) { if (o) for (var p = 0; p < n.length; p++)n[p] = h.util.transformPoint(n[p], o); var f = [n[0].x, n[1].x, n[2].x, n[3].x], m = h.util.array.min(f), y = h.util.array.max(f), C = y - m, x = [n[0].y, n[1].y, n[2].y, n[3].y], I = h.util.array.min(x), D = h.util.array.max(x), P = D - I; return { left: m, top: I, width: C, height: P } }, invertTransform: function (n) { var o = 1 / (n[0] * n[3] - n[1] * n[2]), p = [o * n[3], -o * n[1], -o * n[2], o * n[0]], f = h.util.transformPoint({ x: n[4], y: n[5] }, p, !0); return p[4] = -f.x, p[5] = -f.y, p }, toFixed: function (n, o) { return parseFloat(Number(n).toFixed(o)) }, parseUnit: function (n, o) { var p = /\D{0,2}$/.exec(n), f = parseFloat(n); switch (o || (o = h.Text.DEFAULT_SVG_FONT_SIZE), p[0]) { case "mm": return f * h.DPI / 25.4; case "cm": return f * h.DPI / 2.54; case "in": return f * h.DPI; case "pt": return f * h.DPI / 72; case "pc": return f * h.DPI / 72 * 12; case "em": return f * o; default: return f } }, falseFunction: function () { return !1 }, getKlass: function (n, o) { return n = h.util.string.camelize(n.charAt(0).toUpperCase() + n.slice(1)), h.util.resolveNamespace(o)[n] }, getSvgAttributes: function (n) { var o = ["instantiated_by_use", "style", "id", "class"]; switch (n) { case "linearGradient": o = o.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]); break; case "radialGradient": o = o.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]); break; case "stop": o = o.concat(["offset", "stop-color", "stop-opacity"]); break }return o }, resolveNamespace: function (n) { if (!n) return h; var o = n.split("."), p = o.length, f, m = d || h.window; for (f = 0; f < p; ++f)m = m[o[f]]; return m }, loadImage: function (n, o, p, f) { if (!n) { o && o.call(p, n); return } var m = h.util.createImage(), y = function () { o && o.call(p, m, !1), m = m.onload = m.onerror = null }; m.onload = y, m.onerror = function () { h.log("Error loading " + m.src), o && o.call(p, null, !0), m = m.onload = m.onerror = null }, n.indexOf("data") !== 0 && f !== void 0 && f !== null && (m.crossOrigin = f), n.substring(0, 14) === "data:image/svg" && (m.onload = null, h.util.loadImageInDom(m, y)), m.src = n }, loadImageInDom: function (n, o) { var p = h.document.createElement("div"); p.style.width = p.style.height = "1px", p.style.left = p.style.top = "-100%", p.style.position = "absolute", p.appendChild(n), h.document.querySelector("body").appendChild(p), n.onload = function () { o(), p.parentNode.removeChild(p), p = null } }, enlivenObjects: function (n, o, p, f) { n = n || []; var m = [], y = 0, C = n.length; function x() { ++y === C && o && o(m.filter(function (I) { return I })) } if (!C) { o && o(m); return } n.forEach(function (I, D) { if (!I || !I.type) { x(); return } var P = h.util.getKlass(I.type, p); P.fromObject(I, function (z, et) { et || (m[D] = z), f && f(I, z, et), x() }) }) }, enlivenObjectEnlivables: function (n, o, p) { var f = h.Object.ENLIVEN_PROPS.filter(function (m) { return !!n[m] }); h.util.enlivenObjects(f.map(function (m) { return n[m] }), function (m) { var y = {}; f.forEach(function (C, x) { y[C] = m[x], o && (o[C] = m[x]) }), p && p(y) }) }, enlivenPatterns: function (n, o) { n = n || []; function p() { ++m === y && o && o(f) } var f = [], m = 0, y = n.length; if (!y) { o && o(f); return } n.forEach(function (C, x) { C && C.source ? new h.Pattern(C, function (I) { f[x] = I, p() }) : (f[x] = C, p()) }) }, groupSVGElements: function (n, o, p) { var f; return n && n.length === 1 ? (typeof p < "u" && (n[0].sourcePath = p), n[0]) : (o && (o.width && o.height ? o.centerPoint = { x: o.width / 2, y: o.height / 2 } : (delete o.width, delete o.height)), f = new h.Group(n, o), typeof p < "u" && (f.sourcePath = p), f) }, populateWithProperties: function (n, o, p) { if (p && Array.isArray(p)) for (var f = 0, m = p.length; f < m; f++)p[f] in n && (o[p[f]] = n[p[f]]) }, createCanvasElement: function () { return h.document.createElement("canvas") }, copyCanvasElement: function (n) { var o = h.util.createCanvasElement(); return o.width = n.width, o.height = n.height, o.getContext("2d").drawImage(n, 0, 0), o }, toDataURL: function (n, o, p) { return n.toDataURL("image/" + o, p) }, createImage: function () { return h.document.createElement("img") }, multiplyTransformMatrices: function (n, o, p) { return [n[0] * o[0] + n[2] * o[1], n[1] * o[0] + n[3] * o[1], n[0] * o[2] + n[2] * o[3], n[1] * o[2] + n[3] * o[3], p ? 0 : n[0] * o[4] + n[2] * o[5] + n[4], p ? 0 : n[1] * o[4] + n[3] * o[5] + n[5]] }, qrDecompose: function (n) { var o = l(n[1], n[0]), p = c(n[0], 2) + c(n[1], 2), f = a(p), m = (n[0] * n[3] - n[2] * n[1]) / f, y = l(n[0] * n[2] + n[1] * n[3], p); return { angle: o / r, scaleX: f, scaleY: m, skewX: y / r, skewY: 0, translateX: n[4], translateY: n[5] } }, calcRotateMatrix: function (n) { if (!n.angle) return h.iMatrix.concat(); var o = h.util.degreesToRadians(n.angle), p = h.util.cos(o), f = h.util.sin(o); return [p, f, -f, p, 0, 0] }, calcDimensionsMatrix: function (n) { var o = typeof n.scaleX > "u" ? 1 : n.scaleX, p = typeof n.scaleY > "u" ? 1 : n.scaleY, f = [n.flipX ? -o : o, 0, 0, n.flipY ? -p : p, 0, 0], m = h.util.multiplyTransformMatrices, y = h.util.degreesToRadians; return n.skewX && (f = m(f, [1, 0, Math.tan(y(n.skewX)), 1], !0)), n.skewY && (f = m(f, [1, Math.tan(y(n.skewY)), 0, 1], !0)), f }, composeMatrix: function (n) { var o = [1, 0, 0, 1, n.translateX || 0, n.translateY || 0], p = h.util.multiplyTransformMatrices; return n.angle && (o = p(o, h.util.calcRotateMatrix(n))), (n.scaleX !== 1 || n.scaleY !== 1 || n.skewX || n.skewY || n.flipX || n.flipY) && (o = p(o, h.util.calcDimensionsMatrix(n))), o }, resetObjectTransform: function (n) { n.scaleX = 1, n.scaleY = 1, n.skewX = 0, n.skewY = 0, n.flipX = !1, n.flipY = !1, n.rotate(0) }, saveObjectTransform: function (n) { return { scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, angle: n.angle, left: n.left, flipX: n.flipX, flipY: n.flipY, top: n.top } }, isTransparent: function (n, o, p, f) { f > 0 && (o > f ? o -= f : o = 0, p > f ? p -= f : p = 0); var m = !0, y, C, x = n.getImageData(o, p, f * 2 || 1, f * 2 || 1), I = x.data.length; for (y = 3; y < I && (C = x.data[y], m = C <= 0, m !== !1); y += 4); return x = null, m }, parsePreserveAspectRatioAttribute: function (n) { var o = "meet", p = "Mid", f = "Mid", m = n.split(" "), y; return m && m.length && (o = m.pop(), o !== "meet" && o !== "slice" ? (y = o, o = "meet") : m.length && (y = m.pop())), p = y !== "none" ? y.slice(1, 4) : "none", f = y !== "none" ? y.slice(5, 8) : "none", { meetOrSlice: o, alignX: p, alignY: f } }, clearFabricFontCache: function (n) { n = (n || "").toLowerCase(), n ? h.charWidthsCache[n] && delete h.charWidthsCache[n] : h.charWidthsCache = {} }, limitDimsByArea: function (n, o) { var p = Math.sqrt(o * n), f = Math.floor(o / p); return { x: Math.floor(p), y: f } }, capValue: function (n, o, p) { return Math.max(n, Math.min(o, p)) }, findScaleToFit: function (n, o) { return Math.min(o.width / n.width, o.height / n.height) }, findScaleToCover: function (n, o) { return Math.max(o.width / n.width, o.height / n.height) }, matrixToSVG: function (n) { return "matrix(" + n.map(function (o) { return h.util.toFixed(o, h.Object.NUM_FRACTION_DIGITS) }).join(" ") + ")" }, removeTransformFromObject: function (n, o) { var p = h.util.invertTransform(o), f = h.util.multiplyTransformMatrices(p, n.calcOwnMatrix()); h.util.applyTransformToObject(n, f) }, addTransformToObject: function (n, o) { h.util.applyTransformToObject(n, h.util.multiplyTransformMatrices(o, n.calcOwnMatrix())) }, applyTransformToObject: function (n, o) { var p = h.util.qrDecompose(o), f = new h.Point(p.translateX, p.translateY); n.flipX = !1, n.flipY = !1, n.set("scaleX", p.scaleX), n.set("scaleY", p.scaleY), n.skewX = p.skewX, n.skewY = p.skewY, n.angle = p.angle, n.setPositionByOrigin(f, "center", "center") }, sizeAfterTransform: function (n, o, p) { var f = n / 2, m = o / 2, y = [{ x: -f, y: -m }, { x: f, y: -m }, { x: -f, y: m }, { x: f, y: m }], C = h.util.calcDimensionsMatrix(p), x = h.util.makeBoundingBoxFromPoints(y, C); return { x: x.width, y: x.height } }, mergeClipPaths: function (n, o) { var p = n, f = o; p.inverted && !f.inverted && (p = o, f = n), h.util.applyTransformToObject(f, h.util.multiplyTransformMatrices(h.util.invertTransform(p.calcTransformMatrix()), f.calcTransformMatrix())); var m = p.inverted && f.inverted; return m && (p.inverted = f.inverted = !1), new h.Group([p], { clipPath: f, inverted: m }) }, hasStyleChanged: function (n, o, p) { return p = p || !1, n.fill !== o.fill || n.stroke !== o.stroke || n.strokeWidth !== o.strokeWidth || n.fontSize !== o.fontSize || n.fontFamily !== o.fontFamily || n.fontWeight !== o.fontWeight || n.fontStyle !== o.fontStyle || n.textBackgroundColor !== o.textBackgroundColor || n.deltaY !== o.deltaY || p && (n.overline !== o.overline || n.underline !== o.underline || n.linethrough !== o.linethrough) }, stylesToArray: function (p, o) {
      for (var p = h.util.object.clone(p, !0), f = o.split(`
`), m = -1, y = {}, C = [], x = 0; x < f.length; x++) { if (!p[x]) { m += f[x].length; continue } for (var I = 0; I < f[x].length; I++) { m++; var D = p[x][I]; if (D && Object.keys(D).length > 0) { var P = h.util.hasStyleChanged(y, D, !0); P ? C.push({ start: m, end: m + 1, style: D }) : C[C.length - 1].end++ } y = D || {} } } return C
    }, stylesFromArray: function (n, o) {
      if (!Array.isArray(n)) return n; for (var p = o.split(`
`), f = -1, m = 0, y = {}, C = 0; C < p.length; C++)for (var x = 0; x < p[C].length; x++)f++, n[m] && n[m].start <= f && f < n[m].end && (y[C] = y[C] || {}, y[C][x] = Object.assign({}, n[m].style), f === n[m].end - 1 && m++); return y
    }
  }
}(v), function () { var d = Array.prototype.join, a = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, l = { m: "l", M: "L" }; function c(O, V, G, U, lt, H, R, K, J, ht, ut) { var _t = h.util.cos(O), mt = h.util.sin(O), St = h.util.cos(V), gt = h.util.sin(V), ft = G * lt * St - U * H * gt + R, wt = U * lt * St + G * H * gt + K, xt = ht + J * (-G * lt * mt - U * H * _t), pt = ut + J * (-U * lt * mt + G * H * _t), vt = ft + J * (G * lt * gt + U * H * St), kt = wt + J * (U * lt * gt - G * H * St); return ["C", xt, pt, vt, kt, ft, wt] } function r(O, V, G, U, lt, H, R) { var K = Math.PI, J = R * K / 180, ht = h.util.sin(J), ut = h.util.cos(J), _t = 0, mt = 0; G = Math.abs(G), U = Math.abs(U); var St = -ut * O * .5 - ht * V * .5, gt = -ut * V * .5 + ht * O * .5, ft = G * G, wt = U * U, xt = gt * gt, pt = St * St, vt = ft * wt - ft * xt - wt * pt, kt = 0; if (vt < 0) { var L = Math.sqrt(1 - vt / (ft * wt)); G *= L, U *= L } else kt = (lt === H ? -1 : 1) * Math.sqrt(vt / (ft * xt + wt * pt)); var N = kt * G * gt / U, Q = -kt * U * St / G, $ = ut * N - ht * Q + O * .5, rt = ht * N + ut * Q + V * .5, at = i(1, 0, (St - N) / G, (gt - Q) / U), yt = i((St - N) / G, (gt - Q) / U, (-St - N) / G, (-gt - Q) / U); H === 0 && yt > 0 ? yt -= 2 * K : H === 1 && yt < 0 && (yt += 2 * K); for (var bt = Math.ceil(Math.abs(yt / K * 2)), Et = [], Ft = yt / bt, Qt = 8 / 3 * Math.sin(Ft / 4) * Math.sin(Ft / 4) / Math.sin(Ft / 2), jt = at + Ft, Gt = 0; Gt < bt; Gt++)Et[Gt] = c(at, jt, ut, ht, G, U, $, rt, Qt, _t, mt), _t = Et[Gt][5], mt = Et[Gt][6], at = jt, jt += Ft; return Et } function i(O, V, G, U) { var lt = Math.atan2(V, O), H = Math.atan2(U, G); return H >= lt ? H - lt : 2 * Math.PI - (lt - H) } function n(O, V, G, U, lt, H, R, K) { var J; if (h.cachesBoundsOfCurve && (J = d.call(arguments), h.boundsOfCurveCache[J])) return h.boundsOfCurveCache[J]; var ht = Math.sqrt, ut = Math.min, _t = Math.max, mt = Math.abs, St = [], gt = [[], []], ft, wt, xt, pt, vt, kt, L, N; wt = 6 * O - 12 * G + 6 * lt, ft = -3 * O + 9 * G - 9 * lt + 3 * R, xt = 3 * G - 3 * O; for (var Q = 0; Q < 2; ++Q) { if (Q > 0 && (wt = 6 * V - 12 * U + 6 * H, ft = -3 * V + 9 * U - 9 * H + 3 * K, xt = 3 * U - 3 * V), mt(ft) < 1e-12) { if (mt(wt) < 1e-12) continue; pt = -xt / wt, 0 < pt && pt < 1 && St.push(pt); continue } L = wt * wt - 4 * xt * ft, !(L < 0) && (N = ht(L), vt = (-wt + N) / (2 * ft), 0 < vt && vt < 1 && St.push(vt), kt = (-wt - N) / (2 * ft), 0 < kt && kt < 1 && St.push(kt)) } for (var $, rt, at = St.length, yt = at, bt; at--;)pt = St[at], bt = 1 - pt, $ = bt * bt * bt * O + 3 * bt * bt * pt * G + 3 * bt * pt * pt * lt + pt * pt * pt * R, gt[0][at] = $, rt = bt * bt * bt * V + 3 * bt * bt * pt * U + 3 * bt * pt * pt * H + pt * pt * pt * K, gt[1][at] = rt; gt[0][yt] = O, gt[1][yt] = V, gt[0][yt + 1] = R, gt[1][yt + 1] = K; var Et = [{ x: ut.apply(null, gt[0]), y: ut.apply(null, gt[1]) }, { x: _t.apply(null, gt[0]), y: _t.apply(null, gt[1]) }]; return h.cachesBoundsOfCurve && (h.boundsOfCurveCache[J] = Et), Et } function o(O, V, G) { for (var U = G[1], lt = G[2], H = G[3], R = G[4], K = G[5], J = G[6], ht = G[7], ut = r(J - O, ht - V, U, lt, R, K, H), _t = 0, mt = ut.length; _t < mt; _t++)ut[_t][1] += O, ut[_t][2] += V, ut[_t][3] += O, ut[_t][4] += V, ut[_t][5] += O, ut[_t][6] += V; return ut } function p(O) { var V = 0, G = 0, U = O.length, lt = 0, H = 0, R, K, J, ht = [], ut, _t, mt; for (K = 0; K < U; ++K) { switch (J = !1, R = O[K].slice(0), R[0]) { case "l": R[0] = "L", R[1] += V, R[2] += G; case "L": V = R[1], G = R[2]; break; case "h": R[1] += V; case "H": R[0] = "L", R[2] = G, V = R[1]; break; case "v": R[1] += G; case "V": R[0] = "L", G = R[1], R[1] = V, R[2] = G; break; case "m": R[0] = "M", R[1] += V, R[2] += G; case "M": V = R[1], G = R[2], lt = R[1], H = R[2]; break; case "c": R[0] = "C", R[1] += V, R[2] += G, R[3] += V, R[4] += G, R[5] += V, R[6] += G; case "C": _t = R[3], mt = R[4], V = R[5], G = R[6]; break; case "s": R[0] = "S", R[1] += V, R[2] += G, R[3] += V, R[4] += G; case "S": ut === "C" ? (_t = 2 * V - _t, mt = 2 * G - mt) : (_t = V, mt = G), V = R[3], G = R[4], R[0] = "C", R[5] = R[3], R[6] = R[4], R[3] = R[1], R[4] = R[2], R[1] = _t, R[2] = mt, _t = R[3], mt = R[4]; break; case "q": R[0] = "Q", R[1] += V, R[2] += G, R[3] += V, R[4] += G; case "Q": _t = R[1], mt = R[2], V = R[3], G = R[4]; break; case "t": R[0] = "T", R[1] += V, R[2] += G; case "T": ut === "Q" ? (_t = 2 * V - _t, mt = 2 * G - mt) : (_t = V, mt = G), R[0] = "Q", V = R[1], G = R[2], R[1] = _t, R[2] = mt, R[3] = V, R[4] = G; break; case "a": R[0] = "A", R[6] += V, R[7] += G; case "A": J = !0, ht = ht.concat(o(V, G, R)), V = R[6], G = R[7]; break; case "z": case "Z": V = lt, G = H; break }J || ht.push(R), ut = R[0] } return ht } function f(O, V, G, U) { return Math.sqrt((G - O) * (G - O) + (U - V) * (U - V)) } function m(O) { return O * O * O } function y(O) { return 3 * O * O * (1 - O) } function C(O) { return 3 * O * (1 - O) * (1 - O) } function x(O) { return (1 - O) * (1 - O) * (1 - O) } function I(O, V, G, U, lt, H, R, K) { return function (J) { var ht = m(J), ut = y(J), _t = C(J), mt = x(J); return { x: R * ht + lt * ut + G * _t + O * mt, y: K * ht + H * ut + U * _t + V * mt } } } function D(O, V, G, U, lt, H, R, K) { return function (J) { var ht = 1 - J, ut = 3 * ht * ht * (G - O) + 6 * ht * J * (lt - G) + 3 * J * J * (R - lt), _t = 3 * ht * ht * (U - V) + 6 * ht * J * (H - U) + 3 * J * J * (K - H); return Math.atan2(_t, ut) } } function P(O) { return O * O } function z(O) { return 2 * O * (1 - O) } function et(O) { return (1 - O) * (1 - O) } function tt(O, V, G, U, lt, H) { return function (R) { var K = P(R), J = z(R), ht = et(R); return { x: lt * K + G * J + O * ht, y: H * K + U * J + V * ht } } } function st(O, V, G, U, lt, H) { return function (R) { var K = 1 - R, J = 2 * K * (G - O) + 2 * R * (lt - G), ht = 2 * K * (U - V) + 2 * R * (H - U); return Math.atan2(ht, J) } } function dt(O, V, G) { var U = { x: V, y: G }, lt, H = 0, R; for (R = 1; R <= 100; R += 1)lt = O(R / 100), H += f(U.x, U.y, lt.x, lt.y), U = lt; return H } function q(O, V) { for (var G = 0, U = 0, lt = O.iterator, H = { x: O.x, y: O.y }, R, K, J = .01, ht = O.angleFinder, ut; U < V && J > 1e-4;)R = lt(G), ut = G, K = f(H.x, H.y, R.x, R.y), K + U > V ? (G -= J, J /= 2) : (H = R, G += J, U += K); return R.angle = ht(ut), R } function ct(O) { for (var V = 0, G = O.length, U, lt = 0, H = 0, R = 0, K = 0, J = [], ht, ut, _t, mt = 0; mt < G; mt++) { switch (U = O[mt], ut = { x: lt, y: H, command: U[0] }, U[0]) { case "M": ut.length = 0, R = lt = U[1], K = H = U[2]; break; case "L": ut.length = f(lt, H, U[1], U[2]), lt = U[1], H = U[2]; break; case "C": ht = I(lt, H, U[1], U[2], U[3], U[4], U[5], U[6]), _t = D(lt, H, U[1], U[2], U[3], U[4], U[5], U[6]), ut.iterator = ht, ut.angleFinder = _t, ut.length = dt(ht, lt, H), lt = U[5], H = U[6]; break; case "Q": ht = tt(lt, H, U[1], U[2], U[3], U[4]), _t = st(lt, H, U[1], U[2], U[3], U[4]), ut.iterator = ht, ut.angleFinder = _t, ut.length = dt(ht, lt, H), lt = U[3], H = U[4]; break; case "Z": case "z": ut.destX = R, ut.destY = K, ut.length = f(lt, H, R, K), lt = R, H = K; break }V += ut.length, J.push(ut) } return J.push({ length: V, x: lt, y: H }), J } function W(O, V, G) { G || (G = ct(O)); for (var U = 0; V - G[U].length > 0 && U < G.length - 2;)V -= G[U].length, U++; var lt = G[U], H = V / lt.length, R = lt.command, K = O[U], J; switch (R) { case "M": return { x: lt.x, y: lt.y, angle: 0 }; case "Z": case "z": return J = new h.Point(lt.x, lt.y).lerp(new h.Point(lt.destX, lt.destY), H), J.angle = Math.atan2(lt.destY - lt.y, lt.destX - lt.x), J; case "L": return J = new h.Point(lt.x, lt.y).lerp(new h.Point(K[1], K[2]), H), J.angle = Math.atan2(K[2] - lt.y, K[1] - lt.x), J; case "C": return q(lt, V); case "Q": return q(lt, V) } } function Dt(O) { var V = [], G = [], U, lt, H = h.rePathCommand, R = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", K = "(" + R + ")" + h.commaWsp, J = "([01])" + h.commaWsp + "?", ht = K + "?" + K + "?" + K + J + J + K + "?(" + R + ")", ut = new RegExp(ht, "g"), _t, mt, St; if (!O || !O.match) return V; St = O.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi); for (var gt = 0, ft, wt = St.length; gt < wt; gt++) { U = St[gt], mt = U.slice(1).trim(), G.length = 0; var xt = U.charAt(0); if (ft = [xt], xt.toLowerCase() === "a") for (var pt; pt = ut.exec(mt);)for (var vt = 1; vt < pt.length; vt++)G.push(pt[vt]); else for (; _t = H.exec(mt);)G.push(_t[0]); for (var vt = 0, kt = G.length; vt < kt; vt++)lt = parseFloat(G[vt]), isNaN(lt) || ft.push(lt); var L = a[xt.toLowerCase()], N = l[xt] || xt; if (ft.length - 1 > L) for (var Q = 1, $ = ft.length; Q < $; Q += L)V.push([xt].concat(ft.slice(Q, Q + L))), xt = N; else V.push(ft) } return V } function Lt(O, V) { var G = [], U, lt = new h.Point(O[0].x, O[0].y), H = new h.Point(O[1].x, O[1].y), R = O.length, K = 1, J = 0, ht = R > 2; for (V = V || 0, ht && (K = O[2].x < H.x ? -1 : O[2].x === H.x ? 0 : 1, J = O[2].y < H.y ? -1 : O[2].y === H.y ? 0 : 1), G.push(["M", lt.x - K * V, lt.y - J * V]), U = 1; U < R; U++) { if (!lt.eq(H)) { var ut = lt.midPointFrom(H); G.push(["Q", lt.x, lt.y, ut.x, ut.y]) } lt = O[U], U + 1 < O.length && (H = O[U + 1]) } return ht && (K = lt.x > O[U - 2].x ? 1 : lt.x === O[U - 2].x ? 0 : -1, J = lt.y > O[U - 2].y ? 1 : lt.y === O[U - 2].y ? 0 : -1), G.push(["L", lt.x + K * V, lt.y + J * V]), G } function it(O, V, G) { return G && (V = h.util.multiplyTransformMatrices(V, [1, 0, 0, 1, -G.x, -G.y])), O.map(function (U) { for (var lt = U.slice(0), H = {}, R = 1; R < U.length - 1; R += 2)H.x = U[R], H.y = U[R + 1], H = h.util.transformPoint(H, V), lt[R] = H.x, lt[R + 1] = H.y; return lt }) } h.util.joinPath = function (O) { return O.map(function (V) { return V.join(" ") }).join(" ") }, h.util.parsePath = Dt, h.util.makePathSimpler = p, h.util.getSmoothPathFromPoints = Lt, h.util.getPathSegmentsInfo = ct, h.util.getBoundsOfCurve = n, h.util.getPointOnPath = W, h.util.transformPath = it }(), function () { var d = Array.prototype.slice; function a(n, o) { for (var p = d.call(arguments, 2), f = [], m = 0, y = n.length; m < y; m++)f[m] = p.length ? n[m][o].apply(n[m], p) : n[m][o].call(n[m]); return f } function l(n, o) { return i(n, o, function (p, f) { return p >= f }) } function c(n, o) { return i(n, o, function (p, f) { return p < f }) } function r(n, o) { for (var p = n.length; p--;)n[p] = o; return n } function i(n, o, p) { if (!(!n || n.length === 0)) { var f = n.length - 1, m = o ? n[f][o] : n[f]; if (o) for (; f--;)p(n[f][o], m) && (m = n[f][o]); else for (; f--;)p(n[f], m) && (m = n[f]); return m } } h.util.array = { fill: r, invoke: a, min: c, max: l } }(), function () { function d(l, c, r) { if (r) if (!h.isLikelyNode && c instanceof Element) l = c; else if (c instanceof Array) { l = []; for (var i = 0, n = c.length; i < n; i++)l[i] = d({}, c[i], r) } else if (c && typeof c == "object") for (var o in c) o === "canvas" || o === "group" ? l[o] = null : c.hasOwnProperty(o) && (l[o] = d({}, c[o], r)); else l = c; else for (var o in c) l[o] = c[o]; return l } function a(l, c) { return d({}, l, c) } h.util.object = { extend: d, clone: a }, h.util.object.extend(h.util, h.Observable) }(), function () { function d(i) { return i.replace(/-+(.)?/g, function (n, o) { return o ? o.toUpperCase() : "" }) } function a(i, n) { return i.charAt(0).toUpperCase() + (n ? i.slice(1) : i.slice(1).toLowerCase()) } function l(i) { return i.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function c(i) { var n = 0, o, p = []; for (n = 0, o; n < i.length; n++)(o = r(i, n)) !== !1 && p.push(o); return p } function r(i, n) { var o = i.charCodeAt(n); if (isNaN(o)) return ""; if (o < 55296 || o > 57343) return i.charAt(n); if (55296 <= o && o <= 56319) { if (i.length <= n + 1) throw "High surrogate without following low surrogate"; var p = i.charCodeAt(n + 1); if (56320 > p || p > 57343) throw "High surrogate without following low surrogate"; return i.charAt(n) + i.charAt(n + 1) } if (n === 0) throw "Low surrogate without preceding high surrogate"; var f = i.charCodeAt(n - 1); if (55296 > f || f > 56319) throw "Low surrogate without preceding high surrogate"; return !1 } h.util.string = { camelize: d, capitalize: a, escapeXml: l, graphemeSplit: c } }(), function () { var d = Array.prototype.slice, a = function () { }, l = function () { for (var o in { toString: 1 }) if (o === "toString") return !1; return !0 }(), c = function (o, p, f) { for (var m in p) m in o.prototype && typeof o.prototype[m] == "function" && (p[m] + "").indexOf("callSuper") > -1 ? o.prototype[m] = function (y) { return function () { var C = this.constructor.superclass; this.constructor.superclass = f; var x = p[y].apply(this, arguments); if (this.constructor.superclass = C, y !== "initialize") return x } }(m) : o.prototype[m] = p[m], l && (p.toString !== Object.prototype.toString && (o.prototype.toString = p.toString), p.valueOf !== Object.prototype.valueOf && (o.prototype.valueOf = p.valueOf)) }; function r() { } function i(o) { for (var p = null, f = this; f.constructor.superclass;) { var m = f.constructor.superclass.prototype[o]; if (f[o] !== m) { p = m; break } f = f.constructor.superclass.prototype } return p ? arguments.length > 1 ? p.apply(this, d.call(arguments, 1)) : p.call(this) : console.log("tried to callSuper " + o + ", method not found in prototype chain", this) } function n() { var o = null, p = d.call(arguments, 0); typeof p[0] == "function" && (o = p.shift()); function f() { this.initialize.apply(this, arguments) } f.superclass = o, f.subclasses = [], o && (r.prototype = o.prototype, f.prototype = new r, o.subclasses.push(f)); for (var m = 0, y = p.length; m < y; m++)c(f, p[m], o); return f.prototype.initialize || (f.prototype.initialize = a), f.prototype.constructor = f, f.prototype.callSuper = i, f } h.util.createClass = n }(), function () { var d = !!h.document.createElement("div").attachEvent, a = ["touchstart", "touchmove", "touchend"]; h.util.addListener = function (c, r, i, n) { c && c.addEventListener(r, i, d ? !1 : n) }, h.util.removeListener = function (c, r, i, n) { c && c.removeEventListener(r, i, d ? !1 : n) }; function l(c) { var r = c.changedTouches; return r && r[0] ? r[0] : c } h.util.getPointer = function (c) { var r = c.target, i = h.util.getScrollLeftTop(r), n = l(c); return { x: n.clientX + i.left, y: n.clientY + i.top } }, h.util.isTouchEvent = function (c) { return a.indexOf(c.type) > -1 || c.pointerType === "touch" } }(), function () { function d(n, o) { var p = n.style; if (!p) return n; if (typeof o == "string") return n.style.cssText += ";" + o, o.indexOf("opacity") > -1 ? i(n, o.match(/opacity:\s*(\d?\.?\d*)/)[1]) : n; for (var f in o) if (f === "opacity") i(n, o[f]); else { var m = f === "float" || f === "cssFloat" ? typeof p.styleFloat > "u" ? "cssFloat" : "styleFloat" : f; p.setProperty(m, o[f]) } return n } var a = h.document.createElement("div"), l = typeof a.style.opacity == "string", c = typeof a.style.filter == "string", r = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, i = function (n) { return n }; l ? i = function (n, o) { return n.style.opacity = o, n } : c && (i = function (n, o) { var p = n.style; return n.currentStyle && !n.currentStyle.hasLayout && (p.zoom = 1), r.test(p.filter) ? (o = o >= .9999 ? "" : "alpha(opacity=" + o * 100 + ")", p.filter = p.filter.replace(r, o)) : p.filter += " alpha(opacity=" + o * 100 + ")", n }), h.util.setStyle = d }(), function () { var d = Array.prototype.slice; function a(x) { return typeof x == "string" ? h.document.getElementById(x) : x } var l, c = function (x) { return d.call(x, 0) }; try { l = c(h.document.childNodes) instanceof Array } catch { } l || (c = function (x) { for (var I = new Array(x.length), D = x.length; D--;)I[D] = x[D]; return I }); function r(x, I) { var D = h.document.createElement(x); for (var P in I) P === "class" ? D.className = I[P] : P === "for" ? D.htmlFor = I[P] : D.setAttribute(P, I[P]); return D } function i(x, I) { x && (" " + x.className + " ").indexOf(" " + I + " ") === -1 && (x.className += (x.className ? " " : "") + I) } function n(x, I, D) { return typeof I == "string" && (I = r(I, D)), x.parentNode && x.parentNode.replaceChild(I, x), I.appendChild(x), I } function o(x) { for (var I = 0, D = 0, P = h.document.documentElement, z = h.document.body || { scrollLeft: 0, scrollTop: 0 }; x && (x.parentNode || x.host) && (x = x.parentNode || x.host, x === h.document ? (I = z.scrollLeft || P.scrollLeft || 0, D = z.scrollTop || P.scrollTop || 0) : (I += x.scrollLeft || 0, D += x.scrollTop || 0), !(x.nodeType === 1 && x.style.position === "fixed"));); return { left: I, top: D } } function p(x) { var I, D = x && x.ownerDocument, P = { left: 0, top: 0 }, z = { left: 0, top: 0 }, et, tt = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!D) return z; for (var st in tt) z[tt[st]] += parseInt(f(x, st), 10) || 0; return I = D.documentElement, typeof x.getBoundingClientRect < "u" && (P = x.getBoundingClientRect()), et = o(x), { left: P.left + et.left - (I.clientLeft || 0) + z.left, top: P.top + et.top - (I.clientTop || 0) + z.top } } var f; h.document.defaultView && h.document.defaultView.getComputedStyle ? f = function (x, I) { var D = h.document.defaultView.getComputedStyle(x, null); return D ? D[I] : void 0 } : f = function (x, I) { var D = x.style[I]; return !D && x.currentStyle && (D = x.currentStyle[I]), D }, function () { var x = h.document.documentElement.style, I = "userSelect" in x ? "userSelect" : "MozUserSelect" in x ? "MozUserSelect" : "WebkitUserSelect" in x ? "WebkitUserSelect" : "KhtmlUserSelect" in x ? "KhtmlUserSelect" : ""; function D(z) { return typeof z.onselectstart < "u" && (z.onselectstart = h.util.falseFunction), I ? z.style[I] = "none" : typeof z.unselectable == "string" && (z.unselectable = "on"), z } function P(z) { return typeof z.onselectstart < "u" && (z.onselectstart = null), I ? z.style[I] = "" : typeof z.unselectable == "string" && (z.unselectable = ""), z } h.util.makeElementUnselectable = D, h.util.makeElementSelectable = P }(); function m(x) { var I = h.jsdomImplForWrapper(x); return I._canvas || I._image } function y(x) { if (h.isLikelyNode) { var I = h.jsdomImplForWrapper(x); I && (I._image = null, I._canvas = null, I._currentSrc = null, I._attributes = null, I._classList = null) } } function C(x, I) { x.imageSmoothingEnabled = x.imageSmoothingEnabled || x.webkitImageSmoothingEnabled || x.mozImageSmoothingEnabled || x.msImageSmoothingEnabled || x.oImageSmoothingEnabled, x.imageSmoothingEnabled = I } h.util.setImageSmoothing = C, h.util.getById = a, h.util.toArray = c, h.util.addClass = i, h.util.makeElement = r, h.util.wrapElement = n, h.util.getScrollLeftTop = o, h.util.getElementOffset = p, h.util.getNodeCanvas = m, h.util.cleanUpJsdomNode = y }(), function () { function d(c, r) { return c + (/\?/.test(c) ? "&" : "?") + r } function a() { } function l(c, r) { r || (r = {}); var i = r.method ? r.method.toUpperCase() : "GET", n = r.onComplete || function () { }, o = new h.window.XMLHttpRequest, p = r.body || r.parameters; return o.onreadystatechange = function () { o.readyState === 4 && (n(o), o.onreadystatechange = a) }, i === "GET" && (p = null, typeof r.parameters == "string" && (c = d(c, r.parameters))), o.open(i, c, !0), (i === "POST" || i === "PUT") && o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o.send(p), o } h.util.request = l }(), h.log = console.log, h.warn = console.warn, function () { var d = h.util.object.extend, a = h.util.object.clone, l = []; h.util.object.extend(l, { cancelAll: function () { var m = this.splice(0); return m.forEach(function (y) { y.cancel() }), m }, cancelByCanvas: function (m) { if (!m) return []; var y = this.filter(function (C) { return typeof C.target == "object" && C.target.canvas === m }); return y.forEach(function (C) { C.cancel() }), y }, cancelByTarget: function (m) { var y = this.findAnimationsByTarget(m); return y.forEach(function (C) { C.cancel() }), y }, findAnimationIndex: function (m) { return this.indexOf(this.findAnimation(m)) }, findAnimation: function (m) { return this.find(function (y) { return y.cancel === m }) }, findAnimationsByTarget: function (m) { return m ? this.filter(function (y) { return y.target === m }) : [] } }); function c() { return !1 } function r(m, y, C, x) { return -C * Math.cos(m / x * (Math.PI / 2)) + C + y } function i(m) { m || (m = {}); var y = !1, C, x = function () { var I = h.runningAnimations.indexOf(C); return I > -1 && h.runningAnimations.splice(I, 1)[0] }; return C = d(a(m), { cancel: function () { return y = !0, x() }, currentValue: "startValue" in m ? m.startValue : 0, completionRate: 0, durationRate: 0 }), h.runningAnimations.push(C), p(function (I) { var D = I || +new Date, P = m.duration || 500, z = D + P, et, tt = m.onChange || c, st = m.abort || c, dt = m.onComplete || c, q = m.easing || r, ct = "startValue" in m ? m.startValue.length > 0 : !1, W = "startValue" in m ? m.startValue : 0, Dt = "endValue" in m ? m.endValue : 100, Lt = m.byValue || (ct ? W.map(function (it, O) { return Dt[O] - W[O] }) : Dt - W); m.onStart && m.onStart(), function it(O) { et = O || +new Date; var V = et > z ? P : et - D, G = V / P, U = ct ? W.map(function (H, R) { return q(V, W[R], Lt[R], P) }) : q(V, W, Lt, P), lt = Math.abs(ct ? (U[0] - W[0]) / Lt[0] : (U - W) / Lt); if (C.currentValue = ct ? U.slice() : U, C.completionRate = lt, C.durationRate = G, !y) { if (st(U, lt, G)) { x(); return } if (et > z) { C.currentValue = ct ? Dt.slice() : Dt, C.completionRate = 1, C.durationRate = 1, tt(ct ? Dt.slice() : Dt, 1, 1), dt(Dt, 1, 1), x(); return } else tt(U, lt, G), p(it) } }(D) }), C.cancel } var n = h.window.requestAnimationFrame || h.window.webkitRequestAnimationFrame || h.window.mozRequestAnimationFrame || h.window.oRequestAnimationFrame || h.window.msRequestAnimationFrame || function (m) { return h.window.setTimeout(m, 1e3 / 60) }, o = h.window.cancelAnimationFrame || h.window.clearTimeout; function p() { return n.apply(h.window, arguments) } function f() { return o.apply(h.window, arguments) } h.util.animate = i, h.util.requestAnimFrame = p, h.util.cancelAnimFrame = f, h.runningAnimations = l }(), function () { function d(l, c, r) { var i = "rgba(" + parseInt(l[0] + r * (c[0] - l[0]), 10) + "," + parseInt(l[1] + r * (c[1] - l[1]), 10) + "," + parseInt(l[2] + r * (c[2] - l[2]), 10); return i += "," + (l && c ? parseFloat(l[3] + r * (c[3] - l[3])) : 1), i += ")", i } function a(l, c, r, i) { var n = new h.Color(l).getSource(), o = new h.Color(c).getSource(), p = i.onComplete, f = i.onChange; return i = i || {}, h.util.animate(h.util.object.extend(i, { duration: r || 500, startValue: n, endValue: o, byValue: o, easing: function (m, y, C, x) { var I = i.colorEasing ? i.colorEasing(m, x) : 1 - Math.cos(m / x * (Math.PI / 2)); return d(y, C, I) }, onComplete: function (m, y, C) { if (p) return p(d(o, o, 0), y, C) }, onChange: function (m, y, C) { if (f) { if (Array.isArray(m)) return f(d(m, m, 0), y, C); f(m, y, C) } } })) } h.util.animateColor = a }(), function () { function d(O, V, G, U) { return O < Math.abs(V) ? (O = V, U = G / 4) : V === 0 && O === 0 ? U = G / (2 * Math.PI) * Math.asin(1) : U = G / (2 * Math.PI) * Math.asin(V / O), { a: O, c: V, p: G, s: U } } function a(O, V, G) { return O.a * Math.pow(2, 10 * (V -= 1)) * Math.sin((V * G - O.s) * (2 * Math.PI) / O.p) } function l(O, V, G, U) { return G * ((O = O / U - 1) * O * O + 1) + V } function c(O, V, G, U) { return O /= U / 2, O < 1 ? G / 2 * O * O * O + V : G / 2 * ((O -= 2) * O * O + 2) + V } function r(O, V, G, U) { return G * (O /= U) * O * O * O + V } function i(O, V, G, U) { return -G * ((O = O / U - 1) * O * O * O - 1) + V } function n(O, V, G, U) { return O /= U / 2, O < 1 ? G / 2 * O * O * O * O + V : -G / 2 * ((O -= 2) * O * O * O - 2) + V } function o(O, V, G, U) { return G * (O /= U) * O * O * O * O + V } function p(O, V, G, U) { return G * ((O = O / U - 1) * O * O * O * O + 1) + V } function f(O, V, G, U) { return O /= U / 2, O < 1 ? G / 2 * O * O * O * O * O + V : G / 2 * ((O -= 2) * O * O * O * O + 2) + V } function m(O, V, G, U) { return -G * Math.cos(O / U * (Math.PI / 2)) + G + V } function y(O, V, G, U) { return G * Math.sin(O / U * (Math.PI / 2)) + V } function C(O, V, G, U) { return -G / 2 * (Math.cos(Math.PI * O / U) - 1) + V } function x(O, V, G, U) { return O === 0 ? V : G * Math.pow(2, 10 * (O / U - 1)) + V } function I(O, V, G, U) { return O === U ? V + G : G * (-Math.pow(2, -10 * O / U) + 1) + V } function D(O, V, G, U) { return O === 0 ? V : O === U ? V + G : (O /= U / 2, O < 1 ? G / 2 * Math.pow(2, 10 * (O - 1)) + V : G / 2 * (-Math.pow(2, -10 * --O) + 2) + V) } function P(O, V, G, U) { return -G * (Math.sqrt(1 - (O /= U) * O) - 1) + V } function z(O, V, G, U) { return G * Math.sqrt(1 - (O = O / U - 1) * O) + V } function et(O, V, G, U) { return O /= U / 2, O < 1 ? -G / 2 * (Math.sqrt(1 - O * O) - 1) + V : G / 2 * (Math.sqrt(1 - (O -= 2) * O) + 1) + V } function tt(O, V, G, U) { var lt = 1.70158, H = 0, R = G; if (O === 0) return V; if (O /= U, O === 1) return V + G; H || (H = U * .3); var K = d(R, G, H, lt); return -a(K, O, U) + V } function st(O, V, G, U) { var lt = 1.70158, H = 0, R = G; if (O === 0) return V; if (O /= U, O === 1) return V + G; H || (H = U * .3); var K = d(R, G, H, lt); return K.a * Math.pow(2, -10 * O) * Math.sin((O * U - K.s) * (2 * Math.PI) / K.p) + K.c + V } function dt(O, V, G, U) { var lt = 1.70158, H = 0, R = G; if (O === 0) return V; if (O /= U / 2, O === 2) return V + G; H || (H = U * (.3 * 1.5)); var K = d(R, G, H, lt); return O < 1 ? -.5 * a(K, O, U) + V : K.a * Math.pow(2, -10 * (O -= 1)) * Math.sin((O * U - K.s) * (2 * Math.PI) / K.p) * .5 + K.c + V } function q(O, V, G, U, lt) { return lt === void 0 && (lt = 1.70158), G * (O /= U) * O * ((lt + 1) * O - lt) + V } function ct(O, V, G, U, lt) { return lt === void 0 && (lt = 1.70158), G * ((O = O / U - 1) * O * ((lt + 1) * O + lt) + 1) + V } function W(O, V, G, U, lt) { return lt === void 0 && (lt = 1.70158), O /= U / 2, O < 1 ? G / 2 * (O * O * (((lt *= 1.525) + 1) * O - lt)) + V : G / 2 * ((O -= 2) * O * (((lt *= 1.525) + 1) * O + lt) + 2) + V } function Dt(O, V, G, U) { return G - Lt(U - O, 0, G, U) + V } function Lt(O, V, G, U) { return (O /= U) < 1 / 2.75 ? G * (7.5625 * O * O) + V : O < 2 / 2.75 ? G * (7.5625 * (O -= 1.5 / 2.75) * O + .75) + V : O < 2.5 / 2.75 ? G * (7.5625 * (O -= 2.25 / 2.75) * O + .9375) + V : G * (7.5625 * (O -= 2.625 / 2.75) * O + .984375) + V } function it(O, V, G, U) { return O < U / 2 ? Dt(O * 2, 0, G, U) * .5 + V : Lt(O * 2 - U, 0, G, U) * .5 + G * .5 + V } h.util.ease = { easeInQuad: function (O, V, G, U) { return G * (O /= U) * O + V }, easeOutQuad: function (O, V, G, U) { return -G * (O /= U) * (O - 2) + V }, easeInOutQuad: function (O, V, G, U) { return O /= U / 2, O < 1 ? G / 2 * O * O + V : -G / 2 * (--O * (O - 2) - 1) + V }, easeInCubic: function (O, V, G, U) { return G * (O /= U) * O * O + V }, easeOutCubic: l, easeInOutCubic: c, easeInQuart: r, easeOutQuart: i, easeInOutQuart: n, easeInQuint: o, easeOutQuint: p, easeInOutQuint: f, easeInSine: m, easeOutSine: y, easeInOutSine: C, easeInExpo: x, easeOutExpo: I, easeInOutExpo: D, easeInCirc: P, easeOutCirc: z, easeInOutCirc: et, easeInElastic: tt, easeOutElastic: st, easeInOutElastic: dt, easeInBack: q, easeOutBack: ct, easeInOutBack: W, easeInBounce: Dt, easeOutBounce: Lt, easeInOutBounce: it } }(), function (d) { var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.util.object.clone, r = a.util.toFixed, i = a.util.parseUnit, n = a.util.multiplyTransformMatrices, o = ["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"], p = ["symbol", "image", "marker", "pattern", "view", "svg"], f = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], m = ["symbol", "g", "a", "svg", "clipPath", "defs"], y = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, C = { stroke: "strokeOpacity", fill: "fillOpacity" }, x = "font-size", I = "clip-path"; a.svgValidTagNamesRegEx = z(o), a.svgViewBoxElementsRegEx = z(p), a.svgInvalidAncestorsRegEx = z(f), a.svgValidParentsRegEx = z(m), a.cssRules = {}, a.gradientDefs = {}, a.clipPaths = {}; function D(H) { return H in y ? y[H] : H } function P(H, R, K, J) { var ht = Array.isArray(R), ut; if ((H === "fill" || H === "stroke") && R === "none") R = ""; else { if (H === "strokeUniform") return R === "non-scaling-stroke"; if (H === "strokeDashArray") R === "none" ? R = null : R = R.replace(/,/g, " ").split(/\s+/).map(parseFloat); else if (H === "transformMatrix") K && K.transformMatrix ? R = n(K.transformMatrix, a.parseTransformAttribute(R)) : R = a.parseTransformAttribute(R); else if (H === "visible") R = R !== "none" && R !== "hidden", K && K.visible === !1 && (R = !1); else if (H === "opacity") R = parseFloat(R), K && typeof K.opacity < "u" && (R *= K.opacity); else if (H === "textAnchor") R = R === "start" ? "left" : R === "end" ? "right" : "center"; else if (H === "charSpacing") ut = i(R, J) / J * 1e3; else if (H === "paintFirst") { var _t = R.indexOf("fill"), mt = R.indexOf("stroke"), R = "fill"; (_t > -1 && mt > -1 && mt < _t || _t === -1 && mt > -1) && (R = "stroke") } else { if (H === "href" || H === "xlink:href" || H === "font") return R; if (H === "imageSmoothing") return R === "optimizeQuality"; ut = ht ? R.map(i) : i(R, J) } } return !ht && isNaN(ut) ? R : ut } function z(H) { return new RegExp("^(" + H.join("|") + ")\\b", "i") } function et(H) { for (var R in C) if (!(typeof H[C[R]] > "u" || H[R] === "")) { if (typeof H[R] > "u") { if (!a.Object.prototype[R]) continue; H[R] = a.Object.prototype[R] } if (H[R].indexOf("url(") !== 0) { var K = new a.Color(H[R]); H[R] = K.setAlpha(r(K.getAlpha() * H[C[R]], 2)).toRgba() } } return H } function tt(H, R) { var K, J = [], ht, ut, _t; for (ut = 0, _t = R.length; ut < _t; ut++)K = R[ut], ht = H.getElementsByTagName(K), J = J.concat(Array.prototype.slice.call(ht)); return J } a.parseTransformAttribute = function () { function H(Q, $) { var rt = a.util.cos($[0]), at = a.util.sin($[0]), yt = 0, bt = 0; $.length === 3 && (yt = $[1], bt = $[2]), Q[0] = rt, Q[1] = at, Q[2] = -at, Q[3] = rt, Q[4] = yt - (rt * yt - at * bt), Q[5] = bt - (at * yt + rt * bt) } function R(Q, $) { var rt = $[0], at = $.length === 2 ? $[1] : $[0]; Q[0] = rt, Q[3] = at } function K(Q, $, rt) { Q[rt] = Math.tan(a.util.degreesToRadians($[0])) } function J(Q, $) { Q[4] = $[0], $.length === 2 && (Q[5] = $[1]) } var ht = a.iMatrix, ut = a.reNum, _t = a.commaWsp, mt = "(?:(skewX)\\s*\\(\\s*(" + ut + ")\\s*\\))", St = "(?:(skewY)\\s*\\(\\s*(" + ut + ")\\s*\\))", gt = "(?:(rotate)\\s*\\(\\s*(" + ut + ")(?:" + _t + "(" + ut + ")" + _t + "(" + ut + "))?\\s*\\))", ft = "(?:(scale)\\s*\\(\\s*(" + ut + ")(?:" + _t + "(" + ut + "))?\\s*\\))", wt = "(?:(translate)\\s*\\(\\s*(" + ut + ")(?:" + _t + "(" + ut + "))?\\s*\\))", xt = "(?:(matrix)\\s*\\(\\s*(" + ut + ")" + _t + "(" + ut + ")" + _t + "(" + ut + ")" + _t + "(" + ut + ")" + _t + "(" + ut + ")" + _t + "(" + ut + ")\\s*\\))", pt = "(?:" + xt + "|" + wt + "|" + ft + "|" + gt + "|" + mt + "|" + St + ")", vt = "(?:" + pt + "(?:" + _t + "*" + pt + ")*)", kt = "^\\s*(?:" + vt + "?)\\s*$", L = new RegExp(kt), N = new RegExp(pt, "g"); return function (Q) { var $ = ht.concat(), rt = []; if (!Q || Q && !L.test(Q)) return $; Q.replace(N, function (yt) { var bt = new RegExp(pt).exec(yt).filter(function (Qt) { return !!Qt }), Et = bt[1], Ft = bt.slice(2).map(parseFloat); switch (Et) { case "translate": J($, Ft); break; case "rotate": Ft[0] = a.util.degreesToRadians(Ft[0]), H($, Ft); break; case "scale": R($, Ft); break; case "skewX": K($, Ft, 2); break; case "skewY": K($, Ft, 1); break; case "matrix": $ = Ft; break }rt.push($.concat()), $ = ht.concat() }); for (var at = rt[0]; rt.length > 1;)rt.shift(), at = a.util.multiplyTransformMatrices(at, rt[0]); return at } }(); function st(H, R) { var K, J; H.replace(/;\s*$/, "").split(";").forEach(function (ht) { var ut = ht.split(":"); K = ut[0].trim().toLowerCase(), J = ut[1].trim(), R[K] = J }) } function dt(H, R) { var K, J; for (var ht in H) typeof H[ht] > "u" || (K = ht.toLowerCase(), J = H[ht], R[K] = J) } function q(H, R) { var K = {}; for (var J in a.cssRules[R]) if (ct(H, J.split(" "))) for (var ht in a.cssRules[R][J]) K[ht] = a.cssRules[R][J][ht]; return K } function ct(H, R) { var K, J = !0; return K = Dt(H, R.pop()), K && R.length && (J = W(H, R)), K && J && R.length === 0 } function W(H, R) { for (var K, J = !0; H.parentNode && H.parentNode.nodeType === 1 && R.length;)J && (K = R.pop()), H = H.parentNode, J = Dt(H, K); return R.length === 0 } function Dt(H, R) { var K = H.nodeName, J = H.getAttribute("class"), ht = H.getAttribute("id"), ut, _t; if (ut = new RegExp("^" + K, "i"), R = R.replace(ut, ""), ht && R.length && (ut = new RegExp("#" + ht + "(?![a-zA-Z\\-]+)", "i"), R = R.replace(ut, "")), J && R.length) for (J = J.split(" "), _t = J.length; _t--;)ut = new RegExp("\\." + J[_t] + "(?![a-zA-Z\\-]+)", "i"), R = R.replace(ut, ""); return R.length === 0 } function Lt(H, R) { var K; if (H.getElementById && (K = H.getElementById(R)), K) return K; var J, ht, ut, _t = H.getElementsByTagName("*"); for (ht = 0, ut = _t.length; ht < ut; ht++)if (J = _t[ht], R === J.getAttribute("id")) return J } function it(H) { for (var R = tt(H, ["use", "svg:use"]), K = 0; R.length && K < R.length;) { var J = R[K], ht = J.getAttribute("xlink:href") || J.getAttribute("href"); if (ht === null) return; var ut = ht.slice(1), _t = J.getAttribute("x") || 0, mt = J.getAttribute("y") || 0, St = Lt(H, ut).cloneNode(!0), gt = (St.getAttribute("transform") || "") + " translate(" + _t + ", " + mt + ")", ft, wt = R.length, xt, pt, vt, kt, L = a.svgNS; if (V(St), /^svg$/i.test(St.nodeName)) { var N = St.ownerDocument.createElementNS(L, "g"); for (pt = 0, vt = St.attributes, kt = vt.length; pt < kt; pt++)xt = vt.item(pt), N.setAttributeNS(L, xt.nodeName, xt.nodeValue); for (; St.firstChild;)N.appendChild(St.firstChild); St = N } for (pt = 0, vt = J.attributes, kt = vt.length; pt < kt; pt++)xt = vt.item(pt), !(xt.nodeName === "x" || xt.nodeName === "y" || xt.nodeName === "xlink:href" || xt.nodeName === "href") && (xt.nodeName === "transform" ? gt = xt.nodeValue + " " + gt : St.setAttribute(xt.nodeName, xt.nodeValue)); St.setAttribute("transform", gt), St.setAttribute("instantiated_by_use", "1"), St.removeAttribute("id"), ft = J.parentNode, ft.replaceChild(St, J), R.length === wt && K++ } } var O = new RegExp("^\\s*(" + a.reNum + "+)\\s*,?\\s*(" + a.reNum + "+)\\s*,?\\s*(" + a.reNum + "+)\\s*,?\\s*(" + a.reNum + "+)\\s*$"); function V(H) { if (!a.svgViewBoxElementsRegEx.test(H.nodeName)) return {}; var R = H.getAttribute("viewBox"), K = 1, J = 1, ht = 0, ut = 0, _t, mt, St, gt, ft = H.getAttribute("width"), wt = H.getAttribute("height"), xt = H.getAttribute("x") || 0, pt = H.getAttribute("y") || 0, vt = H.getAttribute("preserveAspectRatio") || "", kt = !R || !(R = R.match(O)), L = !ft || !wt || ft === "100%" || wt === "100%", N = kt && L, Q = {}, $ = "", rt = 0, at = 0; if (Q.width = 0, Q.height = 0, Q.toBeParsed = N, kt && (xt || pt) && H.parentNode && H.parentNode.nodeName !== "#document" && ($ = " translate(" + i(xt) + " " + i(pt) + ") ", St = (H.getAttribute("transform") || "") + $, H.setAttribute("transform", St), H.removeAttribute("x"), H.removeAttribute("y")), N) return Q; if (kt) return Q.width = i(ft), Q.height = i(wt), Q; if (ht = -parseFloat(R[1]), ut = -parseFloat(R[2]), _t = parseFloat(R[3]), mt = parseFloat(R[4]), Q.minX = ht, Q.minY = ut, Q.viewBoxWidth = _t, Q.viewBoxHeight = mt, L ? (Q.width = _t, Q.height = mt) : (Q.width = i(ft), Q.height = i(wt), K = Q.width / _t, J = Q.height / mt), vt = a.util.parsePreserveAspectRatioAttribute(vt), vt.alignX !== "none" && (vt.meetOrSlice === "meet" && (J = K = K > J ? J : K), vt.meetOrSlice === "slice" && (J = K = K > J ? K : J), rt = Q.width - _t * K, at = Q.height - mt * K, vt.alignX === "Mid" && (rt /= 2), vt.alignY === "Mid" && (at /= 2), vt.alignX === "Min" && (rt = 0), vt.alignY === "Min" && (at = 0)), K === 1 && J === 1 && ht === 0 && ut === 0 && xt === 0 && pt === 0) return Q; if ((xt || pt) && H.parentNode.nodeName !== "#document" && ($ = " translate(" + i(xt) + " " + i(pt) + ") "), St = $ + " matrix(" + K + " 0 0 " + J + " " + (ht * K + rt) + " " + (ut * J + at) + ") ", H.nodeName === "svg") { for (gt = H.ownerDocument.createElementNS(a.svgNS, "g"); H.firstChild;)gt.appendChild(H.firstChild); H.appendChild(gt) } else gt = H, gt.removeAttribute("x"), gt.removeAttribute("y"), St = gt.getAttribute("transform") + St; return gt.setAttribute("transform", St), Q } function G(H, R) { for (; H && (H = H.parentNode);)if (H.nodeName && R.test(H.nodeName.replace("svg:", "")) && !H.getAttribute("instantiated_by_use")) return !0; return !1 } a.parseSVGDocument = function (H, R, K, J) { if (H) { it(H); var ht = a.Object.__uid++, ut, _t, mt = V(H), St = a.util.toArray(H.getElementsByTagName("*")); if (mt.crossOrigin = J && J.crossOrigin, mt.svgUid = ht, St.length === 0 && a.isLikelyNode) { St = H.selectNodes('//*[name(.)!="svg"]'); var gt = []; for (ut = 0, _t = St.length; ut < _t; ut++)gt[ut] = St[ut]; St = gt } var ft = St.filter(function (xt) { return V(xt), a.svgValidTagNamesRegEx.test(xt.nodeName.replace("svg:", "")) && !G(xt, a.svgInvalidAncestorsRegEx) }); if (!ft || ft && !ft.length) { R && R([], {}); return } var wt = {}; St.filter(function (xt) { return xt.nodeName.replace("svg:", "") === "clipPath" }).forEach(function (xt) { var pt = xt.getAttribute("id"); wt[pt] = a.util.toArray(xt.getElementsByTagName("*")).filter(function (vt) { return a.svgValidTagNamesRegEx.test(vt.nodeName.replace("svg:", "")) }) }), a.gradientDefs[ht] = a.getGradientDefs(H), a.cssRules[ht] = a.getCSSRules(H), a.clipPaths[ht] = wt, a.parseElements(ft, function (xt, pt) { R && (R(xt, mt, pt, St), delete a.gradientDefs[ht], delete a.cssRules[ht], delete a.clipPaths[ht]) }, c(mt), K, J) } }; function U(H, R) { var K = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], J = "xlink:href", ht = R.getAttribute(J).slice(1), ut = Lt(H, ht); if (ut && ut.getAttribute(J) && U(H, ut), K.forEach(function (mt) { ut && !R.hasAttribute(mt) && ut.hasAttribute(mt) && R.setAttribute(mt, ut.getAttribute(mt)) }), !R.children.length) for (var _t = ut.cloneNode(!0); _t.firstChild;)R.appendChild(_t.firstChild); R.removeAttribute(J) } var lt = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + a.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + a.reNum + "))?\\s+(.*)"); l(a, { parseFontDeclaration: function (H, R) { var K = H.match(lt); if (K) { var J = K[1], ht = K[3], ut = K[4], _t = K[5], mt = K[6]; J && (R.fontStyle = J), ht && (R.fontWeight = isNaN(parseFloat(ht)) ? ht : parseFloat(ht)), ut && (R.fontSize = i(ut)), mt && (R.fontFamily = mt), _t && (R.lineHeight = _t === "normal" ? 1 : _t) } }, getGradientDefs: function (H) { var R = ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"], K = tt(H, R), J, ht = 0, ut = {}; for (ht = K.length; ht--;)J = K[ht], J.getAttribute("xlink:href") && U(H, J), ut[J.getAttribute("id")] = J; return ut }, parseAttributes: function (H, R, K) { if (H) { var J, ht = {}, ut, _t; typeof K > "u" && (K = H.getAttribute("svgUid")), H.parentNode && a.svgValidParentsRegEx.test(H.parentNode.nodeName) && (ht = a.parseAttributes(H.parentNode, R, K)); var mt = R.reduce(function (vt, kt) { return J = H.getAttribute(kt), J && (vt[kt] = J), vt }, {}), St = l(q(H, K), a.parseStyleAttribute(H)); mt = l(mt, St), St[I] && H.setAttribute(I, St[I]), ut = _t = ht.fontSize || a.Text.DEFAULT_SVG_FONT_SIZE, mt[x] && (mt[x] = ut = i(mt[x], _t)); var gt, ft, wt = {}; for (var xt in mt) gt = D(xt), ft = P(gt, mt[xt], ht, ut), wt[gt] = ft; wt && wt.font && a.parseFontDeclaration(wt.font, wt); var pt = l(ht, wt); return a.svgValidParentsRegEx.test(H.nodeName) ? pt : et(pt) } }, parseElements: function (H, R, K, J, ht) { new a.ElementsParser(H, R, K, J, ht).parse() }, parseStyleAttribute: function (H) { var R = {}, K = H.getAttribute("style"); return K && (typeof K == "string" ? st(K, R) : dt(K, R)), R }, parsePointsAttribute: function (H) { if (!H) return null; H = H.replace(/,/g, " ").trim(), H = H.split(/\s+/); var R = [], K, J; for (K = 0, J = H.length; K < J; K += 2)R.push({ x: parseFloat(H[K]), y: parseFloat(H[K + 1]) }); return R }, getCSSRules: function (H) { var R = H.getElementsByTagName("style"), K, J, ht = {}, ut; for (K = 0, J = R.length; K < J; K++) { var _t = R[K].textContent; _t = _t.replace(/\/\*[\s\S]*?\*\//g, ""), _t.trim() !== "" && (ut = _t.split("}"), ut = ut.filter(function (mt) { return mt.trim() }), ut.forEach(function (mt) { var St = mt.split("{"), gt = {}, ft = St[1].trim(), wt = ft.split(";").filter(function (kt) { return kt.trim() }); for (K = 0, J = wt.length; K < J; K++) { var xt = wt[K].split(":"), pt = xt[0].trim(), vt = xt[1].trim(); gt[pt] = vt } mt = St[0].trim(), mt.split(",").forEach(function (kt) { kt = kt.replace(/^svg/i, "").trim(), kt !== "" && (ht[kt] ? a.util.object.extend(ht[kt], gt) : ht[kt] = a.util.object.clone(gt)) }) })) } return ht }, loadSVGFromURL: function (H, R, K, J) { H = H.replace(/^\n\s*/, "").trim(), new a.util.request(H, { method: "get", onComplete: ht }); function ht(ut) { var _t = ut.responseXML; if (!_t || !_t.documentElement) return R && R(null), !1; a.parseSVGDocument(_t.documentElement, function (mt, St, gt, ft) { R && R(mt, St, gt, ft) }, K, J) } }, loadSVGFromString: function (H, R, K, J) { var ht = new a.window.DOMParser, ut = ht.parseFromString(H.trim(), "text/xml"); a.parseSVGDocument(ut.documentElement, function (_t, mt, St, gt) { R(_t, mt, St, gt) }, K, J) } }) }(v), h.ElementsParser = function (d, a, l, c, r, i) { this.elements = d, this.callback = a, this.options = l, this.reviver = c, this.svgUid = l && l.svgUid || 0, this.parsingOptions = r, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = i }, function (d) { d.parse = function () { this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects() }, d.createObjects = function () { var a = this; this.elements.forEach(function (l, c) { l.setAttribute("svgUid", a.svgUid), a.createObject(l, c) }) }, d.findTag = function (a) { return h[h.util.string.capitalize(a.tagName.replace("svg:", ""))] }, d.createObject = function (a, l) { var c = this.findTag(a); if (c && c.fromElement) try { c.fromElement(a, this.createCallback(l, a), this.options) } catch (r) { h.log(r) } else this.checkIfDone() }, d.createCallback = function (a, l) { var c = this; return function (r) { var i; c.resolveGradient(r, l, "fill"), c.resolveGradient(r, l, "stroke"), r instanceof h.Image && r._originalElement && (i = r.parsePreserveAspectRatioAttribute(l)), r._removeTransformMatrix(i), c.resolveClipPath(r, l), c.reviver && c.reviver(l, r), c.instances[a] = r, c.checkIfDone() } }, d.extractPropertyDefinition = function (a, l, c) { var r = a[l], i = this.regexUrl; if (i.test(r)) { i.lastIndex = 0; var n = i.exec(r)[1]; return i.lastIndex = 0, h[c][this.svgUid][n] } }, d.resolveGradient = function (a, l, c) { var r = this.extractPropertyDefinition(a, c, "gradientDefs"); if (r) { var i = l.getAttribute(c + "-opacity"), n = h.Gradient.fromElement(r, a, i, this.options); a.set(c, n) } }, d.createClipPathCallback = function (a, l) { return function (c) { c._removeTransformMatrix(), c.fillRule = c.clipRule, l.push(c) } }, d.resolveClipPath = function (a, l) { var c = this.extractPropertyDefinition(a, "clipPath", "clipPaths"), r, i, n, o, p, f; if (c) { o = [], n = h.util.invertTransform(a.calcTransformMatrix()); for (var m = c[0].parentNode, y = l; y.parentNode && y.getAttribute("clip-path") !== a.clipPath;)y = y.parentNode; y.parentNode.appendChild(m); for (var C = 0; C < c.length; C++)r = c[C], i = this.findTag(r), i.fromElement(r, this.createClipPathCallback(a, o), this.options); o.length === 1 ? c = o[0] : c = new h.Group(o), p = h.util.multiplyTransformMatrices(n, c.calcTransformMatrix()), c.clipPath && this.resolveClipPath(c, y); var f = h.util.qrDecompose(p); c.flipX = !1, c.flipY = !1, c.set("scaleX", f.scaleX), c.set("scaleY", f.scaleY), c.angle = f.angle, c.skewX = f.skewX, c.skewY = 0, c.setPositionByOrigin({ x: f.translateX, y: f.translateY }, "center", "center"), a.clipPath = c } else delete a.clipPath }, d.checkIfDone = function () { --this.numElements === 0 && (this.instances = this.instances.filter(function (a) { return a != null }), this.callback(this.instances, this.elements)) } }(h.ElementsParser.prototype), function (d) { var a = d.fabric || (d.fabric = {}); if (a.Point) { a.warn("fabric.Point is already defined"); return } a.Point = l; function l(c, r) { this.x = c, this.y = r } l.prototype = { type: "point", constructor: l, add: function (c) { return new l(this.x + c.x, this.y + c.y) }, addEquals: function (c) { return this.x += c.x, this.y += c.y, this }, scalarAdd: function (c) { return new l(this.x + c, this.y + c) }, scalarAddEquals: function (c) { return this.x += c, this.y += c, this }, subtract: function (c) { return new l(this.x - c.x, this.y - c.y) }, subtractEquals: function (c) { return this.x -= c.x, this.y -= c.y, this }, scalarSubtract: function (c) { return new l(this.x - c, this.y - c) }, scalarSubtractEquals: function (c) { return this.x -= c, this.y -= c, this }, multiply: function (c) { return new l(this.x * c, this.y * c) }, multiplyEquals: function (c) { return this.x *= c, this.y *= c, this }, divide: function (c) { return new l(this.x / c, this.y / c) }, divideEquals: function (c) { return this.x /= c, this.y /= c, this }, eq: function (c) { return this.x === c.x && this.y === c.y }, lt: function (c) { return this.x < c.x && this.y < c.y }, lte: function (c) { return this.x <= c.x && this.y <= c.y }, gt: function (c) { return this.x > c.x && this.y > c.y }, gte: function (c) { return this.x >= c.x && this.y >= c.y }, lerp: function (c, r) { return typeof r > "u" && (r = .5), r = Math.max(Math.min(1, r), 0), new l(this.x + (c.x - this.x) * r, this.y + (c.y - this.y) * r) }, distanceFrom: function (c) { var r = this.x - c.x, i = this.y - c.y; return Math.sqrt(r * r + i * i) }, midPointFrom: function (c) { return this.lerp(c) }, min: function (c) { return new l(Math.min(this.x, c.x), Math.min(this.y, c.y)) }, max: function (c) { return new l(Math.max(this.x, c.x), Math.max(this.y, c.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (c, r) { return this.x = c, this.y = r, this }, setX: function (c) { return this.x = c, this }, setY: function (c) { return this.y = c, this }, setFromPoint: function (c) { return this.x = c.x, this.y = c.y, this }, swap: function (c) { var r = this.x, i = this.y; this.x = c.x, this.y = c.y, c.x = r, c.y = i }, clone: function () { return new l(this.x, this.y) } } }(v), function (d) { var a = d.fabric || (d.fabric = {}); if (a.Intersection) { a.warn("fabric.Intersection is already defined"); return } function l(c) { this.status = c, this.points = [] } a.Intersection = l, a.Intersection.prototype = { constructor: l, appendPoint: function (c) { return this.points.push(c), this }, appendPoints: function (c) { return this.points = this.points.concat(c), this } }, a.Intersection.intersectLineLine = function (c, r, i, n) { var o, p = (n.x - i.x) * (c.y - i.y) - (n.y - i.y) * (c.x - i.x), f = (r.x - c.x) * (c.y - i.y) - (r.y - c.y) * (c.x - i.x), m = (n.y - i.y) * (r.x - c.x) - (n.x - i.x) * (r.y - c.y); if (m !== 0) { var y = p / m, C = f / m; 0 <= y && y <= 1 && 0 <= C && C <= 1 ? (o = new l("Intersection"), o.appendPoint(new a.Point(c.x + y * (r.x - c.x), c.y + y * (r.y - c.y)))) : o = new l } else p === 0 || f === 0 ? o = new l("Coincident") : o = new l("Parallel"); return o }, a.Intersection.intersectLinePolygon = function (c, r, i) { var n = new l, o = i.length, p, f, m, y; for (y = 0; y < o; y++)p = i[y], f = i[(y + 1) % o], m = l.intersectLineLine(c, r, p, f), n.appendPoints(m.points); return n.points.length > 0 && (n.status = "Intersection"), n }, a.Intersection.intersectPolygonPolygon = function (c, r) { var i = new l, n = c.length, o; for (o = 0; o < n; o++) { var p = c[o], f = c[(o + 1) % n], m = l.intersectLinePolygon(p, f, r); i.appendPoints(m.points) } return i.points.length > 0 && (i.status = "Intersection"), i }, a.Intersection.intersectPolygonRectangle = function (c, r, i) { var n = r.min(i), o = r.max(i), p = new a.Point(o.x, n.y), f = new a.Point(n.x, o.y), m = l.intersectLinePolygon(n, p, c), y = l.intersectLinePolygon(p, o, c), C = l.intersectLinePolygon(o, f, c), x = l.intersectLinePolygon(f, n, c), I = new l; return I.appendPoints(m.points), I.appendPoints(y.points), I.appendPoints(C.points), I.appendPoints(x.points), I.points.length > 0 && (I.status = "Intersection"), I } }(v), function (d) { var a = d.fabric || (d.fabric = {}); if (a.Color) { a.warn("fabric.Color is already defined."); return } function l(r) { r ? this._tryParsingColor(r) : this.setSource([0, 0, 0, 1]) } a.Color = l, a.Color.prototype = { _tryParsingColor: function (r) { var i; r in l.colorNameMap && (r = l.colorNameMap[r]), r === "transparent" && (i = [255, 255, 255, 0]), i || (i = l.sourceFromHex(r)), i || (i = l.sourceFromRgb(r)), i || (i = l.sourceFromHsl(r)), i || (i = [0, 0, 0, 1]), i && this.setSource(i) }, _rgbToHsl: function (r, i, n) { r /= 255, i /= 255, n /= 255; var o, p, f, m = a.util.array.max([r, i, n]), y = a.util.array.min([r, i, n]); if (f = (m + y) / 2, m === y) o = p = 0; else { var C = m - y; switch (p = f > .5 ? C / (2 - m - y) : C / (m + y), m) { case r: o = (i - n) / C + (i < n ? 6 : 0); break; case i: o = (n - r) / C + 2; break; case n: o = (r - i) / C + 4; break }o /= 6 } return [Math.round(o * 360), Math.round(p * 100), Math.round(f * 100)] }, getSource: function () { return this._source }, setSource: function (r) { this._source = r }, toRgb: function () { var r = this.getSource(); return "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")" }, toRgba: function () { var r = this.getSource(); return "rgba(" + r[0] + "," + r[1] + "," + r[2] + "," + r[3] + ")" }, toHsl: function () { var r = this.getSource(), i = this._rgbToHsl(r[0], r[1], r[2]); return "hsl(" + i[0] + "," + i[1] + "%," + i[2] + "%)" }, toHsla: function () { var r = this.getSource(), i = this._rgbToHsl(r[0], r[1], r[2]); return "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + r[3] + ")" }, toHex: function () { var r = this.getSource(), i, n, o; return i = r[0].toString(16), i = i.length === 1 ? "0" + i : i, n = r[1].toString(16), n = n.length === 1 ? "0" + n : n, o = r[2].toString(16), o = o.length === 1 ? "0" + o : o, i.toUpperCase() + n.toUpperCase() + o.toUpperCase() }, toHexa: function () { var r = this.getSource(), i; return i = Math.round(r[3] * 255), i = i.toString(16), i = i.length === 1 ? "0" + i : i, this.toHex() + i.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (r) { var i = this.getSource(); return i[3] = r, this.setSource(i), this }, toGrayscale: function () { var r = this.getSource(), i = parseInt((r[0] * .3 + r[1] * .59 + r[2] * .11).toFixed(0), 10), n = r[3]; return this.setSource([i, i, i, n]), this }, toBlackWhite: function (r) { var i = this.getSource(), n = (i[0] * .3 + i[1] * .59 + i[2] * .11).toFixed(0), o = i[3]; return r = r || 127, n = Number(n) < Number(r) ? 0 : 255, this.setSource([n, n, n, o]), this }, overlayWith: function (r) { r instanceof l || (r = new l(r)); var i = [], n = this.getAlpha(), o = .5, p = this.getSource(), f = r.getSource(), m; for (m = 0; m < 3; m++)i.push(Math.round(p[m] * (1 - o) + f[m] * o)); return i[3] = n, this.setSource(i), this } }, a.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, a.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, a.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, a.Color.colorNameMap = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#663399", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: "#9ACD32" }; function c(r, i, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + (i - r) * 6 * n : n < 1 / 2 ? i : n < 2 / 3 ? r + (i - r) * (2 / 3 - n) * 6 : r } a.Color.fromRgb = function (r) { return l.fromSource(l.sourceFromRgb(r)) }, a.Color.sourceFromRgb = function (r) { var i = r.match(l.reRGBa); if (i) { var n = parseInt(i[1], 10) / (/%$/.test(i[1]) ? 100 : 1) * (/%$/.test(i[1]) ? 255 : 1), o = parseInt(i[2], 10) / (/%$/.test(i[2]) ? 100 : 1) * (/%$/.test(i[2]) ? 255 : 1), p = parseInt(i[3], 10) / (/%$/.test(i[3]) ? 100 : 1) * (/%$/.test(i[3]) ? 255 : 1); return [parseInt(n, 10), parseInt(o, 10), parseInt(p, 10), i[4] ? parseFloat(i[4]) : 1] } }, a.Color.fromRgba = l.fromRgb, a.Color.fromHsl = function (r) { return l.fromSource(l.sourceFromHsl(r)) }, a.Color.sourceFromHsl = function (r) { var i = r.match(l.reHSLa); if (i) { var n = (parseFloat(i[1]) % 360 + 360) % 360 / 360, o = parseFloat(i[2]) / (/%$/.test(i[2]) ? 100 : 1), p = parseFloat(i[3]) / (/%$/.test(i[3]) ? 100 : 1), f, m, y; if (o === 0) f = m = y = p; else { var C = p <= .5 ? p * (o + 1) : p + o - p * o, x = p * 2 - C; f = c(x, C, n + 1 / 3), m = c(x, C, n), y = c(x, C, n - 1 / 3) } return [Math.round(f * 255), Math.round(m * 255), Math.round(y * 255), i[4] ? parseFloat(i[4]) : 1] } }, a.Color.fromHsla = l.fromHsl, a.Color.fromHex = function (r) { return l.fromSource(l.sourceFromHex(r)) }, a.Color.sourceFromHex = function (r) { if (r.match(l.reHex)) { var i = r.slice(r.indexOf("#") + 1), n = i.length === 3 || i.length === 4, o = i.length === 8 || i.length === 4, p = n ? i.charAt(0) + i.charAt(0) : i.substring(0, 2), f = n ? i.charAt(1) + i.charAt(1) : i.substring(2, 4), m = n ? i.charAt(2) + i.charAt(2) : i.substring(4, 6), y = o ? n ? i.charAt(3) + i.charAt(3) : i.substring(6, 8) : "FF"; return [parseInt(p, 16), parseInt(f, 16), parseInt(m, 16), parseFloat((parseInt(y, 16) / 255).toFixed(2))] } }, a.Color.fromSource = function (r) { var i = new l; return i.setSource(r), i } }(v), function (d) { var a = d.fabric || (d.fabric = {}), l = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], c = ["ns", "nesw", "ew", "nwse"], r = {}, i = "left", n = "top", o = "right", p = "bottom", f = "center", m = { top: p, bottom: n, left: o, right: i, center: f }, y = a.util.radiansToDegrees, C = Math.sign || function (gt) { return (gt > 0) - (gt < 0) || +gt }; function x(gt, ft) { var wt = gt.angle + y(Math.atan2(ft.y, ft.x)) + 360; return Math.round(wt % 360 / 45) } function I(gt, ft) { var wt = ft.transform.target, xt = wt.canvas, pt = a.util.object.clone(ft); pt.target = wt, xt && xt.fire("object:" + gt, pt), wt.fire(gt, ft) } function D(gt, ft) { var wt = ft.canvas, xt = wt.uniScaleKey, pt = gt[xt]; return wt.uniformScaling && !pt || !wt.uniformScaling && pt } function P(gt) { return gt.originX === f && gt.originY === f } function z(gt, ft, wt) { var xt = gt.lockScalingX, pt = gt.lockScalingY; return !!(xt && pt || !ft && (xt || pt) && wt || xt && ft === "x" || pt && ft === "y") } function et(gt, ft, wt) { var xt = "not-allowed", pt = D(gt, wt), vt = ""; if (ft.x !== 0 && ft.y === 0 ? vt = "x" : ft.x === 0 && ft.y !== 0 && (vt = "y"), z(wt, vt, pt)) return xt; var kt = x(wt, ft); return l[kt] + "-resize" } function tt(gt, ft, wt) { var xt = "not-allowed"; if (ft.x !== 0 && wt.lockSkewingY || ft.y !== 0 && wt.lockSkewingX) return xt; var pt = x(wt, ft) % 4; return c[pt] + "-resize" } function st(gt, ft, wt) { return gt[wt.canvas.altActionKey] ? r.skewCursorStyleHandler(gt, ft, wt) : r.scaleCursorStyleHandler(gt, ft, wt) } function dt(gt, ft, wt) { var xt = gt[wt.canvas.altActionKey]; if (ft.x === 0) return xt ? "skewX" : "scaleY"; if (ft.y === 0) return xt ? "skewY" : "scaleX" } function q(gt, ft, wt) { return wt.lockRotation ? "not-allowed" : ft.cursorStyle } function ct(gt, ft, wt, xt) { return { e: gt, transform: ft, pointer: { x: wt, y: xt } } } function W(gt) { return function (ft, wt, xt, pt) { var vt = wt.target, kt = vt.getCenterPoint(), L = vt.translateToOriginPoint(kt, wt.originX, wt.originY), N = gt(ft, wt, xt, pt); return vt.setPositionByOrigin(L, wt.originX, wt.originY), N } } function Dt(gt, ft) { return function (wt, xt, pt, vt) { var kt = ft(wt, xt, pt, vt); return kt && I(gt, ct(wt, xt, pt, vt)), kt } } function Lt(gt, ft, wt, xt, pt) { var vt = gt.target, kt = vt.controls[gt.corner], L = vt.canvas.getZoom(), N = vt.padding / L, Q = vt.toLocalPoint(new a.Point(xt, pt), ft, wt); return Q.x >= N && (Q.x -= N), Q.x <= -N && (Q.x += N), Q.y >= N && (Q.y -= N), Q.y <= N && (Q.y += N), Q.x -= kt.offsetX, Q.y -= kt.offsetY, Q } function it(gt) { return gt.flipX !== gt.flipY } function O(gt, ft, wt, xt, pt) { if (gt[ft] !== 0) { var vt = gt._getTransformedDimensions()[xt], kt = pt / vt * gt[wt]; gt.set(wt, kt) } } function V(gt, ft, wt, xt) { var pt = ft.target, vt = pt._getTransformedDimensions(0, pt.skewY), kt = Lt(ft, ft.originX, ft.originY, wt, xt), L = Math.abs(kt.x * 2) - vt.x, N = pt.skewX, Q; L < 2 ? Q = 0 : (Q = y(Math.atan2(L / pt.scaleX, vt.y / pt.scaleY)), ft.originX === i && ft.originY === p && (Q = -Q), ft.originX === o && ft.originY === n && (Q = -Q), it(pt) && (Q = -Q)); var $ = N !== Q; if ($) { var rt = pt._getTransformedDimensions().y; pt.set("skewX", Q), O(pt, "skewY", "scaleY", "y", rt) } return $ } function G(gt, ft, wt, xt) { var pt = ft.target, vt = pt._getTransformedDimensions(pt.skewX, 0), kt = Lt(ft, ft.originX, ft.originY, wt, xt), L = Math.abs(kt.y * 2) - vt.y, N = pt.skewY, Q; L < 2 ? Q = 0 : (Q = y(Math.atan2(L / pt.scaleY, vt.x / pt.scaleX)), ft.originX === i && ft.originY === p && (Q = -Q), ft.originX === o && ft.originY === n && (Q = -Q), it(pt) && (Q = -Q)); var $ = N !== Q; if ($) { var rt = pt._getTransformedDimensions().x; pt.set("skewY", Q), O(pt, "skewX", "scaleX", "x", rt) } return $ } function U(gt, ft, wt, xt) { var pt = ft.target, vt = pt.skewX, kt, L = ft.originY; if (pt.lockSkewingX) return !1; if (vt === 0) { var N = Lt(ft, f, f, wt, xt); N.x > 0 ? kt = i : kt = o } else vt > 0 && (kt = L === n ? i : o), vt < 0 && (kt = L === n ? o : i), it(pt) && (kt = kt === i ? o : i); ft.originX = kt; var Q = Dt("skewing", W(V)); return Q(gt, ft, wt, xt) } function lt(gt, ft, wt, xt) { var pt = ft.target, vt = pt.skewY, kt, L = ft.originX; if (pt.lockSkewingY) return !1; if (vt === 0) { var N = Lt(ft, f, f, wt, xt); N.y > 0 ? kt = n : kt = p } else vt > 0 && (kt = L === i ? n : p), vt < 0 && (kt = L === i ? p : n), it(pt) && (kt = kt === n ? p : n); ft.originY = kt; var Q = Dt("skewing", W(G)); return Q(gt, ft, wt, xt) } function H(gt, ft, wt, xt) { var pt = ft, vt = pt.target, kt = vt.translateToOriginPoint(vt.getCenterPoint(), pt.originX, pt.originY); if (vt.lockRotation) return !1; var L = Math.atan2(pt.ey - kt.y, pt.ex - kt.x), N = Math.atan2(xt - kt.y, wt - kt.x), Q = y(N - L + pt.theta), $ = !0; if (vt.snapAngle > 0) { var rt = vt.snapAngle, at = vt.snapThreshold || rt, yt = Math.ceil(Q / rt) * rt, bt = Math.floor(Q / rt) * rt; Math.abs(Q - bt) < at ? Q = bt : Math.abs(Q - yt) < at && (Q = yt) } return Q < 0 && (Q = 360 + Q), Q %= 360, $ = vt.angle !== Q, vt.angle = Q, $ } function R(gt, ft, wt, xt, pt) { pt = pt || {}; var vt = ft.target, kt = vt.lockScalingX, L = vt.lockScalingY, N = pt.by, Q, $, rt, at, yt = D(gt, vt), bt = z(vt, N, yt), Et, Ft, Qt = ft.gestureScale; if (bt) return !1; if (Qt) $ = ft.scaleX * Qt, rt = ft.scaleY * Qt; else { if (Q = Lt(ft, ft.originX, ft.originY, wt, xt), Et = N !== "y" ? C(Q.x) : 1, Ft = N !== "x" ? C(Q.y) : 1, ft.signX || (ft.signX = Et), ft.signY || (ft.signY = Ft), vt.lockScalingFlip && (ft.signX !== Et || ft.signY !== Ft)) return !1; if (at = vt._getTransformedDimensions(), yt && !N) { var jt = Math.abs(Q.x) + Math.abs(Q.y), Gt = ft.original, Kt = Math.abs(at.x * Gt.scaleX / vt.scaleX) + Math.abs(at.y * Gt.scaleY / vt.scaleY), ae = jt / Kt; $ = Gt.scaleX * ae, rt = Gt.scaleY * ae } else $ = Math.abs(Q.x * vt.scaleX / at.x), rt = Math.abs(Q.y * vt.scaleY / at.y); P(ft) && ($ *= 2, rt *= 2), ft.signX !== Et && N !== "y" && (ft.originX = m[ft.originX], $ *= -1, ft.signX = Et), ft.signY !== Ft && N !== "x" && (ft.originY = m[ft.originY], rt *= -1, ft.signY = Ft) } var ee = vt.scaleX, ke = vt.scaleY; return N ? (N === "x" && vt.set("scaleX", $), N === "y" && vt.set("scaleY", rt)) : (!kt && vt.set("scaleX", $), !L && vt.set("scaleY", rt)), ee !== vt.scaleX || ke !== vt.scaleY } function K(gt, ft, wt, xt) { return R(gt, ft, wt, xt) } function J(gt, ft, wt, xt) { return R(gt, ft, wt, xt, { by: "x" }) } function ht(gt, ft, wt, xt) { return R(gt, ft, wt, xt, { by: "y" }) } function ut(gt, ft, wt, xt) { return gt[ft.target.canvas.altActionKey] ? r.skewHandlerX(gt, ft, wt, xt) : r.scalingY(gt, ft, wt, xt) } function _t(gt, ft, wt, xt) { return gt[ft.target.canvas.altActionKey] ? r.skewHandlerY(gt, ft, wt, xt) : r.scalingX(gt, ft, wt, xt) } function mt(gt, ft, wt, xt) { var pt = ft.target, vt = Lt(ft, ft.originX, ft.originY, wt, xt), kt = pt.strokeWidth / (pt.strokeUniform ? pt.scaleX : 1), L = P(ft) ? 2 : 1, N = pt.width, Q = Math.abs(vt.x * L / pt.scaleX) - kt; return pt.set("width", Math.max(Q, 0)), N !== Q } function St(gt, ft, wt, xt) { var pt = ft.target, vt = wt - ft.offsetX, kt = xt - ft.offsetY, L = !pt.get("lockMovementX") && pt.left !== vt, N = !pt.get("lockMovementY") && pt.top !== kt; return L && pt.set("left", vt), N && pt.set("top", kt), (L || N) && I("moving", ct(gt, ft, wt, xt)), L || N } r.scaleCursorStyleHandler = et, r.skewCursorStyleHandler = tt, r.scaleSkewCursorStyleHandler = st, r.rotationWithSnapping = Dt("rotating", W(H)), r.scalingEqually = Dt("scaling", W(K)), r.scalingX = Dt("scaling", W(J)), r.scalingY = Dt("scaling", W(ht)), r.scalingYOrSkewingX = ut, r.scalingXOrSkewingY = _t, r.changeWidth = Dt("resizing", W(mt)), r.skewHandlerX = U, r.skewHandlerY = lt, r.dragHandler = St, r.scaleOrSkewActionName = dt, r.rotationStyleHandler = q, r.fireEvent = I, r.wrapWithFixedAnchor = W, r.wrapWithFireEvent = Dt, r.getLocalPoint = Lt, a.controlsUtils = r }(v), function (d) { var a = d.fabric || (d.fabric = {}), l = a.util.degreesToRadians, c = a.controlsUtils; function r(n, o, p, f, m) { f = f || {}; var y = this.sizeX || f.cornerSize || m.cornerSize, C = this.sizeY || f.cornerSize || m.cornerSize, x = typeof f.transparentCorners < "u" ? f.transparentCorners : m.transparentCorners, I = x ? "stroke" : "fill", D = !x && (f.cornerStrokeColor || m.cornerStrokeColor), P = o, z = p, et; n.save(), n.fillStyle = f.cornerColor || m.cornerColor, n.strokeStyle = f.cornerStrokeColor || m.cornerStrokeColor, y > C ? (et = y, n.scale(1, C / y), z = p * y / C) : C > y ? (et = C, n.scale(y / C, 1), P = o * C / y) : et = y, n.lineWidth = 1, n.beginPath(), n.arc(P, z, et / 2, 0, 2 * Math.PI, !1), n[I](), D && n.stroke(), n.restore() } function i(n, o, p, f, m) { f = f || {}; var y = this.sizeX || f.cornerSize || m.cornerSize, C = this.sizeY || f.cornerSize || m.cornerSize, x = typeof f.transparentCorners < "u" ? f.transparentCorners : m.transparentCorners, I = x ? "stroke" : "fill", D = !x && (f.cornerStrokeColor || m.cornerStrokeColor), P = y / 2, z = C / 2; n.save(), n.fillStyle = f.cornerColor || m.cornerColor, n.strokeStyle = f.cornerStrokeColor || m.cornerStrokeColor, n.lineWidth = 1, n.translate(o, p), n.rotate(l(m.angle)), n[I + "Rect"](-P, -z, y, C), D && n.strokeRect(-P, -z, y, C), n.restore() } c.renderCircleControl = r, c.renderSquareControl = i }(v), function (d) { var a = d.fabric || (d.fabric = {}); function l(c) { for (var r in c) this[r] = c[r] } a.Control = l, a.Control.prototype = { visible: !0, actionName: "scale", angle: 0, x: 0, y: 0, offsetX: 0, offsetY: 0, sizeX: null, sizeY: null, touchSizeX: null, touchSizeY: null, cursorStyle: "crosshair", withConnection: !1, actionHandler: function () { }, mouseDownHandler: function () { }, mouseUpHandler: function () { }, getActionHandler: function () { return this.actionHandler }, getMouseDownHandler: function () { return this.mouseDownHandler }, getMouseUpHandler: function () { return this.mouseUpHandler }, cursorStyleHandler: function (c, r) { return r.cursorStyle }, getActionName: function (c, r) { return r.actionName }, getVisibility: function (c, r) { var i = c._controlsVisibility; return i && typeof i[r] < "u" ? i[r] : this.visible }, setVisibility: function (c) { this.visible = c }, positionHandler: function (c, r) { var i = a.util.transformPoint({ x: this.x * c.x + this.offsetX, y: this.y * c.y + this.offsetY }, r); return i }, calcCornerCoords: function (c, r, i, n, o) { var p, f, m, y, C = o ? this.touchSizeX : this.sizeX, x = o ? this.touchSizeY : this.sizeY; if (C && x && C !== x) { var I = Math.atan2(x, C), D = Math.sqrt(C * C + x * x) / 2, P = I - a.util.degreesToRadians(c), z = Math.PI / 2 - I - a.util.degreesToRadians(c); p = D * a.util.cos(P), f = D * a.util.sin(P), m = D * a.util.cos(z), y = D * a.util.sin(z) } else { var et = C && x ? C : r; D = et * .7071067812; var P = a.util.degreesToRadians(45 - c); p = m = D * a.util.cos(P), f = y = D * a.util.sin(P) } return { tl: { x: i - y, y: n - m }, tr: { x: i + p, y: n - f }, bl: { x: i - p, y: n + f }, br: { x: i + y, y: n + m } } }, render: function (c, r, i, n, o) { switch (n = n || {}, n.cornerStyle || o.cornerStyle) { case "circle": a.controlsUtils.renderCircleControl.call(this, c, r, i, n, o); break; default: a.controlsUtils.renderSquareControl.call(this, c, r, i, n, o) } } } }(v), function () {
  function d(i, n) { var o = i.getAttribute("style"), p = i.getAttribute("offset") || 0, f, m, y, C; if (p = parseFloat(p) / (/%$/.test(p) ? 100 : 1), p = p < 0 ? 0 : p > 1 ? 1 : p, o) { var x = o.split(/\s*;\s*/); for (x[x.length - 1] === "" && x.pop(), C = x.length; C--;) { var I = x[C].split(/\s*:\s*/), D = I[0].trim(), P = I[1].trim(); D === "stop-color" ? f = P : D === "stop-opacity" && (y = P) } } return f || (f = i.getAttribute("stop-color") || "rgb(0,0,0)"), y || (y = i.getAttribute("stop-opacity")), f = new h.Color(f), m = f.getAlpha(), y = isNaN(parseFloat(y)) ? 1 : parseFloat(y), y *= m * n, { offset: p, color: f.toRgb(), opacity: y } } function a(i) { return { x1: i.getAttribute("x1") || 0, y1: i.getAttribute("y1") || 0, x2: i.getAttribute("x2") || "100%", y2: i.getAttribute("y2") || 0 } } function l(i) { return { x1: i.getAttribute("fx") || i.getAttribute("cx") || "50%", y1: i.getAttribute("fy") || i.getAttribute("cy") || "50%", r1: 0, x2: i.getAttribute("cx") || "50%", y2: i.getAttribute("cy") || "50%", r2: i.getAttribute("r") || "50%" } } var c = h.util.object.clone; h.Gradient = h.util.createClass({
    offsetX: 0, offsetY: 0, gradientTransform: null, gradientUnits: "pixels", type: "linear", initialize: function (i) { i || (i = {}), i.coords || (i.coords = {}); var n, o = this; Object.keys(i).forEach(function (p) { o[p] = i[p] }), this.id ? this.id += "_" + h.Object.__uid++ : this.id = h.Object.__uid++, n = { x1: i.coords.x1 || 0, y1: i.coords.y1 || 0, x2: i.coords.x2 || 0, y2: i.coords.y2 || 0 }, this.type === "radial" && (n.r1 = i.coords.r1 || 0, n.r2 = i.coords.r2 || 0), this.coords = n, this.colorStops = i.colorStops.slice() }, addColorStop: function (i) { for (var n in i) { var o = new h.Color(i[n]); this.colorStops.push({ offset: parseFloat(n), color: o.toRgb(), opacity: o.getAlpha() }) } return this }, toObject: function (i) { var n = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform }; return h.util.populateWithProperties(this, n, i), n }, toSVG: function (i, m) {
      var o = c(this.coords, !0), p, f, m = m || {}, y, C, x = c(this.colorStops, !0), I = o.r1 > o.r2, D = this.gradientTransform ? this.gradientTransform.concat() : h.iMatrix.concat(), P = -this.offsetX, z = -this.offsetY, et = !!m.additionalTransform, tt = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox"; if (x.sort(function (W, Dt) { return W.offset - Dt.offset }), tt === "objectBoundingBox" ? (P /= i.width, z /= i.height) : (P += i.width / 2, z += i.height / 2), i.type === "path" && this.gradientUnits !== "percentage" && (P -= i.pathOffset.x, z -= i.pathOffset.y), D[4] -= P, D[5] -= z, C = 'id="SVGID_' + this.id + '" gradientUnits="' + tt + '"', C += ' gradientTransform="' + (et ? m.additionalTransform + " " : "") + h.util.matrixToSVG(D) + '" ', this.type === "linear" ? y = ["<linearGradient ", C, ' x1="', o.x1, '" y1="', o.y1, '" x2="', o.x2, '" y2="', o.y2, `">
`] : this.type === "radial" && (y = ["<radialGradient ", C, ' cx="', I ? o.x1 : o.x2, '" cy="', I ? o.y1 : o.y2, '" r="', I ? o.r1 : o.r2, '" fx="', I ? o.x2 : o.x1, '" fy="', I ? o.y2 : o.y1, `">
`]), this.type === "radial") { if (I) for (x = x.concat(), x.reverse(), p = 0, f = x.length; p < f; p++)x[p].offset = 1 - x[p].offset; var st = Math.min(o.r1, o.r2); if (st > 0) { var dt = Math.max(o.r1, o.r2), q = st / dt; for (p = 0, f = x.length; p < f; p++)x[p].offset += q * (1 - x[p].offset) } } for (p = 0, f = x.length; p < f; p++) {
        var ct = x[p]; y.push("<stop ", 'offset="', ct.offset * 100 + "%", '" style="stop-color:', ct.color, typeof ct.opacity < "u" ? ";stop-opacity: " + ct.opacity : ";", `"/>
`)
      } return y.push(this.type === "linear" ? `</linearGradient>
`: `</radialGradient>
`), y.join("")
    }, toLive: function (i) { var n, o = h.util.object.clone(this.coords), p, f; if (this.type) { for (this.type === "linear" ? n = i.createLinearGradient(o.x1, o.y1, o.x2, o.y2) : this.type === "radial" && (n = i.createRadialGradient(o.x1, o.y1, o.r1, o.x2, o.y2, o.r2)), p = 0, f = this.colorStops.length; p < f; p++) { var m = this.colorStops[p].color, y = this.colorStops[p].opacity, C = this.colorStops[p].offset; typeof y < "u" && (m = new h.Color(m).setAlpha(y).toRgba()), n.addColorStop(C, m) } return n } }
  }), h.util.object.extend(h.Gradient, { fromElement: function (i, n, o, p) { var f = parseFloat(o) / (/%$/.test(o) ? 100 : 1); f = f < 0 ? 0 : f > 1 ? 1 : f, isNaN(f) && (f = 1); var m = i.getElementsByTagName("stop"), y, C = i.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", x = i.getAttribute("gradientTransform") || "", I = [], D, P, z = 0, et = 0, tt; for (i.nodeName === "linearGradient" || i.nodeName === "LINEARGRADIENT" ? (y = "linear", D = a(i)) : (y = "radial", D = l(i)), P = m.length; P--;)I.push(d(m[P], f)); tt = h.parseTransformAttribute(x), r(n, D, p, C), C === "pixels" && (z = -n.left, et = -n.top); var st = new h.Gradient({ id: i.getAttribute("id"), type: y, coords: D, colorStops: I, gradientUnits: C, gradientTransform: tt, offsetX: z, offsetY: et }); return st } }); function r(i, n, o, p) { var f, m; Object.keys(n).forEach(function (y) { f = n[y], f === "Infinity" ? m = 1 : f === "-Infinity" ? m = 0 : (m = parseFloat(n[y], 10), typeof f == "string" && /^(\d+\.\d+)%|(\d+)%$/.test(f) && (m *= .01, p === "pixels" && ((y === "x1" || y === "x2" || y === "r2") && (m *= o.viewBoxWidth || o.width), (y === "y1" || y === "y2") && (m *= o.viewBoxHeight || o.height)))), n[y] = m }) }
}(), function () {
  var d = h.util.toFixed; h.Pattern = h.util.createClass({
    repeat: "repeat", offsetX: 0, offsetY: 0, crossOrigin: "", patternTransform: null, initialize: function (a, l) { if (a || (a = {}), this.id = h.Object.__uid++, this.setOptions(a), !a.source || a.source && typeof a.source != "string") { l && l(this); return } else { var c = this; this.source = h.util.createImage(), h.util.loadImage(a.source, function (r, i) { c.source = r, l && l(c, i) }, null, this.crossOrigin) } }, toObject: function (a) { var l = h.Object.NUM_FRACTION_DIGITS, c, r; return typeof this.source.src == "string" ? c = this.source.src : typeof this.source == "object" && this.source.toDataURL && (c = this.source.toDataURL()), r = { type: "pattern", source: c, repeat: this.repeat, crossOrigin: this.crossOrigin, offsetX: d(this.offsetX, l), offsetY: d(this.offsetY, l), patternTransform: this.patternTransform ? this.patternTransform.concat() : null }, h.util.populateWithProperties(this, r, a), r }, toSVG: function (a) {
      var l = typeof this.source == "function" ? this.source() : this.source, c = l.width / a.width, r = l.height / a.height, i = this.offsetX / a.width, n = this.offsetY / a.height, o = ""; return (this.repeat === "repeat-x" || this.repeat === "no-repeat") && (r = 1, n && (r += Math.abs(n))), (this.repeat === "repeat-y" || this.repeat === "no-repeat") && (c = 1, i && (c += Math.abs(i))), l.src ? o = l.src : l.toDataURL && (o = l.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + i + '" y="' + n + '" width="' + c + '" height="' + r + `">
<image x="0" y="0" width="`+ l.width + '" height="' + l.height + '" xlink:href="' + o + `"></image>
</pattern>
`}, setOptions: function (a) { for (var l in a) this[l] = a[l] }, toLive: function (a) { var l = this.source; return !l || typeof l.src < "u" && (!l.complete || l.naturalWidth === 0 || l.naturalHeight === 0) ? "" : a.createPattern(l, this.repeat) }
  })
}(), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.toFixed; if (a.Shadow) { a.warn("fabric.Shadow is already defined."); return } a.Shadow = a.util.createClass({
    color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1, initialize: function (c) { typeof c == "string" && (c = this._parseShadow(c)); for (var r in c) this[r] = c[r]; this.id = a.Object.__uid++ }, _parseShadow: function (c) { var r = c.trim(), i = a.Shadow.reOffsetsAndBlur.exec(r) || [], n = r.replace(a.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)"; return { color: n.trim(), offsetX: parseFloat(i[1], 10) || 0, offsetY: parseFloat(i[2], 10) || 0, blur: parseFloat(i[3], 10) || 0 } }, toString: function () { return [this.offsetX, this.offsetY, this.blur, this.color].join("px ") }, toSVG: function (c) {
      var r = 40, i = 40, n = a.Object.NUM_FRACTION_DIGITS, o = a.util.rotateVector({ x: this.offsetX, y: this.offsetY }, a.util.degreesToRadians(-c.angle)), p = 20, f = new a.Color(this.color); return c.width && c.height && (r = l((Math.abs(o.x) + this.blur) / c.width, n) * 100 + p, i = l((Math.abs(o.y) + this.blur) / c.height, n) * 100 + p), c.flipX && (o.x *= -1), c.flipY && (o.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + i + '%" height="' + (100 + 2 * i) + '%" x="-' + r + '%" width="' + (100 + 2 * r) + `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`+ l(this.blur ? this.blur / 2 : 0, n) + `"></feGaussianBlur>
	<feOffset dx="`+ l(o.x, n) + '" dy="' + l(o.y, n) + `" result="oBlur" ></feOffset>
	<feFlood flood-color="`+ f.toRgb() + '" flood-opacity="' + f.getAlpha() + `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`}, toObject: function () { if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling }; var c = {}, r = a.Shadow.prototype; return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function (i) { this[i] !== r[i] && (c[i] = this[i]) }, this), c }
  }), a.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/
}(v), function () {
  if (h.StaticCanvas) { h.warn("fabric.StaticCanvas is already defined."); return } var d = h.util.object.extend, a = h.util.getElementOffset, l = h.util.removeFromArray, c = h.util.toFixed, r = h.util.transformPoint, i = h.util.invertTransform, n = h.util.getNodeCanvas, o = h.util.createCanvasElement, p = new Error("Could not initialize `canvas` element"); h.StaticCanvas = h.util.createClass(h.CommonMethods, {
    initialize: function (f, m) { m || (m = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(f, m) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: h.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !0, clipPath: void 0, _initStatic: function (f, m) { var y = this.requestRenderAllBound; this._objects = [], this._createLowerCanvas(f), this._initOptions(m), this.interactive || this._initRetinaScaling(), m.overlayImage && this.setOverlayImage(m.overlayImage, y), m.backgroundImage && this.setBackgroundImage(m.backgroundImage, y), m.backgroundColor && this.setBackgroundColor(m.backgroundColor, y), m.overlayColor && this.setOverlayColor(m.overlayColor, y), this.calcOffset() }, _isRetinaScaling: function () { return h.devicePixelRatio > 1 && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? Math.max(1, h.devicePixelRatio) : 1 }, _initRetinaScaling: function () { if (this._isRetinaScaling()) { var f = h.devicePixelRatio; this.__initRetinaScaling(f, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(f, this.upperCanvasEl, this.contextTop) } }, __initRetinaScaling: function (f, m, y) { m.setAttribute("width", this.width * f), m.setAttribute("height", this.height * f), y.scale(f, f) }, calcOffset: function () { return this._offset = a(this.lowerCanvasEl), this }, setOverlayImage: function (f, m, y) { return this.__setBgOverlayImage("overlayImage", f, m, y) }, setBackgroundImage: function (f, m, y) { return this.__setBgOverlayImage("backgroundImage", f, m, y) }, setOverlayColor: function (f, m) { return this.__setBgOverlayColor("overlayColor", f, m) }, setBackgroundColor: function (f, m) { return this.__setBgOverlayColor("backgroundColor", f, m) }, __setBgOverlayImage: function (f, m, y, C) { return typeof m == "string" ? h.util.loadImage(m, function (x, I) { if (x) { var D = new h.Image(x, C); this[f] = D, D.canvas = this } y && y(x, I) }, this, C && C.crossOrigin) : (C && m.setOptions(C), this[f] = m, m && (m.canvas = this), y && y(m, !1)), this }, __setBgOverlayColor: function (f, m, y) { return this[f] = m, this._initGradient(m, f), this._initPattern(m, f, y), this }, _createCanvasElement: function () { var f = o(); if (!f || (f.style || (f.style = {}), typeof f.getContext > "u")) throw p; return f }, _initOptions: function (f) { var m = this.lowerCanvasEl; this._setOptions(f), this.width = this.width || parseInt(m.width, 10) || 0, this.height = this.height || parseInt(m.height, 10) || 0, this.lowerCanvasEl.style && (m.width = this.width, m.height = this.height, m.style.width = this.width + "px", m.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (f) { f && f.getContext ? this.lowerCanvasEl = f : this.lowerCanvasEl = h.util.getById(f) || this._createCanvasElement(), h.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (f, m) { return this.setDimensions({ width: f }, m) }, setHeight: function (f, m) { return this.setDimensions({ height: f }, m) }, setDimensions: function (f, m) { var y; m = m || {}; for (var C in f) y = f[C], m.cssOnly || (this._setBackstoreDimension(C, f[C]), y += "px", this.hasLostContext = !0), m.backstoreOnly || this._setCssDimension(C, y); return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), m.cssOnly || this.requestRenderAll(), this }, _setBackstoreDimension: function (f, m) { return this.lowerCanvasEl[f] = m, this.upperCanvasEl && (this.upperCanvasEl[f] = m), this.cacheCanvasEl && (this.cacheCanvasEl[f] = m), this[f] = m, this }, _setCssDimension: function (f, m) { return this.lowerCanvasEl.style[f] = m, this.upperCanvasEl && (this.upperCanvasEl.style[f] = m), this.wrapperEl && (this.wrapperEl.style[f] = m), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (f) { var m = this._activeObject, y = this.backgroundImage, C = this.overlayImage, x, I, D; for (this.viewportTransform = f, I = 0, D = this._objects.length; I < D; I++)x = this._objects[I], x.group || x.setCoords(!0); return m && m.setCoords(), y && y.setCoords(!0), C && C.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this }, zoomToPoint: function (f, m) { var y = f, C = this.viewportTransform.slice(0); f = r(f, i(this.viewportTransform)), C[0] = m, C[3] = m; var x = r(f, C); return C[4] += y.x - x.x, C[5] += y.y - x.y, this.setViewportTransform(C) }, setZoom: function (f) { return this.zoomToPoint(new h.Point(0, 0), f), this }, absolutePan: function (f) { var m = this.viewportTransform.slice(0); return m[4] = -f.x, m[5] = -f.y, this.setViewportTransform(m) }, relativePan: function (f) { return this.absolutePan(new h.Point(-f.x - this.viewportTransform[4], -f.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (f) { this.stateful && f.setupState(), f._set("canvas", this), f.setCoords(), this.fire("object:added", { target: f }), f.fire("added") }, _onObjectRemoved: function (f) { this.fire("object:removed", { target: f }), f.fire("removed"), delete f.canvas }, clearContext: function (f) { return f.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this }, renderAll: function () { var f = this.contextContainer; return this.renderCanvas(f, this._objects), this }, renderAndReset: function () { this.isRendering = 0, this.renderAll() }, requestRenderAll: function () { return this.isRendering || (this.isRendering = h.util.requestAnimFrame(this.renderAndResetBound)), this }, calcViewportBoundaries: function () { var f = {}, m = this.width, y = this.height, C = i(this.viewportTransform); return f.tl = r({ x: 0, y: 0 }, C), f.br = r({ x: m, y }, C), f.tr = new h.Point(f.br.x, f.tl.y), f.bl = new h.Point(f.tl.x, f.br.y), this.vptCoords = f, f }, cancelRequestedRender: function () { this.isRendering && (h.util.cancelAnimFrame(this.isRendering), this.isRendering = 0) }, renderCanvas: function (f, m) { var y = this.viewportTransform, C = this.clipPath; this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(f), h.util.setImageSmoothing(f, this.imageSmoothingEnabled), this.fire("before:render", { ctx: f }), this._renderBackground(f), f.save(), f.transform(y[0], y[1], y[2], y[3], y[4], y[5]), this._renderObjects(f, m), f.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(f), C && (C.canvas = this, C.shouldCache(), C._transformDone = !0, C.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(f)), this._renderOverlay(f), this.controlsAboveOverlay && this.interactive && this.drawControls(f), this.fire("after:render", { ctx: f }) }, drawClipPathOnCanvas: function (f) { var m = this.viewportTransform, y = this.clipPath; f.save(), f.transform(m[0], m[1], m[2], m[3], m[4], m[5]), f.globalCompositeOperation = "destination-in", y.transform(f), f.scale(1 / y.zoomX, 1 / y.zoomY), f.drawImage(y._cacheCanvas, -y.cacheTranslationX, -y.cacheTranslationY), f.restore() }, _renderObjects: function (f, m) { var y, C; for (y = 0, C = m.length; y < C; ++y)m[y] && m[y].render(f) }, _renderBackgroundOrOverlay: function (f, m) { var y = this[m + "Color"], C = this[m + "Image"], x = this.viewportTransform, I = this[m + "Vpt"]; if (!(!y && !C)) { if (y) { f.save(), f.beginPath(), f.moveTo(0, 0), f.lineTo(this.width, 0), f.lineTo(this.width, this.height), f.lineTo(0, this.height), f.closePath(), f.fillStyle = y.toLive ? y.toLive(f, this) : y, I && f.transform(x[0], x[1], x[2], x[3], x[4], x[5]), f.transform(1, 0, 0, 1, y.offsetX || 0, y.offsetY || 0); var D = y.gradientTransform || y.patternTransform; D && f.transform(D[0], D[1], D[2], D[3], D[4], D[5]), f.fill(), f.restore() } C && (f.save(), I && f.transform(x[0], x[1], x[2], x[3], x[4], x[5]), C.render(f), f.restore()) } }, _renderBackground: function (f) { this._renderBackgroundOrOverlay(f, "background") }, _renderOverlay: function (f) { this._renderBackgroundOrOverlay(f, "overlay") }, getCenter: function () { return { top: this.height / 2, left: this.width / 2 } }, getCenterPoint: function () { return new h.Point(this.width / 2, this.height / 2) }, centerObjectH: function (f) { return this._centerObject(f, new h.Point(this.getCenterPoint().x, f.getCenterPoint().y)) }, centerObjectV: function (f) { return this._centerObject(f, new h.Point(f.getCenterPoint().x, this.getCenterPoint().y)) }, centerObject: function (f) { var m = this.getCenterPoint(); return this._centerObject(f, m) }, viewportCenterObject: function (f) { var m = this.getVpCenter(); return this._centerObject(f, m) }, viewportCenterObjectH: function (f) { var m = this.getVpCenter(); return this._centerObject(f, new h.Point(m.x, f.getCenterPoint().y)), this }, viewportCenterObjectV: function (f) { var m = this.getVpCenter(); return this._centerObject(f, new h.Point(f.getCenterPoint().x, m.y)) }, getVpCenter: function () { var f = this.getCenterPoint(), m = i(this.viewportTransform); return r(f, m) }, _centerObject: function (f, m) { return f.setPositionByOrigin(m, "center", "center"), f.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this }, toDatalessJSON: function (f) { return this.toDatalessObject(f) }, toObject: function (f) { return this._toObjectMethod("toObject", f) }, toDatalessObject: function (f) { return this._toObjectMethod("toDatalessObject", f) }, _toObjectMethod: function (f, m) { var y = this.clipPath, C = { version: h.version, objects: this._toObjects(f, m) }; return y && !y.excludeFromExport && (C.clipPath = this._toObject(this.clipPath, f, m)), d(C, this.__serializeBgOverlay(f, m)), h.util.populateWithProperties(this, C, m), C }, _toObjects: function (f, m) { return this._objects.filter(function (y) { return !y.excludeFromExport }).map(function (y) { return this._toObject(y, f, m) }, this) }, _toObject: function (f, m, y) { var C; this.includeDefaultValues || (C = f.includeDefaultValues, f.includeDefaultValues = !1); var x = f[m](y); return this.includeDefaultValues || (f.includeDefaultValues = C), x }, __serializeBgOverlay: function (f, m) { var y = {}, C = this.backgroundImage, x = this.overlayImage, I = this.backgroundColor, D = this.overlayColor; return I && I.toObject ? I.excludeFromExport || (y.background = I.toObject(m)) : I && (y.background = I), D && D.toObject ? D.excludeFromExport || (y.overlay = D.toObject(m)) : D && (y.overlay = D), C && !C.excludeFromExport && (y.backgroundImage = this._toObject(C, f, m)), x && !x.excludeFromExport && (y.overlayImage = this._toObject(x, f, m)), y }, svgViewportTransformation: !0, toSVG: function (f, m) {
      f || (f = {}), f.reviver = m; var y = []; return this._setSVGPreamble(y, f), this._setSVGHeader(y, f), this.clipPath && y.push('<g clip-path="url(#' + this.clipPath.clipPathId + `)" >
`), this._setSVGBgOverlayColor(y, "background"), this._setSVGBgOverlayImage(y, "backgroundImage", m), this._setSVGObjects(y, m), this.clipPath && y.push(`</g>
`), this._setSVGBgOverlayColor(y, "overlay"), this._setSVGBgOverlayImage(y, "overlayImage", m), y.push("</svg>"), y.join("")
    }, _setSVGPreamble: function (f, m) {
      m.suppressPreamble || f.push('<?xml version="1.0" encoding="', m.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`)
    }, _setSVGHeader: function (f, m) {
      var y = m.width || this.width, C = m.height || this.height, x, I = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', D = h.Object.NUM_FRACTION_DIGITS; m.viewBox ? I = 'viewBox="' + m.viewBox.x + " " + m.viewBox.y + " " + m.viewBox.width + " " + m.viewBox.height + '" ' : this.svgViewportTransformation && (x = this.viewportTransform, I = 'viewBox="' + c(-x[4] / x[0], D) + " " + c(-x[5] / x[3], D) + " " + c(this.width / x[0], D) + " " + c(this.height / x[3], D) + '" '), f.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', y, '" ', 'height="', C, '" ', I, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", h.version, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(m), `</defs>
`)
    }, createSVGClipPathMarkup: function (f) {
      var m = this.clipPath; return m ? (m.clipPathId = "CLIPPATH_" + h.Object.__uid++, '<clipPath id="' + m.clipPathId + `" >
`+ this.clipPath.toClipPathSVG(f.reviver) + `</clipPath>
`) : ""
    }, createSVGRefElementsMarkup: function () { var f = this, m = ["background", "overlay"].map(function (y) { var C = f[y + "Color"]; if (C && C.toLive) { var x = f[y + "Vpt"], I = f.viewportTransform, D = { width: f.width / (x ? I[0] : 1), height: f.height / (x ? I[3] : 1) }; return C.toSVG(D, { additionalTransform: x ? h.util.matrixToSVG(I) : "" }) } }); return m.join("") }, createSVGFontFacesMarkup: function () {
      var f = "", m = {}, y, C, x, I, D, P, z, et, tt, st = h.fontPaths, dt = []; for (this._objects.forEach(function ct(W) { dt.push(W), W._objects && W._objects.forEach(ct) }), et = 0, tt = dt.length; et < tt; et++)if (y = dt[et], C = y.fontFamily, !(y.type.indexOf("text") === -1 || m[C] || !st[C]) && (m[C] = !0, !!y.styles)) { x = y.styles; for (D in x) { I = x[D]; for (z in I) P = I[z], C = P.fontFamily, !m[C] && st[C] && (m[C] = !0) } } for (var q in m) f += [`		@font-face {
`, "			font-family: '", q, `';
`, "			src: url('", st[q], `');
`, `		}
`].join(""); return f && (f = ['	<style type="text/css">', `<![CDATA[
`, f, "]]>", `</style>
`].join("")), f
    }, _setSVGObjects: function (f, m) { var y, C, x, I = this._objects; for (C = 0, x = I.length; C < x; C++)y = I[C], !y.excludeFromExport && this._setSVGObject(f, y, m) }, _setSVGObject: function (f, m, y) { f.push(m.toSVG(y)) }, _setSVGBgOverlayImage: function (f, m, y) { this[m] && !this[m].excludeFromExport && this[m].toSVG && f.push(this[m].toSVG(y)) }, _setSVGBgOverlayColor: function (f, m) {
      var y = this[m + "Color"], C = this.viewportTransform, x = this.width, I = this.height; if (y) if (y.toLive) {
        var D = y.repeat, P = h.util.invertTransform(C), z = this[m + "Vpt"], et = z ? h.util.matrixToSVG(P) : ""; f.push('<rect transform="' + et + " translate(", x / 2, ",", I / 2, ')"', ' x="', y.offsetX - x / 2, '" y="', y.offsetY - I / 2, '" ', 'width="', D === "repeat-y" || D === "no-repeat" ? y.source.width : x, '" height="', D === "repeat-x" || D === "no-repeat" ? y.source.height : I, '" fill="url(#SVGID_' + y.id + ')"', `></rect>
`)
      } else f.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', y, '"', `></rect>
`)
    }, sendToBack: function (f) { if (!f) return this; var m = this._activeObject, y, C, x; if (f === m && f.type === "activeSelection") for (x = m._objects, y = x.length; y--;)C = x[y], l(this._objects, C), this._objects.unshift(C); else l(this._objects, f), this._objects.unshift(f); return this.renderOnAddRemove && this.requestRenderAll(), this }, bringToFront: function (f) { if (!f) return this; var m = this._activeObject, y, C, x; if (f === m && f.type === "activeSelection") for (x = m._objects, y = 0; y < x.length; y++)C = x[y], l(this._objects, C), this._objects.push(C); else l(this._objects, f), this._objects.push(f); return this.renderOnAddRemove && this.requestRenderAll(), this }, sendBackwards: function (f, m) { if (!f) return this; var y = this._activeObject, C, x, I, D, P, z = 0; if (f === y && f.type === "activeSelection") for (P = y._objects, C = 0; C < P.length; C++)x = P[C], I = this._objects.indexOf(x), I > 0 + z && (D = I - 1, l(this._objects, x), this._objects.splice(D, 0, x)), z++; else I = this._objects.indexOf(f), I !== 0 && (D = this._findNewLowerIndex(f, I, m), l(this._objects, f), this._objects.splice(D, 0, f)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewLowerIndex: function (f, m, y) { var C, x; if (y) for (C = m, x = m - 1; x >= 0; --x) { var I = f.intersectsWithObject(this._objects[x]) || f.isContainedWithinObject(this._objects[x]) || this._objects[x].isContainedWithinObject(f); if (I) { C = x; break } } else C = m - 1; return C }, bringForward: function (f, m) { if (!f) return this; var y = this._activeObject, C, x, I, D, P, z = 0; if (f === y && f.type === "activeSelection") for (P = y._objects, C = P.length; C--;)x = P[C], I = this._objects.indexOf(x), I < this._objects.length - 1 - z && (D = I + 1, l(this._objects, x), this._objects.splice(D, 0, x)), z++; else I = this._objects.indexOf(f), I !== this._objects.length - 1 && (D = this._findNewUpperIndex(f, I, m), l(this._objects, f), this._objects.splice(D, 0, f)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewUpperIndex: function (f, m, y) { var C, x, I; if (y) for (C = m, x = m + 1, I = this._objects.length; x < I; ++x) { var D = f.intersectsWithObject(this._objects[x]) || f.isContainedWithinObject(this._objects[x]) || this._objects[x].isContainedWithinObject(f); if (D) { C = x; break } } else C = m + 1; return C }, moveTo: function (f, m) { return l(this._objects, f), this._objects.splice(m, 0, f), this.renderOnAddRemove && this.requestRenderAll() }, dispose: function () { return this.isRendering && (h.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function (f) { f.dispose && f.dispose() }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), h.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), h.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>" }
  }), d(h.StaticCanvas.prototype, h.Observable), d(h.StaticCanvas.prototype, h.Collection), d(h.StaticCanvas.prototype, h.DataURLExporter), d(h.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (f) { var m = o(); if (!m || !m.getContext) return null; var y = m.getContext("2d"); if (!y) return null; switch (f) { case "setLineDash": return typeof y.setLineDash < "u"; default: return null } } }), h.StaticCanvas.prototype.toJSON = h.StaticCanvas.prototype.toObject, h.isLikelyNode && (h.StaticCanvas.prototype.createPNGStream = function () { var f = n(this.lowerCanvasEl); return f && f.createPNGStream() }, h.StaticCanvas.prototype.createJPEGStream = function (f) { var m = n(this.lowerCanvasEl); return m && m.createJPEGStream(f) })
}(), h.BaseBrush = h.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeMiterLimit: 10, strokeDashArray: null, limitedToCanvasSize: !1, _setBrushStyles: function (d) { d.strokeStyle = this.color, d.lineWidth = this.width, d.lineCap = this.strokeLineCap, d.miterLimit = this.strokeMiterLimit, d.lineJoin = this.strokeLineJoin, d.setLineDash(this.strokeDashArray || []) }, _saveAndTransform: function (d) { var a = this.canvas.viewportTransform; d.save(), d.transform(a[0], a[1], a[2], a[3], a[4], a[5]) }, _setShadow: function () { if (this.shadow) { var d = this.canvas, a = this.shadow, l = d.contextTop, c = d.getZoom(); d && d._isRetinaScaling() && (c *= h.devicePixelRatio), l.shadowColor = a.color, l.shadowBlur = a.blur * c, l.shadowOffsetX = a.offsetX * c, l.shadowOffsetY = a.offsetY * c } }, needsFullRender: function () { var d = new h.Color(this.color); return d.getAlpha() < 1 || !!this.shadow }, _resetShadow: function () { var d = this.canvas.contextTop; d.shadowColor = "", d.shadowBlur = d.shadowOffsetX = d.shadowOffsetY = 0 }, _isOutSideCanvas: function (d) { return d.x < 0 || d.x > this.canvas.getWidth() || d.y < 0 || d.y > this.canvas.getHeight() } }), function () { h.PencilBrush = h.util.createClass(h.BaseBrush, { decimate: .4, drawStraightLine: !1, straightLineKey: "shiftKey", initialize: function (d) { this.canvas = d, this._points = [] }, needsFullRender: function () { return this.callSuper("needsFullRender") || this._hasStraightLine }, _drawSegment: function (d, a, l) { var c = a.midPointFrom(l); return d.quadraticCurveTo(a.x, a.y, c.x, c.y), c }, onMouseDown: function (d, a) { this.canvas._isMainEvent(a.e) && (this.drawStraightLine = a.e[this.straightLineKey], this._prepareForDrawing(d), this._captureDrawingPath(d), this._render()) }, onMouseMove: function (d, a) { if (this.canvas._isMainEvent(a.e) && (this.drawStraightLine = a.e[this.straightLineKey], !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d)) && this._captureDrawingPath(d) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render(); else { var l = this._points, c = l.length, r = this.canvas.contextTop; this._saveAndTransform(r), this.oldEnd && (r.beginPath(), r.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(r, l[c - 2], l[c - 1], !0), r.stroke(), r.restore() } }, onMouseUp: function (d) { return this.canvas._isMainEvent(d.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0 }, _prepareForDrawing: function (d) { var a = new h.Point(d.x, d.y); this._reset(), this._addPoint(a), this.canvas.contextTop.moveTo(a.x, a.y) }, _addPoint: function (d) { return this._points.length > 1 && d.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(d), !0) }, _reset: function () { this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1 }, _captureDrawingPath: function (d) { var a = new h.Point(d.x, d.y); return this._addPoint(a) }, _render: function (d) { var a, l, c = this._points[0], r = this._points[1]; if (d = d || this.canvas.contextTop, this._saveAndTransform(d), d.beginPath(), this._points.length === 2 && c.x === r.x && c.y === r.y) { var i = this.width / 1e3; c = new h.Point(c.x, c.y), r = new h.Point(r.x, r.y), c.x -= i, r.x += i } for (d.moveTo(c.x, c.y), a = 1, l = this._points.length; a < l; a++)this._drawSegment(d, c, r), c = this._points[a], r = this._points[a + 1]; d.lineTo(c.x, c.y), d.stroke(), d.restore() }, convertPointsToSVGPath: function (d) { var a = this.width / 1e3; return h.util.getSmoothPathFromPoints(d, a) }, _isEmptySVGPath: function (d) { var a = h.util.joinPath(d); return a === "M 0 0 Q 0 0 0 0 L 0 0" }, createPath: function (d) { var a = new h.Path(d, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray }); return this.shadow && (this.shadow.affectStroke = !0, a.shadow = new h.Shadow(this.shadow)), a }, decimatePoints: function (d, a) { if (d.length <= 2) return d; var l = this.canvas.getZoom(), c = Math.pow(a / l, 2), r, i = d.length - 1, n = d[0], o = [n], p; for (r = 1; r < i - 1; r++)p = Math.pow(n.x - d[r].x, 2) + Math.pow(n.y - d[r].y, 2), p >= c && (n = d[r], o.push(n)); return o.push(d[i]), o }, _finalizeAndAddPath: function () { var d = this.canvas.contextTop; d.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate)); var a = this.convertPointsToSVGPath(this._points); if (this._isEmptySVGPath(a)) { this.canvas.requestRenderAll(); return } var l = this.createPath(a); this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: l }), this.canvas.add(l), this.canvas.requestRenderAll(), l.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: l }) } }) }(), h.CircleBrush = h.util.createClass(h.BaseBrush, { width: 10, initialize: function (d) { this.canvas = d, this.points = [] }, drawDot: function (d) { var a = this.addPoint(d), l = this.canvas.contextTop; this._saveAndTransform(l), this.dot(l, a), l.restore() }, dot: function (d, a) { d.fillStyle = a.fill, d.beginPath(), d.arc(a.x, a.y, a.radius, 0, Math.PI * 2, !1), d.closePath(), d.fill() }, onMouseDown: function (d) { this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(d) }, _render: function () { var d = this.canvas.contextTop, a, l, c = this.points; for (this._saveAndTransform(d), a = 0, l = c.length; a < l; a++)this.dot(d, c[a]); d.restore() }, onMouseMove: function (d) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(d), this._render()) : this.drawDot(d)) }, onMouseUp: function () { var d = this.canvas.renderOnAddRemove, a, l; this.canvas.renderOnAddRemove = !1; var c = []; for (a = 0, l = this.points.length; a < l; a++) { var r = this.points[a], i = new h.Circle({ radius: r.radius, left: r.x, top: r.y, originX: "center", originY: "center", fill: r.fill }); this.shadow && (i.shadow = new h.Shadow(this.shadow)), c.push(i) } var n = new h.Group(c); n.canvas = this.canvas, this.canvas.fire("before:path:created", { path: n }), this.canvas.add(n), this.canvas.fire("path:created", { path: n }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = d, this.canvas.requestRenderAll() }, addPoint: function (d) { var a = new h.Point(d.x, d.y), l = h.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, c = new h.Color(this.color).setAlpha(h.util.getRandomInt(0, 100) / 100).toRgba(); return a.radius = l, a.fill = c, this.points.push(a), a } }), h.SprayBrush = h.util.createClass(h.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: !1, optimizeOverlapping: !0, initialize: function (d) { this.canvas = d, this.sprayChunks = [] }, onMouseDown: function (d) { this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(d), this.render(this.sprayChunkPoints) }, onMouseMove: function (d) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d) || (this.addSprayChunk(d), this.render(this.sprayChunkPoints)) }, onMouseUp: function () { var d = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var a = [], l = 0, c = this.sprayChunks.length; l < c; l++)for (var r = this.sprayChunks[l], i = 0, n = r.length; i < n; i++) { var o = new h.Rect({ width: r[i].width, height: r[i].width, left: r[i].x + 1, top: r[i].y + 1, originX: "center", originY: "center", fill: this.color }); a.push(o) } this.optimizeOverlapping && (a = this._getOptimizedRects(a)); var p = new h.Group(a); this.shadow && p.set("shadow", new h.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: p }), this.canvas.add(p), this.canvas.fire("path:created", { path: p }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = d, this.canvas.requestRenderAll() }, _getOptimizedRects: function (d) { var a = {}, l, c, r; for (c = 0, r = d.length; c < r; c++)l = d[c].left + "" + d[c].top, a[l] || (a[l] = d[c]); var i = []; for (l in a) i.push(a[l]); return i }, render: function (d) { var a = this.canvas.contextTop, l, c; for (a.fillStyle = this.color, this._saveAndTransform(a), l = 0, c = d.length; l < c; l++) { var r = d[l]; typeof r.opacity < "u" && (a.globalAlpha = r.opacity), a.fillRect(r.x, r.y, r.width, r.width) } a.restore() }, _render: function () { var d = this.canvas.contextTop, a, l; for (d.fillStyle = this.color, this._saveAndTransform(d), a = 0, l = this.sprayChunks.length; a < l; a++)this.render(this.sprayChunks[a]); d.restore() }, addSprayChunk: function (d) { this.sprayChunkPoints = []; var a, l, c, r = this.width / 2, i; for (i = 0; i < this.density; i++) { a = h.util.getRandomInt(d.x - r, d.x + r), l = h.util.getRandomInt(d.y - r, d.y + r), this.dotWidthVariance ? c = h.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : c = this.dotWidth; var n = new h.Point(a, l); n.width = c, this.randomOpacity && (n.opacity = h.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(n) } this.sprayChunks.push(this.sprayChunkPoints) } }), h.PatternBrush = h.util.createClass(h.PencilBrush, { getPatternSrc: function () { var d = 20, a = 5, l = h.util.createCanvasElement(), c = l.getContext("2d"); return l.width = l.height = d + a, c.fillStyle = this.color, c.beginPath(), c.arc(d / 2, d / 2, d / 2, 0, Math.PI * 2, !1), c.closePath(), c.fill(), l }, getPatternSrcFunction: function () { return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"') }, getPattern: function (d) { return d.createPattern(this.source || this.getPatternSrc(), "repeat") }, _setBrushStyles: function (d) { this.callSuper("_setBrushStyles", d), d.strokeStyle = this.getPattern(d) }, createPath: function (d) { var a = this.callSuper("createPath", d), l = a._getLeftTopCoords().scalarAdd(a.strokeWidth / 2); return a.stroke = new h.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -l.x, offsetY: -l.y }), a } }), function () { var d = h.util.getPointer, a = h.util.degreesToRadians, l = h.util.isTouchEvent; h.Canvas = h.util.createClass(h.StaticCanvas, { initialize: function (r, i) { i || (i = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(r, i), this._initInteractive(), this._createCacheCanvas() }, uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, targets: [], enablePointerEvents: !1, _hoveredTarget: null, _hoveredTargets: [], _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = h.PencilBrush && new h.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var r = this.getActiveObjects(), i, n, o; if (r.length > 0 && !this.preserveObjectStacking) { n = [], o = []; for (var p = 0, f = this._objects.length; p < f; p++)i = this._objects[p], r.indexOf(i) === -1 ? n.push(i) : o.push(i); r.length > 1 && (this._activeObject._objects = o), n.push.apply(n, o) } else n = this._objects; return n }, renderAll: function () { this.contextTopDirty && !this._groupSelector && !this.isDrawingMode && (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1); var r = this.contextContainer; return this.renderCanvas(r, this._chooseObjectsToRender()), this }, renderTopLayer: function (r) { r.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(r), this.contextTopDirty = !0), r.restore() }, renderTop: function () { var r = this.contextTop; return this.clearContext(r), this.renderTopLayer(r), this.fire("after:render"), this }, _normalizePointer: function (r, i) { var n = r.calcTransformMatrix(), o = h.util.invertTransform(n), p = this.restorePointerVpt(i); return h.util.transformPoint(p, o) }, isTargetTransparent: function (r, i, n) { if (r.shouldCache() && r._cacheCanvas && r !== this._activeObject) { var o = this._normalizePointer(r, { x: i, y: n }), p = Math.max(r.cacheTranslationX + o.x * r.zoomX, 0), f = Math.max(r.cacheTranslationY + o.y * r.zoomY, 0), x = h.util.isTransparent(r._cacheContext, Math.round(p), Math.round(f), this.targetFindTolerance); return x } var m = this.contextCache, y = r.selectionBackgroundColor, C = this.viewportTransform; r.selectionBackgroundColor = "", this.clearContext(m), m.save(), m.transform(C[0], C[1], C[2], C[3], C[4], C[5]), r.render(m), m.restore(), r.selectionBackgroundColor = y; var x = h.util.isTransparent(m, i, n, this.targetFindTolerance); return x }, _isSelectionKeyPressed: function (r) { var i = !1; return Array.isArray(this.selectionKey) ? i = !!this.selectionKey.find(function (n) { return r[n] === !0 }) : i = r[this.selectionKey], i }, _shouldClearSelection: function (r, i) { var n = this.getActiveObjects(), o = this._activeObject; return !i || i && o && n.length > 1 && n.indexOf(i) === -1 && o !== i && !this._isSelectionKeyPressed(r) || i && !i.evented || i && !i.selectable && o && o !== i }, _shouldCenterTransform: function (r, i, n) { if (r) { var o; return i === "scale" || i === "scaleX" || i === "scaleY" || i === "resizing" ? o = this.centeredScaling || r.centeredScaling : i === "rotate" && (o = this.centeredRotation || r.centeredRotation), o ? !n : n } }, _getOriginFromCorner: function (r, i) { var n = { x: r.originX, y: r.originY }; return i === "ml" || i === "tl" || i === "bl" ? n.x = "right" : (i === "mr" || i === "tr" || i === "br") && (n.x = "left"), i === "tl" || i === "mt" || i === "tr" ? n.y = "bottom" : (i === "bl" || i === "mb" || i === "br") && (n.y = "top"), n }, _getActionFromCorner: function (r, i, n, o) { if (!i || !r) return "drag"; var p = o.controls[i]; return p.getActionName(n, p, o) }, _setupCurrentTransform: function (r, i, n) { if (i) { var o = this.getPointer(r), p = i.__corner, f = i.controls[p], m = n && p ? f.getActionHandler(r, i, f) : h.controlsUtils.dragHandler, y = this._getActionFromCorner(n, p, r, i), C = this._getOriginFromCorner(i, p), x = r[this.centeredKey], I = { target: i, action: y, actionHandler: m, corner: p, scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, offsetX: o.x - i.left, offsetY: o.y - i.top, originX: C.x, originY: C.y, ex: o.x, ey: o.y, lastX: o.x, lastY: o.y, theta: a(i.angle), width: i.width * i.scaleX, shiftKey: r.shiftKey, altKey: x, original: h.util.saveObjectTransform(i) }; this._shouldCenterTransform(i, y, x) && (I.originX = "center", I.originY = "center"), I.original.originX = C.x, I.original.originY = C.y, this._currentTransform = I, this._beforeTransform(r) } }, setCursor: function (r) { this.upperCanvasEl.style.cursor = r }, _drawSelection: function (r) { var i = this._groupSelector, n = new h.Point(i.ex, i.ey), o = h.util.transformPoint(n, this.viewportTransform), p = new h.Point(i.ex + i.left, i.ey + i.top), f = h.util.transformPoint(p, this.viewportTransform), m = Math.min(o.x, f.x), y = Math.min(o.y, f.y), C = Math.max(o.x, f.x), x = Math.max(o.y, f.y), I = this.selectionLineWidth / 2; this.selectionColor && (r.fillStyle = this.selectionColor, r.fillRect(m, y, C - m, x - y)), !(!this.selectionLineWidth || !this.selectionBorderColor) && (r.lineWidth = this.selectionLineWidth, r.strokeStyle = this.selectionBorderColor, m += I, y += I, C -= I, x -= I, h.Object.prototype._setLineDash.call(this, r, this.selectionDashArray), r.strokeRect(m, y, C - m, x - y)) }, findTarget: function (r, i) { if (!this.skipTargetFind) { var n = !0, o = this.getPointer(r, n), p = this._activeObject, f = this.getActiveObjects(), m, y, C = l(r), x = f.length > 1 && !i || f.length === 1; if (this.targets = [], x && p._findTargetCorner(o, C) || f.length > 1 && !i && p === this._searchPossibleTargets([p], o)) return p; if (f.length === 1 && p === this._searchPossibleTargets([p], o)) if (this.preserveObjectStacking) m = p, y = this.targets, this.targets = []; else return p; var I = this._searchPossibleTargets(this._objects, o); return r[this.altSelectionKey] && I && m && I !== m && (I = m, this.targets = y), I } }, _checkTarget: function (r, i, n) { if (i && i.visible && i.evented && i.containsPoint(r)) if ((this.perPixelTargetFind || i.perPixelTargetFind) && !i.isEditing) { var o = this.isTargetTransparent(i, n.x, n.y); if (!o) return !0 } else return !0 }, _searchPossibleTargets: function (r, i) { for (var n, o = r.length, p; o--;) { var f = r[o], m = f.group ? this._normalizePointer(f.group, i) : i; if (this._checkTarget(m, f, i)) { n = r[o], n.subTargetCheck && n instanceof h.Group && (p = this._searchPossibleTargets(n._objects, i), p && this.targets.push(p)); break } } return n }, restorePointerVpt: function (r) { return h.util.transformPoint(r, h.util.invertTransform(this.viewportTransform)) }, getPointer: function (r, i) { if (this._absolutePointer && !i) return this._absolutePointer; if (this._pointer && i) return this._pointer; var n = d(r), o = this.upperCanvasEl, p = o.getBoundingClientRect(), f = p.width || 0, m = p.height || 0, y; (!f || !m) && ("top" in p && "bottom" in p && (m = Math.abs(p.top - p.bottom)), "right" in p && "left" in p && (f = Math.abs(p.right - p.left))), this.calcOffset(), n.x = n.x - this._offset.left, n.y = n.y - this._offset.top, i || (n = this.restorePointerVpt(n)); var C = this.getRetinaScaling(); return C !== 1 && (n.x /= C, n.y /= C), f === 0 || m === 0 ? y = { width: 1, height: 1 } : y = { width: o.width / f, height: o.height / m }, { x: n.x * y.width, y: n.y * y.height } }, _createUpperCanvas: function () { var r = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), i = this.lowerCanvasEl, n = this.upperCanvasEl; n ? n.className = "" : (n = this._createCanvasElement(), this.upperCanvasEl = n), h.util.addClass(n, "upper-canvas " + r), this.wrapperEl.appendChild(n), this._copyCanvasStyle(i, n), this._applyCanvasStyle(n), this.contextTop = n.getContext("2d") }, getTopContext: function () { return this.contextTop }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = h.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), h.util.setStyle(this.wrapperEl, { width: this.width + "px", height: this.height + "px", position: "relative" }), h.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (r) { var i = this.width || r.width, n = this.height || r.height; h.util.setStyle(r, { position: "absolute", width: i + "px", height: n + "px", left: 0, top: 0, "touch-action": this.allowTouchScrolling ? "manipulation" : "none", "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none" }), r.width = i, r.height = n, h.util.makeElementUnselectable(r) }, _copyCanvasStyle: function (r, i) { i.style.cssText = r.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, getActiveObject: function () { return this._activeObject }, getActiveObjects: function () { var r = this._activeObject; return r ? r.type === "activeSelection" && r._objects ? r._objects.slice(0) : [r] : [] }, _onObjectRemoved: function (r) { r === this._activeObject && (this.fire("before:selection:cleared", { target: r }), this._discardActiveObject(), this.fire("selection:cleared", { target: r }), r.fire("deselected")), r === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", r) }, _fireSelectionEvents: function (r, i) { var n = !1, o = this.getActiveObjects(), p = [], f = []; r.forEach(function (m) { o.indexOf(m) === -1 && (n = !0, m.fire("deselected", { e: i, target: m }), f.push(m)) }), o.forEach(function (m) { r.indexOf(m) === -1 && (n = !0, m.fire("selected", { e: i, target: m }), p.push(m)) }), r.length > 0 && o.length > 0 ? n && this.fire("selection:updated", { e: i, selected: p, deselected: f }) : o.length > 0 ? this.fire("selection:created", { e: i, selected: p }) : r.length > 0 && this.fire("selection:cleared", { e: i, deselected: f }) }, setActiveObject: function (r, i) { var n = this.getActiveObjects(); return this._setActiveObject(r, i), this._fireSelectionEvents(n, i), this }, _setActiveObject: function (r, i) { return this._activeObject === r || !this._discardActiveObject(i, r) || r.onSelect({ e: i }) ? !1 : (this._activeObject = r, !0) }, _discardActiveObject: function (r, i) { var n = this._activeObject; if (n) { if (n.onDeselect({ e: r, object: i })) return !1; this._activeObject = null } return !0 }, discardActiveObject: function (r) { var i = this.getActiveObjects(), n = this.getActiveObject(); return i.length && this.fire("before:selection:cleared", { target: n, e: r }), this._discardActiveObject(r), this._fireSelectionEvents(i, r), this }, dispose: function () { var r = this.wrapperEl; return this.removeListeners(), r.removeChild(this.upperCanvasEl), r.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach(function (i) { h.util.cleanUpJsdomNode(this[i]), this[i] = void 0 }.bind(this)), r.parentNode && r.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, h.StaticCanvas.prototype.dispose.call(this), this }, clear: function () { return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (r) { var i = this._activeObject; i && i._renderControls(r) }, _toObject: function (r, i, n) { var o = this._realizeGroupTransformOnObject(r), p = this.callSuper("_toObject", r, i, n); return this._unwindGroupTransformOnObject(r, o), p }, _realizeGroupTransformOnObject: function (r) { if (r.group && r.group.type === "activeSelection" && this._activeObject === r.group) { var i = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"], n = {}; return i.forEach(function (o) { n[o] = r[o] }), h.util.addTransformToObject(r, this._activeObject.calcOwnMatrix()), n } else return null }, _unwindGroupTransformOnObject: function (r, i) { i && r.set(i) }, _setSVGObject: function (r, i, n) { var o = this._realizeGroupTransformOnObject(i); this.callSuper("_setSVGObject", r, i, n), this._unwindGroupTransformOnObject(i, o) }, setViewportTransform: function (r) { this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), h.StaticCanvas.prototype.setViewportTransform.call(this, r) } }); for (var c in h.StaticCanvas) c !== "prototype" && (h.Canvas[c] = h.StaticCanvas[c]) }(), function () { var d = h.util.addListener, a = h.util.removeListener, l = 3, c = 2, r = 1, i = { passive: !1 }; function n(o, p) { return o.button && o.button === p - 1 } h.util.object.extend(h.Canvas.prototype, { mainTouchId: null, _initEventListeners: function () { this.removeListeners(), this._bindEvents(), this.addOrRemove(d, "add") }, _getEventPrefix: function () { return this.enablePointerEvents ? "pointer" : "mouse" }, addOrRemove: function (o, p) { var f = this.upperCanvasEl, m = this._getEventPrefix(); o(h.window, "resize", this._onResize), o(f, m + "down", this._onMouseDown), o(f, m + "move", this._onMouseMove, i), o(f, m + "out", this._onMouseOut), o(f, m + "enter", this._onMouseEnter), o(f, "wheel", this._onMouseWheel), o(f, "contextmenu", this._onContextMenu), o(f, "dblclick", this._onDoubleClick), o(f, "dragover", this._onDragOver), o(f, "dragenter", this._onDragEnter), o(f, "dragleave", this._onDragLeave), o(f, "drop", this._onDrop), this.enablePointerEvents || o(f, "touchstart", this._onTouchStart, i), typeof eventjs < "u" && p in eventjs && (eventjs[p](f, "gesture", this._onGesture), eventjs[p](f, "drag", this._onDrag), eventjs[p](f, "orientation", this._onOrientationChange), eventjs[p](f, "shake", this._onShake), eventjs[p](f, "longpress", this._onLongPress)) }, removeListeners: function () { this.addOrRemove(a, "remove"); var o = this._getEventPrefix(); a(h.document, o + "up", this._onMouseUp), a(h.document, "touchend", this._onTouchEnd, i), a(h.document, o + "move", this._onMouseMove, i), a(h.document, "touchmove", this._onMouseMove, i) }, _bindEvents: function () { this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0) }, _onGesture: function (o, p) { this.__onTransformGesture && this.__onTransformGesture(o, p) }, _onDrag: function (o, p) { this.__onDrag && this.__onDrag(o, p) }, _onMouseWheel: function (o) { this.__onMouseWheel(o) }, _onMouseOut: function (o) { var p = this._hoveredTarget; this.fire("mouse:out", { target: p, e: o }), this._hoveredTarget = null, p && p.fire("mouseout", { e: o }); var f = this; this._hoveredTargets.forEach(function (m) { f.fire("mouse:out", { target: p, e: o }), m && p.fire("mouseout", { e: o }) }), this._hoveredTargets = [] }, _onMouseEnter: function (o) { !this._currentTransform && !this.findTarget(o) && (this.fire("mouse:over", { target: null, e: o }), this._hoveredTarget = null, this._hoveredTargets = []) }, _onOrientationChange: function (o, p) { this.__onOrientationChange && this.__onOrientationChange(o, p) }, _onShake: function (o, p) { this.__onShake && this.__onShake(o, p) }, _onLongPress: function (o, p) { this.__onLongPress && this.__onLongPress(o, p) }, _onDragOver: function (o) { o.preventDefault(); var p = this._simpleEventHandler("dragover", o); this._fireEnterLeaveEvents(p, o) }, _onDrop: function (o) { return this._simpleEventHandler("drop:before", o), this._simpleEventHandler("drop", o) }, _onContextMenu: function (o) { return this.stopContextMenu && (o.stopPropagation(), o.preventDefault()), !1 }, _onDoubleClick: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "dblclick"), this._resetTransformEventData(o) }, getPointerId: function (o) { var p = o.changedTouches; return p ? p[0] && p[0].identifier : this.enablePointerEvents ? o.pointerId : -1 }, _isMainEvent: function (o) { return o.isPrimary === !0 ? !0 : o.isPrimary === !1 ? !1 : o.type === "touchend" && o.touches.length === 0 ? !0 : o.changedTouches ? o.changedTouches[0].identifier === this.mainTouchId : !0 }, _onTouchStart: function (o) { o.preventDefault(), this.mainTouchId === null && (this.mainTouchId = this.getPointerId(o)), this.__onMouseDown(o), this._resetTransformEventData(); var p = this.upperCanvasEl, f = this._getEventPrefix(); d(h.document, "touchend", this._onTouchEnd, i), d(h.document, "touchmove", this._onMouseMove, i), a(p, f + "down", this._onMouseDown) }, _onMouseDown: function (o) { this.__onMouseDown(o), this._resetTransformEventData(); var p = this.upperCanvasEl, f = this._getEventPrefix(); a(p, f + "move", this._onMouseMove, i), d(h.document, f + "up", this._onMouseUp), d(h.document, f + "move", this._onMouseMove, i) }, _onTouchEnd: function (o) { if (!(o.touches.length > 0)) { this.__onMouseUp(o), this._resetTransformEventData(), this.mainTouchId = null; var p = this._getEventPrefix(); a(h.document, "touchend", this._onTouchEnd, i), a(h.document, "touchmove", this._onMouseMove, i); var f = this; this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function () { d(f.upperCanvasEl, p + "down", f._onMouseDown), f._willAddMouseDown = 0 }, 400) } }, _onMouseUp: function (o) { this.__onMouseUp(o), this._resetTransformEventData(); var p = this.upperCanvasEl, f = this._getEventPrefix(); this._isMainEvent(o) && (a(h.document, f + "up", this._onMouseUp), a(h.document, f + "move", this._onMouseMove, i), d(p, f + "move", this._onMouseMove, i)) }, _onMouseMove: function (o) { !this.allowTouchScrolling && o.preventDefault && o.preventDefault(), this.__onMouseMove(o) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (o) { var p = this._activeObject; return !!p != !!o || p && o && p !== o ? !0 : (p && p.isEditing, !1) }, __onMouseUp: function (o) { var p, f = this._currentTransform, m = this._groupSelector, y = !1, C = !m || m.left === 0 && m.top === 0; if (this._cacheTransformEventData(o), p = this._target, this._handleEvent(o, "up:before"), n(o, l)) { this.fireRightClick && this._handleEvent(o, "up", l, C); return } if (n(o, c)) { this.fireMiddleClick && this._handleEvent(o, "up", c, C), this._resetTransformEventData(); return } if (this.isDrawingMode && this._isCurrentlyDrawing) { this._onMouseUpInDrawingMode(o); return } if (this._isMainEvent(o)) { if (f && (this._finalizeCurrentTransform(o), y = f.actionPerformed), !C) { var x = p === this._activeObject; this._maybeGroupObjects(o), y || (y = this._shouldRender(p) || !x && p === this._activeObject) } var I, D; if (p) { if (I = p._findTargetCorner(this.getPointer(o, !0), h.util.isTouchEvent(o)), p.selectable && p !== this._activeObject && p.activeOn === "up") this.setActiveObject(p, o), y = !0; else { var P = p.controls[I], z = P && P.getMouseUpHandler(o, p, P); z && (D = this.getPointer(o), z(o, f, D.x, D.y)) } p.isMoving = !1 } if (f && (f.target !== p || f.corner !== I)) { var et = f.target && f.target.controls[f.corner], tt = et && et.getMouseUpHandler(o, p, P); D = D || this.getPointer(o), tt && tt(o, f, D.x, D.y) } this._setCursorFromEvent(o, p), this._handleEvent(o, "up", r, C), this._groupSelector = null, this._currentTransform = null, p && (p.__corner = 0), y ? this.requestRenderAll() : C || this.renderTop() } }, _simpleEventHandler: function (o, p) { var f = this.findTarget(p), m = this.targets, y = { e: p, target: f, subTargets: m }; if (this.fire(o, y), f && f.fire(o, y), !m) return f; for (var C = 0; C < m.length; C++)m[C].fire(o, y); return f }, _handleEvent: function (o, p, f, m) { var y = this._target, C = this.targets || [], x = { e: o, target: y, subTargets: C, button: f || r, isClick: m || !1, pointer: this._pointer, absolutePointer: this._absolutePointer, transform: this._currentTransform }; p === "up" && (x.currentTarget = this.findTarget(o), x.currentSubTargets = this.targets), this.fire("mouse:" + p, x), y && y.fire("mouse" + p, x); for (var I = 0; I < C.length; I++)C[I].fire("mouse" + p, x) }, _finalizeCurrentTransform: function (o) { var p = this._currentTransform, f = p.target, m = { e: o, target: f, transform: p, action: p.action }; f._scaling && (f._scaling = !1), f.setCoords(), (p.actionPerformed || this.stateful && f.hasStateChanged()) && this._fire("modified", m) }, _onMouseDownInDrawingMode: function (o) { this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(o).requestRenderAll(); var p = this.getPointer(o); this.freeDrawingBrush.onMouseDown(p, { e: o, pointer: p }), this._handleEvent(o, "down") }, _onMouseMoveInDrawingMode: function (o) { if (this._isCurrentlyDrawing) { var p = this.getPointer(o); this.freeDrawingBrush.onMouseMove(p, { e: o, pointer: p }) } this.setCursor(this.freeDrawingCursor), this._handleEvent(o, "move") }, _onMouseUpInDrawingMode: function (o) { var p = this.getPointer(o); this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: o, pointer: p }), this._handleEvent(o, "up") }, __onMouseDown: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "down:before"); var p = this._target; if (n(o, l)) { this.fireRightClick && this._handleEvent(o, "down", l); return } if (n(o, c)) { this.fireMiddleClick && this._handleEvent(o, "down", c); return } if (this.isDrawingMode) { this._onMouseDownInDrawingMode(o); return } if (this._isMainEvent(o) && !this._currentTransform) { var f = this._pointer; this._previousPointer = f; var m = this._shouldRender(p), y = this._shouldGroup(o, p); if (this._shouldClearSelection(o, p) ? this.discardActiveObject(o) : y && (this._handleGrouping(o, p), p = this._activeObject), this.selection && (!p || !p.selectable && !p.isEditing && p !== this._activeObject) && (this._groupSelector = { ex: this._absolutePointer.x, ey: this._absolutePointer.y, top: 0, left: 0 }), p) { var C = p === this._activeObject; p.selectable && p.activeOn === "down" && this.setActiveObject(p, o); var x = p._findTargetCorner(this.getPointer(o, !0), h.util.isTouchEvent(o)); if (p.__corner = x, p === this._activeObject && (x || !y)) { this._setupCurrentTransform(o, p, C); var I = p.controls[x], f = this.getPointer(o), D = I && I.getMouseDownHandler(o, p, I); D && D(o, this._currentTransform, f.x, f.y) } } this._handleEvent(o, "down"), (m || y) && this.requestRenderAll() } }, _resetTransformEventData: function () { this._target = null, this._pointer = null, this._absolutePointer = null }, _cacheTransformEventData: function (o) { this._resetTransformEventData(), this._pointer = this.getPointer(o, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(o) || null }, _beforeTransform: function (o) { var p = this._currentTransform; this.stateful && p.target.saveState(), this.fire("before:transform", { e: o, transform: p }) }, __onMouseMove: function (o) { this._handleEvent(o, "move:before"), this._cacheTransformEventData(o); var p, f; if (this.isDrawingMode) { this._onMouseMoveInDrawingMode(o); return } if (this._isMainEvent(o)) { var m = this._groupSelector; m ? (f = this._absolutePointer, m.left = f.x - m.ex, m.top = f.y - m.ey, this.renderTop()) : this._currentTransform ? this._transformObject(o) : (p = this.findTarget(o) || null, this._setCursorFromEvent(o, p), this._fireOverOutEvents(p, o)), this._handleEvent(o, "move"), this._resetTransformEventData() } }, _fireOverOutEvents: function (o, p) { var f = this._hoveredTarget, m = this._hoveredTargets, y = this.targets, C = Math.max(m.length, y.length); this.fireSyntheticInOutEvents(o, p, { oldTarget: f, evtOut: "mouseout", canvasEvtOut: "mouse:out", evtIn: "mouseover", canvasEvtIn: "mouse:over" }); for (var x = 0; x < C; x++)this.fireSyntheticInOutEvents(y[x], p, { oldTarget: m[x], evtOut: "mouseout", evtIn: "mouseover" }); this._hoveredTarget = o, this._hoveredTargets = this.targets.concat() }, _fireEnterLeaveEvents: function (o, p) { var f = this._draggedoverTarget, m = this._hoveredTargets, y = this.targets, C = Math.max(m.length, y.length); this.fireSyntheticInOutEvents(o, p, { oldTarget: f, evtOut: "dragleave", evtIn: "dragenter" }); for (var x = 0; x < C; x++)this.fireSyntheticInOutEvents(y[x], p, { oldTarget: m[x], evtOut: "dragleave", evtIn: "dragenter" }); this._draggedoverTarget = o }, fireSyntheticInOutEvents: function (o, p, f) { var m, y, C = f.oldTarget, x, I, D = C !== o, P = f.canvasEvtIn, z = f.canvasEvtOut; D && (m = { e: p, target: o, previousTarget: C }, y = { e: p, target: C, nextTarget: o }), I = o && D, x = C && D, x && (z && this.fire(z, y), C.fire(f.evtOut, y)), I && (P && this.fire(P, m), o.fire(f.evtIn, m)) }, __onMouseWheel: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "wheel"), this._resetTransformEventData() }, _transformObject: function (o) { var p = this.getPointer(o), f = this._currentTransform; f.reset = !1, f.shiftKey = o.shiftKey, f.altKey = o[this.centeredKey], this._performTransformAction(o, f, p), f.actionPerformed && this.requestRenderAll() }, _performTransformAction: function (o, p, f) { var m = f.x, y = f.y, C = p.action, x = !1, I = p.actionHandler; I && (x = I(o, p, m, y)), C === "drag" && x && (p.target.isMoving = !0, this.setCursor(p.target.moveCursor || this.moveCursor)), p.actionPerformed = p.actionPerformed || x }, _fire: h.controlsUtils.fireEvent, _setCursorFromEvent: function (o, p) { if (!p) return this.setCursor(this.defaultCursor), !1; var f = p.hoverCursor || this.hoverCursor, m = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, y = (!m || !m.contains(p)) && p._findTargetCorner(this.getPointer(o, !0)); y ? this.setCursor(this.getCornerCursor(y, p, o)) : (p.subTargetCheck && this.targets.concat().reverse().map(function (C) { f = C.hoverCursor || f }), this.setCursor(f)) }, getCornerCursor: function (o, p, f) { var m = p.controls[o]; return m.cursorStyleHandler(f, m, p) } }) }(), function () { var d = Math.min, a = Math.max; h.util.object.extend(h.Canvas.prototype, { _shouldGroup: function (l, c) { var r = this._activeObject; return r && this._isSelectionKeyPressed(l) && c && c.selectable && this.selection && (r !== c || r.type === "activeSelection") && !c.onSelect({ e: l }) }, _handleGrouping: function (l, c) { var r = this._activeObject; r.__corner || c === r && (c = this.findTarget(l, !0), !c || !c.selectable) || (r && r.type === "activeSelection" ? this._updateActiveSelection(c, l) : this._createActiveSelection(c, l)) }, _updateActiveSelection: function (l, c) { var r = this._activeObject, i = r._objects.slice(0); r.contains(l) ? (r.removeWithUpdate(l), this._hoveredTarget = l, this._hoveredTargets = this.targets.concat(), r.size() === 1 && this._setActiveObject(r.item(0), c)) : (r.addWithUpdate(l), this._hoveredTarget = r, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(i, c) }, _createActiveSelection: function (l, c) { var r = this.getActiveObjects(), i = this._createGroup(l); this._hoveredTarget = i, this._setActiveObject(i, c), this._fireSelectionEvents(r, c) }, _createGroup: function (l) { var c = this._objects, r = c.indexOf(this._activeObject) < c.indexOf(l), i = r ? [this._activeObject, l] : [l, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new h.ActiveSelection(i, { canvas: this }) }, _groupSelectedObjects: function (l) { var c = this._collectObjects(l), r; c.length === 1 ? this.setActiveObject(c[0], l) : c.length > 1 && (r = new h.ActiveSelection(c.reverse(), { canvas: this }), this.setActiveObject(r, l)) }, _collectObjects: function (l) { for (var c = [], r, i = this._groupSelector.ex, n = this._groupSelector.ey, o = i + this._groupSelector.left, p = n + this._groupSelector.top, f = new h.Point(d(i, o), d(n, p)), m = new h.Point(a(i, o), a(n, p)), y = !this.selectionFullyContained, C = i === o && n === p, x = this._objects.length; x-- && (r = this._objects[x], !(!(!r || !r.selectable || !r.visible) && (y && r.intersectsWithRect(f, m, !0) || r.isContainedWithinRect(f, m, !0) || y && r.containsPoint(f, null, !0) || y && r.containsPoint(m, null, !0)) && (c.push(r), C)));); return c.length > 1 && (c = c.filter(function (I) { return !I.onSelect({ e: l }) })), c }, _maybeGroupObjects: function (l) { this.selection && this._groupSelector && this._groupSelectedObjects(l), this.setCursor(this.defaultCursor), this._groupSelector = null } }) }(), function () { h.util.object.extend(h.StaticCanvas.prototype, { toDataURL: function (d) { d || (d = {}); var a = d.format || "png", l = d.quality || 1, c = (d.multiplier || 1) * (d.enableRetinaScaling ? this.getRetinaScaling() : 1), r = this.toCanvasElement(c, d); return h.util.toDataURL(r, a, l) }, toCanvasElement: function (d, a) { d = d || 1, a = a || {}; var l = (a.width || this.width) * d, c = (a.height || this.height) * d, r = this.getZoom(), i = this.width, n = this.height, o = r * d, p = this.viewportTransform, f = (p[4] - (a.left || 0)) * d, m = (p[5] - (a.top || 0)) * d, y = this.interactive, C = [o, 0, 0, o, f, m], x = this.enableRetinaScaling, I = h.util.createCanvasElement(), D = this.contextTop; return I.width = l, I.height = c, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = C, this.width = l, this.height = c, this.calcViewportBoundaries(), this.renderCanvas(I.getContext("2d"), this._objects), this.viewportTransform = p, this.width = i, this.height = n, this.calcViewportBoundaries(), this.interactive = y, this.enableRetinaScaling = x, this.contextTop = D, I } }) }(), h.util.object.extend(h.StaticCanvas.prototype, { loadFromJSON: function (d, a, l) { if (d) { var c = typeof d == "string" ? JSON.parse(d) : h.util.object.clone(d), r = this, i = c.clipPath, n = this.renderOnAddRemove; return this.renderOnAddRemove = !1, delete c.clipPath, this._enlivenObjects(c.objects, function (o) { r.clear(), r._setBgOverlay(c, function () { i ? r._enlivenObjects([i], function (p) { r.clipPath = p[0], r.__setupCanvas.call(r, c, o, n, a) }) : r.__setupCanvas.call(r, c, o, n, a) }) }, l), this } }, __setupCanvas: function (d, a, l, c) { var r = this; a.forEach(function (i, n) { r.insertAt(i, n) }), this.renderOnAddRemove = l, delete d.objects, delete d.backgroundImage, delete d.overlayImage, delete d.background, delete d.overlay, this._setOptions(d), this.renderAll(), c && c() }, _setBgOverlay: function (d, a) { var l = { backgroundColor: !1, overlayColor: !1, backgroundImage: !1, overlayImage: !1 }; if (!d.backgroundImage && !d.overlayImage && !d.background && !d.overlay) { a && a(); return } var c = function () { l.backgroundImage && l.overlayImage && l.backgroundColor && l.overlayColor && a && a() }; this.__setBgOverlay("backgroundImage", d.backgroundImage, l, c), this.__setBgOverlay("overlayImage", d.overlayImage, l, c), this.__setBgOverlay("backgroundColor", d.background, l, c), this.__setBgOverlay("overlayColor", d.overlay, l, c) }, __setBgOverlay: function (d, a, l, c) { var r = this; if (!a) { l[d] = !0, c && c(); return } d === "backgroundImage" || d === "overlayImage" ? h.util.enlivenObjects([a], function (i) { r[d] = i[0], l[d] = !0, c && c() }) : this["set" + h.util.string.capitalize(d, !0)](a, function () { l[d] = !0, c && c() }) }, _enlivenObjects: function (d, a, l) { if (!d || d.length === 0) { a && a([]); return } h.util.enlivenObjects(d, function (c) { a && a(c) }, null, l) }, _toDataURL: function (d, a) { this.clone(function (l) { a(l.toDataURL(d)) }) }, _toDataURLWithMultiplier: function (d, a, l) { this.clone(function (c) { l(c.toDataURLWithMultiplier(d, a)) }) }, clone: function (d, a) { var l = JSON.stringify(this.toJSON(a)); this.cloneWithoutData(function (c) { c.loadFromJSON(l, function () { d && d(c) }) }) }, cloneWithoutData: function (d) { var a = h.util.createCanvasElement(); a.width = this.width, a.height = this.height; var l = new h.Canvas(a); this.backgroundImage ? (l.setBackgroundImage(this.backgroundImage.src, function () { l.renderAll(), d && d(l) }), l.backgroundImageOpacity = this.backgroundImageOpacity, l.backgroundImageStretch = this.backgroundImageStretch) : d && d(l) } }), function (d) { var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.util.object.clone, r = a.util.toFixed, i = a.util.string.capitalize, n = a.util.degreesToRadians, o = !a.isLikelyNode, p = 2; a.Object || (a.Object = a.util.createClass(a.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgb(178,204,255)", borderDashArray: null, cornerColor: "rgb(178,204,255)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, minScaleLimit: 0, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, perPixelTargetFind: !1, includeDefaultValues: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: o, statefullCache: !1, noScaleCache: !0, strokeUniform: !1, dirty: !0, __corner: 0, paintFirst: "fill", activeOn: "down", stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "), colorProperties: "fill stroke backgroundColor".split(" "), clipPath: void 0, inverted: !1, absolutePositioned: !1, initialize: function (f) { f && this.setOptions(f) }, _createCacheCanvas: function () { this._cacheProperties = {}, this._cacheCanvas = a.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0 }, _limitCacheSize: function (f) { var m = a.perfLimitSizeTotal, y = f.width, C = f.height, x = a.maxCacheSideLimit, I = a.minCacheSideLimit; if (y <= x && C <= x && y * C <= m) return y < I && (f.width = I), C < I && (f.height = I), f; var D = y / C, P = a.util.limitDimsByArea(D, m), z = a.util.capValue, et = z(I, P.x, x), tt = z(I, P.y, x); return y > et && (f.zoomX /= y / et, f.width = et, f.capped = !0), C > tt && (f.zoomY /= C / tt, f.height = tt, f.capped = !0), f }, _getCacheCanvasDimensions: function () { var f = this.getTotalObjectScaling(), m = this._getTransformedDimensions(0, 0), y = m.x * f.scaleX / this.scaleX, C = m.y * f.scaleY / this.scaleY; return { width: y + p, height: C + p, zoomX: f.scaleX, zoomY: f.scaleY, x: y, y: C } }, _updateCacheCanvas: function () { var f = this.canvas; if (this.noScaleCache && f && f._currentTransform) { var m = f._currentTransform.target, y = f._currentTransform.action; if (this === m && y.slice && y.slice(0, 5) === "scale") return !1 } var C = this._cacheCanvas, x = this._limitCacheSize(this._getCacheCanvasDimensions()), I = a.minCacheSideLimit, D = x.width, P = x.height, z, et, tt = x.zoomX, st = x.zoomY, dt = D !== this.cacheWidth || P !== this.cacheHeight, q = this.zoomX !== tt || this.zoomY !== st, ct = dt || q, W = 0, Dt = 0, Lt = !1; if (dt) { var it = this._cacheCanvas.width, O = this._cacheCanvas.height, V = D > it || P > O, G = (D < it * .9 || P < O * .9) && it > I && O > I; Lt = V || G, V && !x.capped && (D > I || P > I) && (W = D * .1, Dt = P * .1) } return this instanceof a.Text && this.path && (ct = !0, Lt = !0, W += this.getHeightOfLine(0) * this.zoomX, Dt += this.getHeightOfLine(0) * this.zoomY), ct ? (Lt ? (C.width = Math.ceil(D + W), C.height = Math.ceil(P + Dt)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, C.width, C.height)), z = x.x / 2, et = x.y / 2, this.cacheTranslationX = Math.round(C.width / 2 - z) + z, this.cacheTranslationY = Math.round(C.height / 2 - et) + et, this.cacheWidth = D, this.cacheHeight = P, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(tt, st), this.zoomX = tt, this.zoomY = st, !0) : !1 }, setOptions: function (f) { this._setOptions(f), this._initGradient(f.fill, "fill"), this._initGradient(f.stroke, "stroke"), this._initPattern(f.fill, "fill"), this._initPattern(f.stroke, "stroke") }, transform: function (f) { var m = this.group && !this.group._transformDone || this.group && this.canvas && f === this.canvas.contextTop, y = this.calcTransformMatrix(!m); f.transform(y[0], y[1], y[2], y[3], y[4], y[5]) }, toObject: function (f) { var m = a.Object.NUM_FRACTION_DIGITS, y = { type: this.type, version: a.version, originX: this.originX, originY: this.originY, left: r(this.left, m), top: r(this.top, m), width: r(this.width, m), height: r(this.height, m), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: r(this.strokeWidth, m), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: r(this.strokeMiterLimit, m), scaleX: r(this.scaleX, m), scaleY: r(this.scaleY, m), angle: r(this.angle, m), flipX: this.flipX, flipY: this.flipY, opacity: r(this.opacity, m), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: r(this.skewX, m), skewY: r(this.skewY, m) }; return this.clipPath && !this.clipPath.excludeFromExport && (y.clipPath = this.clipPath.toObject(f), y.clipPath.inverted = this.clipPath.inverted, y.clipPath.absolutePositioned = this.clipPath.absolutePositioned), a.util.populateWithProperties(this, y, f), this.includeDefaultValues || (y = this._removeDefaultValues(y)), y }, toDatalessObject: function (f) { return this.toObject(f) }, _removeDefaultValues: function (f) { var m = a.util.getKlass(f.type).prototype, y = m.stateProperties; return y.forEach(function (C) { C === "left" || C === "top" || (f[C] === m[C] && delete f[C], Array.isArray(f[C]) && Array.isArray(m[C]) && f[C].length === 0 && m[C].length === 0 && delete f[C]) }), f }, toString: function () { return "#<fabric." + i(this.type) + ">" }, getObjectScaling: function () { if (!this.group) return { scaleX: this.scaleX, scaleY: this.scaleY }; var f = a.util.qrDecompose(this.calcTransformMatrix()); return { scaleX: Math.abs(f.scaleX), scaleY: Math.abs(f.scaleY) } }, getTotalObjectScaling: function () { var f = this.getObjectScaling(), m = f.scaleX, y = f.scaleY; if (this.canvas) { var C = this.canvas.getZoom(), x = this.canvas.getRetinaScaling(); m *= C * x, y *= C * x } return { scaleX: m, scaleY: y } }, getObjectOpacity: function () { var f = this.opacity; return this.group && (f *= this.group.getObjectOpacity()), f }, _set: function (f, m) { var y = f === "scaleX" || f === "scaleY", C = this[f] !== m, x = !1; return y && (m = this._constrainScale(m)), f === "scaleX" && m < 0 ? (this.flipX = !this.flipX, m *= -1) : f === "scaleY" && m < 0 ? (this.flipY = !this.flipY, m *= -1) : f === "shadow" && m && !(m instanceof a.Shadow) ? m = new a.Shadow(m) : f === "dirty" && this.group && this.group.set("dirty", m), this[f] = m, C && (x = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(f) > -1 ? (this.dirty = !0, x && this.group.set("dirty", !0)) : x && this.stateProperties.indexOf(f) > -1 && this.group.set("dirty", !0)), this }, setOnGroup: function () { }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : a.iMatrix.concat() }, isNotVisible: function () { return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible }, render: function (f) { this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (f.save(), this._setupCompositeOperation(f), this.drawSelectionBackground(f), this.transform(f), this._setOpacity(f), this._setShadow(f, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(f)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(f), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), f.restore()) }, renderCache: function (f) { f = f || {}, (!this._cacheCanvas || !this._cacheContext) && this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, f.forClipping), this.dirty = !1) }, _removeCacheCanvas: function () { this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0 }, hasStroke: function () { return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0 }, hasFill: function () { return this.fill && this.fill !== "transparent" }, needsItsOwnCache: function () { return !!(this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow == "object" || this.clipPath) }, shouldCache: function () { return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching }, willDrawShadow: function () { return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0) }, drawClipPathOnCache: function (f, m) { if (f.save(), m.inverted ? f.globalCompositeOperation = "destination-out" : f.globalCompositeOperation = "destination-in", m.absolutePositioned) { var y = a.util.invertTransform(this.calcTransformMatrix()); f.transform(y[0], y[1], y[2], y[3], y[4], y[5]) } m.transform(f), f.scale(1 / m.zoomX, 1 / m.zoomY), f.drawImage(m._cacheCanvas, -m.cacheTranslationX, -m.cacheTranslationY), f.restore() }, drawObject: function (f, m) { var y = this.fill, C = this.stroke; m ? (this.fill = "black", this.stroke = "", this._setClippingProperties(f)) : this._renderBackground(f), this._render(f), this._drawClipPath(f, this.clipPath), this.fill = y, this.stroke = C }, _drawClipPath: function (f, m) { m && (m.canvas = this.canvas, m.shouldCache(), m._transformDone = !0, m.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(f, m)) }, drawCacheOnCanvas: function (f) { f.scale(1 / this.zoomX, 1 / this.zoomY), f.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY) }, isCacheDirty: function (f) { if (this.isNotVisible()) return !1; if (this._cacheCanvas && this._cacheContext && !f && this._updateCacheCanvas()) return !0; if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (this._cacheCanvas && this._cacheContext && !f) { var m = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-m / 2, -y / 2, m, y) } return !0 } return !1 }, _renderBackground: function (f) { if (this.backgroundColor) { var m = this._getNonTransformedDimensions(); f.fillStyle = this.backgroundColor, f.fillRect(-m.x / 2, -m.y / 2, m.x, m.y), this._removeShadow(f) } }, _setOpacity: function (f) { this.group && !this.group._transformDone ? f.globalAlpha = this.getObjectOpacity() : f.globalAlpha *= this.opacity }, _setStrokeStyles: function (f, m) { var y = m.stroke; y && (f.lineWidth = m.strokeWidth, f.lineCap = m.strokeLineCap, f.lineDashOffset = m.strokeDashOffset, f.lineJoin = m.strokeLineJoin, f.miterLimit = m.strokeMiterLimit, y.toLive ? y.gradientUnits === "percentage" || y.gradientTransform || y.patternTransform ? this._applyPatternForTransformedGradient(f, y) : (f.strokeStyle = y.toLive(f, this), this._applyPatternGradientTransform(f, y)) : f.strokeStyle = m.stroke) }, _setFillStyles: function (f, m) { var y = m.fill; y && (y.toLive ? (f.fillStyle = y.toLive(f, this), this._applyPatternGradientTransform(f, m.fill)) : f.fillStyle = y) }, _setClippingProperties: function (f) { f.globalAlpha = 1, f.strokeStyle = "transparent", f.fillStyle = "#000000" }, _setLineDash: function (f, m) { !m || m.length === 0 || (1 & m.length && m.push.apply(m, m), f.setLineDash(m)) }, _renderControls: function (f, m) { var y = this.getViewportTransform(), C = this.calcTransformMatrix(), x, I, D; m = m || {}, I = typeof m.hasBorders < "u" ? m.hasBorders : this.hasBorders, D = typeof m.hasControls < "u" ? m.hasControls : this.hasControls, C = a.util.multiplyTransformMatrices(y, C), x = a.util.qrDecompose(C), f.save(), f.translate(x.translateX, x.translateY), f.lineWidth = 1 * this.borderScaleFactor, this.group || (f.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (x.angle -= 180), f.rotate(n(this.group ? x.angle : this.angle)), m.forActiveSelection || this.group ? I && this.drawBordersInGroup(f, x, m) : I && this.drawBorders(f, m), D && this.drawControls(f, m), f.restore() }, _setShadow: function (f) { if (this.shadow) { var m = this.shadow, y = this.canvas, C, x = y && y.viewportTransform[0] || 1, I = y && y.viewportTransform[3] || 1; m.nonScaling ? C = { scaleX: 1, scaleY: 1 } : C = this.getObjectScaling(), y && y._isRetinaScaling() && (x *= a.devicePixelRatio, I *= a.devicePixelRatio), f.shadowColor = m.color, f.shadowBlur = m.blur * a.browserShadowBlurConstant * (x + I) * (C.scaleX + C.scaleY) / 4, f.shadowOffsetX = m.offsetX * x * C.scaleX, f.shadowOffsetY = m.offsetY * I * C.scaleY } }, _removeShadow: function (f) { this.shadow && (f.shadowColor = "", f.shadowBlur = f.shadowOffsetX = f.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (f, m) { if (!m || !m.toLive) return { offsetX: 0, offsetY: 0 }; var y = m.gradientTransform || m.patternTransform, C = -this.width / 2 + m.offsetX || 0, x = -this.height / 2 + m.offsetY || 0; return m.gradientUnits === "percentage" ? f.transform(this.width, 0, 0, this.height, C, x) : f.transform(1, 0, 0, 1, C, x), y && f.transform(y[0], y[1], y[2], y[3], y[4], y[5]), { offsetX: C, offsetY: x } }, _renderPaintInOrder: function (f) { this.paintFirst === "stroke" ? (this._renderStroke(f), this._renderFill(f)) : (this._renderFill(f), this._renderStroke(f)) }, _render: function () { }, _renderFill: function (f) { this.fill && (f.save(), this._setFillStyles(f, this), this.fillRule === "evenodd" ? f.fill("evenodd") : f.fill(), f.restore()) }, _renderStroke: function (f) { if (!(!this.stroke || this.strokeWidth === 0)) { if (this.shadow && !this.shadow.affectStroke && this._removeShadow(f), f.save(), this.strokeUniform && this.group) { var m = this.getObjectScaling(); f.scale(1 / m.scaleX, 1 / m.scaleY) } else this.strokeUniform && f.scale(1 / this.scaleX, 1 / this.scaleY); this._setLineDash(f, this.strokeDashArray), this._setStrokeStyles(f, this), f.stroke(), f.restore() } }, _applyPatternForTransformedGradient: function (f, m) { var y = this._limitCacheSize(this._getCacheCanvasDimensions()), C = a.util.createCanvasElement(), x, I = this.canvas.getRetinaScaling(), D = y.x / this.scaleX / I, P = y.y / this.scaleY / I; C.width = D, C.height = P, x = C.getContext("2d"), x.beginPath(), x.moveTo(0, 0), x.lineTo(D, 0), x.lineTo(D, P), x.lineTo(0, P), x.closePath(), x.translate(D / 2, P / 2), x.scale(y.zoomX / this.scaleX / I, y.zoomY / this.scaleY / I), this._applyPatternGradientTransform(x, m), x.fillStyle = m.toLive(f), x.fill(), f.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), f.scale(I * this.scaleX / y.zoomX, I * this.scaleY / y.zoomY), f.strokeStyle = x.createPattern(C, "no-repeat") }, _findCenterFromElement: function () { return { x: this.left + this.width / 2, y: this.top + this.height / 2 } }, _assignTransformMatrixProps: function () { if (this.transformMatrix) { var f = a.util.qrDecompose(this.transformMatrix); this.flipX = !1, this.flipY = !1, this.set("scaleX", f.scaleX), this.set("scaleY", f.scaleY), this.angle = f.angle, this.skewX = f.skewX, this.skewY = 0 } }, _removeTransformMatrix: function (f) { var m = this._findCenterFromElement(); this.transformMatrix && (this._assignTransformMatrixProps(), m = a.util.transformPoint(m, this.transformMatrix)), this.transformMatrix = null, f && (this.scaleX *= f.scaleX, this.scaleY *= f.scaleY, this.cropX = f.cropX, this.cropY = f.cropY, m.x += f.offsetLeft, m.y += f.offsetTop, this.width = f.width, this.height = f.height), this.setPositionByOrigin(m, "center", "center") }, clone: function (f, m) { var y = this.toObject(m); this.constructor.fromObject ? this.constructor.fromObject(y, f) : a.Object._fromObject("Object", y, f) }, cloneAsImage: function (f, m) { var y = this.toCanvasElement(m); return f && f(new a.Image(y)), this }, toCanvasElement: function (f) { f || (f = {}); var m = a.util, y = m.saveObjectTransform(this), C = this.group, x = this.shadow, I = Math.abs, D = (f.multiplier || 1) * (f.enableRetinaScaling ? a.devicePixelRatio : 1); delete this.group, f.withoutTransform && m.resetObjectTransform(this), f.withoutShadow && (this.shadow = null); var P = a.util.createCanvasElement(), z = this.getBoundingRect(!0, !0), et = this.shadow, tt, st = { x: 0, y: 0 }, dt, q, ct; et && (dt = et.blur, et.nonScaling ? tt = { scaleX: 1, scaleY: 1 } : tt = this.getObjectScaling(), st.x = 2 * Math.round(I(et.offsetX) + dt) * I(tt.scaleX), st.y = 2 * Math.round(I(et.offsetY) + dt) * I(tt.scaleY)), q = z.width + st.x, ct = z.height + st.y, P.width = Math.ceil(q), P.height = Math.ceil(ct); var W = new a.StaticCanvas(P, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }); f.format === "jpeg" && (W.backgroundColor = "#fff"), this.setPositionByOrigin(new a.Point(W.width / 2, W.height / 2), "center", "center"); var Dt = this.canvas; W.add(this); var Lt = W.toCanvasElement(D || 1, f); return this.shadow = x, this.set("canvas", Dt), C && (this.group = C), this.set(y).setCoords(), W._objects = [], W.dispose(), W = null, Lt }, toDataURL: function (f) { return f || (f = {}), a.util.toDataURL(this.toCanvasElement(f), f.format || "png", f.quality || 1) }, isType: function (f) { return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === f }, complexity: function () { return 1 }, toJSON: function (f) { return this.toObject(f) }, rotate: function (f) { var m = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation; return m && this._setOriginToCenter(), this.set("angle", f), m && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, getLocalPointer: function (f, m) { m = m || this.canvas.getPointer(f); var y = new a.Point(m.x, m.y), C = this._getLeftTopCoords(); return this.angle && (y = a.util.rotatePoint(y, C, n(-this.angle))), { x: y.x - C.x, y: y.y - C.y } }, _setupCompositeOperation: function (f) { this.globalCompositeOperation && (f.globalCompositeOperation = this.globalCompositeOperation) }, dispose: function () { a.runningAnimations && a.runningAnimations.cancelByTarget(this) } }), a.util.createAccessors && a.util.createAccessors(a.Object), l(a.Object.prototype, a.Observable), a.Object.NUM_FRACTION_DIGITS = 2, a.Object.ENLIVEN_PROPS = ["clipPath"], a.Object._fromObject = function (f, m, y, C) { var x = a[f]; m = c(m, !0), a.util.enlivenPatterns([m.fill, m.stroke], function (I) { typeof I[0] < "u" && (m.fill = I[0]), typeof I[1] < "u" && (m.stroke = I[1]), a.util.enlivenObjectEnlivables(m, m, function () { var D = C ? new x(m[C], m) : new x(m); y && y(D) }) }) }, a.Object.__uid = 0) }(v), function () { var d = h.util.degreesToRadians, a = { left: -.5, center: 0, right: .5 }, l = { top: -.5, center: 0, bottom: .5 }; h.util.object.extend(h.Object.prototype, { translateToGivenOrigin: function (c, r, i, n, o) { var p = c.x, f = c.y, m, y, C; return typeof r == "string" ? r = a[r] : r -= .5, typeof n == "string" ? n = a[n] : n -= .5, m = n - r, typeof i == "string" ? i = l[i] : i -= .5, typeof o == "string" ? o = l[o] : o -= .5, y = o - i, (m || y) && (C = this._getTransformedDimensions(), p = c.x + m * C.x, f = c.y + y * C.y), new h.Point(p, f) }, translateToCenterPoint: function (c, r, i) { var n = this.translateToGivenOrigin(c, r, i, "center", "center"); return this.angle ? h.util.rotatePoint(n, c, d(this.angle)) : n }, translateToOriginPoint: function (c, r, i) { var n = this.translateToGivenOrigin(c, "center", "center", r, i); return this.angle ? h.util.rotatePoint(n, c, d(this.angle)) : n }, getCenterPoint: function () { var c = new h.Point(this.left, this.top); return this.translateToCenterPoint(c, this.originX, this.originY) }, getPointByOrigin: function (c, r) { var i = this.getCenterPoint(); return this.translateToOriginPoint(i, c, r) }, toLocalPoint: function (c, r, i) { var n = this.getCenterPoint(), o, p; return typeof r < "u" && typeof i < "u" ? o = this.translateToGivenOrigin(n, "center", "center", r, i) : o = new h.Point(this.left, this.top), p = new h.Point(c.x, c.y), this.angle && (p = h.util.rotatePoint(p, n, -d(this.angle))), p.subtractEquals(o) }, setPositionByOrigin: function (c, r, i) { var n = this.translateToCenterPoint(c, r, i), o = this.translateToOriginPoint(n, this.originX, this.originY); this.set("left", o.x), this.set("top", o.y) }, adjustPosition: function (c) { var r = d(this.angle), i = this.getScaledWidth(), n = h.util.cos(r) * i, o = h.util.sin(r) * i, p, f; typeof this.originX == "string" ? p = a[this.originX] : p = this.originX - .5, typeof c == "string" ? f = a[c] : f = c - .5, this.left += n * (f - p), this.top += o * (f - p), this.setCoords(), this.originX = c }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var c = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = c.x, this.top = c.y }, _resetOrigin: function () { var c = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = c.x, this.top = c.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") } }) }(), function () { function d(i) { return [new h.Point(i.tl.x, i.tl.y), new h.Point(i.tr.x, i.tr.y), new h.Point(i.br.x, i.br.y), new h.Point(i.bl.x, i.bl.y)] } var a = h.util, l = a.degreesToRadians, c = a.multiplyTransformMatrices, r = a.transformPoint; a.object.extend(h.Object.prototype, { oCoords: null, aCoords: null, lineCoords: null, ownMatrixCache: null, matrixCache: null, controls: {}, _getCoords: function (i, n) { return n ? i ? this.calcACoords() : this.calcLineCoords() : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0), i ? this.aCoords : this.lineCoords) }, getCoords: function (i, n) { return d(this._getCoords(i, n)) }, intersectsWithRect: function (i, n, o, p) { var f = this.getCoords(o, p), m = h.Intersection.intersectPolygonRectangle(f, i, n); return m.status === "Intersection" }, intersectsWithObject: function (i, n, o) { var p = h.Intersection.intersectPolygonPolygon(this.getCoords(n, o), i.getCoords(n, o)); return p.status === "Intersection" || i.isContainedWithinObject(this, n, o) || this.isContainedWithinObject(i, n, o) }, isContainedWithinObject: function (i, n, o) { for (var p = this.getCoords(n, o), f = n ? i.aCoords : i.lineCoords, m = 0, y = i._getImageLines(f); m < 4; m++)if (!i.containsPoint(p[m], y)) return !1; return !0 }, isContainedWithinRect: function (i, n, o, p) { var f = this.getBoundingRect(o, p); return f.left >= i.x && f.left + f.width <= n.x && f.top >= i.y && f.top + f.height <= n.y }, containsPoint: function (i, m, o, p) { var f = this._getCoords(o, p), m = m || this._getImageLines(f), y = this._findCrossPoints(i, m); return y !== 0 && y % 2 === 1 }, isOnScreen: function (i) { if (!this.canvas) return !1; var n = this.canvas.vptCoords.tl, o = this.canvas.vptCoords.br, p = this.getCoords(!0, i); return p.some(function (f) { return f.x <= o.x && f.x >= n.x && f.y <= o.y && f.y >= n.y }) || this.intersectsWithRect(n, o, !0, i) ? !0 : this._containsCenterOfCanvas(n, o, i) }, _containsCenterOfCanvas: function (i, n, o) { var p = { x: (i.x + n.x) / 2, y: (i.y + n.y) / 2 }; return !!this.containsPoint(p, null, !0, o) }, isPartiallyOnScreen: function (i) { if (!this.canvas) return !1; var n = this.canvas.vptCoords.tl, o = this.canvas.vptCoords.br; if (this.intersectsWithRect(n, o, !0, i)) return !0; var p = this.getCoords(!0, i).every(function (f) { return (f.x >= o.x || f.x <= n.x) && (f.y >= o.y || f.y <= n.y) }); return p && this._containsCenterOfCanvas(n, o, i) }, _getImageLines: function (i) { var n = { topline: { o: i.tl, d: i.tr }, rightline: { o: i.tr, d: i.br }, bottomline: { o: i.br, d: i.bl }, leftline: { o: i.bl, d: i.tl } }; return n }, _findCrossPoints: function (i, n) { var o, p, f, m, y, C = 0, x; for (var I in n) if (x = n[I], !(x.o.y < i.y && x.d.y < i.y) && !(x.o.y >= i.y && x.d.y >= i.y) && (x.o.x === x.d.x && x.o.x >= i.x ? y = x.o.x : (o = 0, p = (x.d.y - x.o.y) / (x.d.x - x.o.x), f = i.y - o * i.x, m = x.o.y - p * x.o.x, y = -(f - m) / (o - p)), y >= i.x && (C += 1), C === 2)) break; return C }, getBoundingRect: function (i, n) { var o = this.getCoords(i, n); return a.makeBoundingBoxFromPoints(o) }, getScaledWidth: function () { return this._getTransformedDimensions().x }, getScaledHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (i) { return Math.abs(i) < this.minScaleLimit ? i < 0 ? -this.minScaleLimit : this.minScaleLimit : i === 0 ? 1e-4 : i }, scale: function (i) { return this._set("scaleX", i), this._set("scaleY", i), this.setCoords() }, scaleToWidth: function (i, n) { var o = this.getBoundingRect(n).width / this.getScaledWidth(); return this.scale(i / this.width / o) }, scaleToHeight: function (i, n) { var o = this.getBoundingRect(n).height / this.getScaledHeight(); return this.scale(i / this.height / o) }, calcLineCoords: function () { var i = this.getViewportTransform(), n = this.padding, o = l(this.angle), p = a.cos(o), f = a.sin(o), m = p * n, y = f * n, C = m + y, x = m - y, I = this.calcACoords(), D = { tl: r(I.tl, i), tr: r(I.tr, i), bl: r(I.bl, i), br: r(I.br, i) }; return n && (D.tl.x -= x, D.tl.y -= C, D.tr.x += C, D.tr.y -= x, D.bl.x -= C, D.bl.y += x, D.br.x += x, D.br.y += C), D }, calcOCoords: function () { var i = this._calcRotateMatrix(), n = this._calcTranslateMatrix(), o = this.getViewportTransform(), p = c(o, n), f = c(p, i), f = c(f, [1 / o[0], 0, 0, 1 / o[3], 0, 0]), m = this._calculateCurrentDimensions(), y = {}; return this.forEachControl(function (C, x, I) { y[x] = C.positionHandler(m, f, I) }), y }, calcACoords: function () { var i = this._calcRotateMatrix(), n = this._calcTranslateMatrix(), o = c(n, i), p = this._getTransformedDimensions(), f = p.x / 2, m = p.y / 2; return { tl: r({ x: -f, y: -m }, o), tr: r({ x: f, y: -m }, o), bl: r({ x: -f, y: m }, o), br: r({ x: f, y: m }, o) } }, setCoords: function (i) { return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), i ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this) }, _calcRotateMatrix: function () { return a.calcRotateMatrix(this) }, _calcTranslateMatrix: function () { var i = this.getCenterPoint(); return [1, 0, 0, 1, i.x, i.y] }, transformMatrixKey: function (i) { var n = "_", o = ""; return !i && this.group && (o = this.group.transformMatrixKey(i) + n), o + this.top + n + this.left + n + this.scaleX + n + this.scaleY + n + this.skewX + n + this.skewY + n + this.angle + n + this.originX + n + this.originY + n + this.width + n + this.height + n + this.strokeWidth + this.flipX + this.flipY }, calcTransformMatrix: function (i) { var n = this.calcOwnMatrix(); if (i || !this.group) return n; var o = this.transformMatrixKey(i), p = this.matrixCache || (this.matrixCache = {}); return p.key === o ? p.value : (this.group && (n = c(this.group.calcTransformMatrix(!1), n)), p.key = o, p.value = n, n) }, calcOwnMatrix: function () { var i = this.transformMatrixKey(!0), n = this.ownMatrixCache || (this.ownMatrixCache = {}); if (n.key === i) return n.value; var o = this._calcTranslateMatrix(), p = { angle: this.angle, translateX: o[4], translateY: o[5], scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }; return n.key = i, n.value = a.composeMatrix(p), n.value }, _getNonTransformedDimensions: function () { var i = this.strokeWidth, n = this.width + i, o = this.height + i; return { x: n, y: o } }, _getTransformedDimensions: function (i, n) { typeof i > "u" && (i = this.skewX), typeof n > "u" && (n = this.skewY); var o, p, f, m = i === 0 && n === 0; if (this.strokeUniform ? (p = this.width, f = this.height) : (o = this._getNonTransformedDimensions(), p = o.x, f = o.y), m) return this._finalizeDimensions(p * this.scaleX, f * this.scaleY); var y = a.sizeAfterTransform(p, f, { scaleX: this.scaleX, scaleY: this.scaleY, skewX: i, skewY: n }); return this._finalizeDimensions(y.x, y.y) }, _finalizeDimensions: function (i, n) { return this.strokeUniform ? { x: i + this.strokeWidth, y: n + this.strokeWidth } : { x: i, y: n } }, _calculateCurrentDimensions: function () { var i = this.getViewportTransform(), n = this._getTransformedDimensions(), o = r(n, i, !0); return o.scalarAdd(2 * this.padding) } }) }(), h.util.object.extend(h.Object.prototype, { sendToBack: function () { return this.group ? h.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? h.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this }, sendBackwards: function (d) { return this.group ? h.StaticCanvas.prototype.sendBackwards.call(this.group, this, d) : this.canvas && this.canvas.sendBackwards(this, d), this }, bringForward: function (d) { return this.group ? h.StaticCanvas.prototype.bringForward.call(this.group, this, d) : this.canvas && this.canvas.bringForward(this, d), this }, moveTo: function (d) { return this.group && this.group.type !== "activeSelection" ? h.StaticCanvas.prototype.moveTo.call(this.group, this, d) : this.canvas && this.canvas.moveTo(this, d), this } }), function () {
  function d(l, c) { if (c) { if (c.toLive) return l + ": url(#SVGID_" + c.id + "); "; var r = new h.Color(c), i = l + ": " + r.toRgb() + "; ", n = r.getAlpha(); return n !== 1 && (i += l + "-opacity: " + n.toString() + "; "), i } else return l + ": none; " } var a = h.util.toFixed; h.util.object.extend(h.Object.prototype, {
    getSvgStyles: function (l) { var c = this.fillRule ? this.fillRule : "nonzero", r = this.strokeWidth ? this.strokeWidth : "0", i = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", n = this.strokeDashOffset ? this.strokeDashOffset : "0", o = this.strokeLineCap ? this.strokeLineCap : "butt", p = this.strokeLineJoin ? this.strokeLineJoin : "miter", f = this.strokeMiterLimit ? this.strokeMiterLimit : "4", m = typeof this.opacity < "u" ? this.opacity : "1", y = this.visible ? "" : " visibility: hidden;", C = l ? "" : this.getSvgFilter(), x = d("fill", this.fill), I = d("stroke", this.stroke); return [I, "stroke-width: ", r, "; ", "stroke-dasharray: ", i, "; ", "stroke-linecap: ", o, "; ", "stroke-dashoffset: ", n, "; ", "stroke-linejoin: ", p, "; ", "stroke-miterlimit: ", f, "; ", x, "fill-rule: ", c, "; ", "opacity: ", m, ";", C, y].join("") }, getSvgSpanStyles: function (l, c) { var r = "; ", n = l.fontFamily ? "font-family: " + (l.fontFamily.indexOf("'") === -1 && l.fontFamily.indexOf('"') === -1 ? "'" + l.fontFamily + "'" : l.fontFamily) + r : "", i = l.strokeWidth ? "stroke-width: " + l.strokeWidth + r : "", n = n, o = l.fontSize ? "font-size: " + l.fontSize + "px" + r : "", p = l.fontStyle ? "font-style: " + l.fontStyle + r : "", f = l.fontWeight ? "font-weight: " + l.fontWeight + r : "", m = l.fill ? d("fill", l.fill) : "", y = l.stroke ? d("stroke", l.stroke) : "", C = this.getSvgTextDecoration(l), x = l.deltaY ? "baseline-shift: " + -l.deltaY + "; " : ""; return C && (C = "text-decoration: " + C + r), [y, i, n, o, p, f, C, m, x, c ? "white-space: pre; " : ""].join("") }, getSvgTextDecoration: function (l) { return ["overline", "underline", "line-through"].filter(function (c) { return l[c.replace("-", "")] }).join(" ") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgCommons: function () { return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("") }, getSvgTransform: function (l, c) { var r = l ? this.calcTransformMatrix() : this.calcOwnMatrix(), i = 'transform="' + h.util.matrixToSVG(r); return i + (c || "") + '" ' }, _setSVGBg: function (l) {
      if (this.backgroundColor) {
        var c = h.Object.NUM_FRACTION_DIGITS; l.push("		<rect ", this._getFillAttributes(this.backgroundColor), ' x="', a(-this.width / 2, c), '" y="', a(-this.height / 2, c), '" width="', a(this.width, c), '" height="', a(this.height, c), `"></rect>
`)
      }
    }, toSVG: function (l) { return this._createBaseSVGMarkup(this._toSVG(l), { reviver: l }) }, toClipPathSVG: function (l) { return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(l), { reviver: l }) }, _createBaseClipPathSVGMarkup: function (l, c) { c = c || {}; var r = c.reviver, i = c.additionalTransform || "", n = [this.getSvgTransform(!0, i), this.getSvgCommons()].join(""), o = l.indexOf("COMMON_PARTS"); return l[o] = n, r ? r(l.join("")) : l.join("") }, _createBaseSVGMarkup: function (l, c) {
      c = c || {}; var r = c.noStyle, i = c.reviver, n = r ? "" : 'style="' + this.getSvgStyles() + '" ', o = c.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", p = this.clipPath, f = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", m = p && p.absolutePositioned, y = this.stroke, C = this.fill, x = this.shadow, I, D = [], P, z = l.indexOf("COMMON_PARTS"), et = c.additionalTransform; return p && (p.clipPathId = "CLIPPATH_" + h.Object.__uid++, P = '<clipPath id="' + p.clipPathId + `" >
`+ p.toClipPathSVG(i) + `</clipPath>
`), m && D.push("<g ", o, this.getSvgCommons(), ` >
`), D.push("<g ", this.getSvgTransform(!1), m ? "" : o + this.getSvgCommons(), ` >
`), I = [n, f, r ? "" : this.addPaintOrder(), " ", et ? 'transform="' + et + '" ' : ""].join(""), l[z] = I, C && C.toLive && D.push(C.toSVG(this)), y && y.toLive && D.push(y.toSVG(this)), x && D.push(x.toSVG(this)), p && D.push(P), D.push(l.join("")), D.push(`</g>
`), m && D.push(`</g>
`), i ? i(D.join("")) : D.join("")
    }, addPaintOrder: function () { return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "" }
  })
}(), function () { var d = h.util.object.extend, a = "stateProperties"; function l(r, i, n) { var o = {}, p = !0; n.forEach(function (f) { o[f] = r[f] }), d(r[i], o, p) } function c(r, i, n) { if (r === i) return !0; if (Array.isArray(r)) { if (!Array.isArray(i) || r.length !== i.length) return !1; for (var o = 0, p = r.length; o < p; o++)if (!c(r[o], i[o])) return !1; return !0 } else if (r && typeof r == "object") { var f = Object.keys(r), m; if (!i || typeof i != "object" || !n && f.length !== Object.keys(i).length) return !1; for (var o = 0, p = f.length; o < p; o++)if (m = f[o], !(m === "canvas" || m === "group") && !c(r[m], i[m])) return !1; return !0 } } h.util.object.extend(h.Object.prototype, { hasStateChanged: function (r) { r = r || a; var i = "_" + r; return Object.keys(this[i]).length < this[r].length ? !0 : !c(this[i], this, !0) }, saveState: function (r) { var i = r && r.propertySet || a, n = "_" + i; return this[n] ? (l(this, n, this[i]), r && r.stateProperties && l(this, n, r.stateProperties), this) : this.setupState(r) }, setupState: function (r) { r = r || {}; var i = r.propertySet || a; return r.propertySet = i, this["_" + i] = {}, this.saveState(r), this } }) }(), function () { var d = h.util.degreesToRadians; h.util.object.extend(h.Object.prototype, { _findTargetCorner: function (a, l) { if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1; var c = a.x, r = a.y, i, n, o = Object.keys(this.oCoords), p = o.length - 1, f; for (this.__corner = 0; p >= 0; p--)if (f = o[p], !!this.isControlVisible(f) && (n = this._getImageLines(l ? this.oCoords[f].touchCorner : this.oCoords[f].corner), i = this._findCrossPoints({ x: c, y: r }, n), i !== 0 && i % 2 === 1)) return this.__corner = f, f; return !1 }, forEachControl: function (a) { for (var l in this.controls) a(this.controls[l], l, this) }, _setCornerCoords: function () { var a = this.oCoords; for (var l in a) { var c = this.controls[l]; a[l].corner = c.calcCornerCoords(this.angle, this.cornerSize, a[l].x, a[l].y, !1), a[l].touchCorner = c.calcCornerCoords(this.angle, this.touchCornerSize, a[l].x, a[l].y, !0) } }, drawSelectionBackground: function (a) { if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this; a.save(); var l = this.getCenterPoint(), c = this._calculateCurrentDimensions(), r = this.canvas.viewportTransform; return a.translate(l.x, l.y), a.scale(1 / r[0], 1 / r[3]), a.rotate(d(this.angle)), a.fillStyle = this.selectionBackgroundColor, a.fillRect(-c.x / 2, -c.y / 2, c.x, c.y), a.restore(), this }, drawBorders: function (a, l) { l = l || {}; var c = this._calculateCurrentDimensions(), r = this.borderScaleFactor, i = c.x + r, n = c.y + r, o = typeof l.hasControls < "u" ? l.hasControls : this.hasControls, p = !1; return a.save(), a.strokeStyle = l.borderColor || this.borderColor, this._setLineDash(a, l.borderDashArray || this.borderDashArray), a.strokeRect(-i / 2, -n / 2, i, n), o && (a.beginPath(), this.forEachControl(function (f, m, y) { f.withConnection && f.getVisibility(y, m) && (p = !0, a.moveTo(f.x * i, f.y * n), a.lineTo(f.x * i + f.offsetX, f.y * n + f.offsetY)) }), p && a.stroke()), a.restore(), this }, drawBordersInGroup: function (a, l, c) { c = c || {}; var r = h.util.sizeAfterTransform(this.width, this.height, l), i = this.strokeWidth, n = this.strokeUniform, o = this.borderScaleFactor, p = r.x + i * (n ? this.canvas.getZoom() : l.scaleX) + o, f = r.y + i * (n ? this.canvas.getZoom() : l.scaleY) + o; return a.save(), this._setLineDash(a, c.borderDashArray || this.borderDashArray), a.strokeStyle = c.borderColor || this.borderColor, a.strokeRect(-p / 2, -f / 2, p, f), a.restore(), this }, drawControls: function (a, l) { l = l || {}, a.save(); var c = this.canvas.getRetinaScaling(), r, i; return a.setTransform(c, 0, 0, c, 0, 0), a.strokeStyle = a.fillStyle = l.cornerColor || this.cornerColor, this.transparentCorners || (a.strokeStyle = l.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(a, l.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (r = this.group.calcTransformMatrix()), this.forEachControl(function (n, o, p) { i = p.oCoords[o], n.getVisibility(p, o) && (r && (i = h.util.transformPoint(i, r)), n.render(a, i.x, i.y, l, p)) }), a.restore(), this }, isControlVisible: function (a) { return this.controls[a] && this.controls[a].getVisibility(this, a) }, setControlVisible: function (a, l) { return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[a] = l, this }, setControlsVisibility: function (a) { a || (a = {}); for (var l in a) this.setControlVisible(l, a[l]); return this }, onDeselect: function () { }, onSelect: function () { } }) }(), h.util.object.extend(h.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function (d, a) { a = a || {}; var l = function () { }, c = a.onComplete || l, r = a.onChange || l, i = this; return h.util.animate({ target: this, startValue: d.left, endValue: this.getCenterPoint().x, duration: this.FX_DURATION, onChange: function (n) { d.set("left", n), i.requestRenderAll(), r() }, onComplete: function () { d.setCoords(), c() } }) }, fxCenterObjectV: function (d, a) { a = a || {}; var l = function () { }, c = a.onComplete || l, r = a.onChange || l, i = this; return h.util.animate({ target: this, startValue: d.top, endValue: this.getCenterPoint().y, duration: this.FX_DURATION, onChange: function (n) { d.set("top", n), i.requestRenderAll(), r() }, onComplete: function () { d.setCoords(), c() } }) }, fxRemove: function (d, a) { a = a || {}; var l = function () { }, c = a.onComplete || l, r = a.onChange || l, i = this; return h.util.animate({ target: this, startValue: d.opacity, endValue: 0, duration: this.FX_DURATION, onChange: function (n) { d.set("opacity", n), i.requestRenderAll(), r() }, onComplete: function () { i.remove(d), c() } }) } }), h.util.object.extend(h.Object.prototype, { animate: function () { if (arguments[0] && typeof arguments[0] == "object") { var d = [], a, l, c = []; for (a in arguments[0]) d.push(a); for (var r = 0, i = d.length; r < i; r++)a = d[r], l = r !== i - 1, c.push(this._animate(a, arguments[0][a], arguments[1], l)); return c } else return this._animate.apply(this, arguments) }, _animate: function (d, a, l, c) { var r = this, i; a = a.toString(), l ? l = h.util.object.clone(l) : l = {}, ~d.indexOf(".") && (i = d.split(".")); var n = r.colorProperties.indexOf(d) > -1 || i && r.colorProperties.indexOf(i[1]) > -1, o = i ? this.get(i[0])[i[1]] : this.get(d); "from" in l || (l.from = o), n || (~a.indexOf("=") ? a = o + parseFloat(a.replace("=", "")) : a = parseFloat(a)); var p = { target: this, startValue: l.from, endValue: a, byValue: l.by, easing: l.easing, duration: l.duration, abort: l.abort && function (f, m, y) { return l.abort.call(r, f, m, y) }, onChange: function (f, m, y) { i ? r[i[0]][i[1]] = f : r.set(d, f), !c && l.onChange && l.onChange(f, m, y) }, onComplete: function (f, m, y) { c || (r.setCoords(), l.onComplete && l.onComplete(f, m, y)) } }; return n ? h.util.animateColor(p.startValue, p.endValue, p.duration, p) : h.util.animate(p) } }), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.util.object.clone, r = { x1: 1, x2: 1, y1: 1, y2: 1 }; if (a.Line) { a.warn("fabric.Line is already defined"); return } a.Line = a.util.createClass(a.Object, {
    type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: a.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"), initialize: function (n, o) { n || (n = [0, 0, 0, 0]), this.callSuper("initialize", o), this.set("x1", n[0]), this.set("y1", n[1]), this.set("x2", n[2]), this.set("y2", n[3]), this._setWidthHeight(o) }, _setWidthHeight: function (n) { n || (n = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in n ? n.left : this._getLeftToOriginX(), this.top = "top" in n ? n.top : this._getTopToOriginY() }, _set: function (n, o) { return this.callSuper("_set", n, o), typeof r[n] < "u" && this._setWidthHeight(), this }, _getLeftToOriginX: i({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: i({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (n) { n.beginPath(); var o = this.calcLinePoints(); n.moveTo(o.x1, o.y1), n.lineTo(o.x2, o.y2), n.lineWidth = this.strokeWidth; var p = n.strokeStyle; n.strokeStyle = this.stroke || n.fillStyle, this.stroke && this._renderStroke(n), n.strokeStyle = p }, _findCenterFromElement: function () { return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 } }, toObject: function (n) { return l(this.callSuper("toObject", n), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var n = this.callSuper("_getNonTransformedDimensions"); return this.strokeLineCap === "butt" && (this.width === 0 && (n.y -= this.strokeWidth), this.height === 0 && (n.x -= this.strokeWidth)), n }, calcLinePoints: function () { var n = this.x1 <= this.x2 ? -1 : 1, o = this.y1 <= this.y2 ? -1 : 1, p = n * this.width * .5, f = o * this.height * .5, m = n * this.width * -.5, y = o * this.height * -.5; return { x1: p, x2: m, y1: f, y2: y } }, _toSVG: function () {
      var n = this.calcLinePoints(); return ["<line ", "COMMON_PARTS", 'x1="', n.x1, '" y1="', n.y1, '" x2="', n.x2, '" y2="', n.y2, `" />
`]
    }
  }), a.Line.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), a.Line.fromElement = function (n, o, p) { p = p || {}; var f = a.parseAttributes(n, a.Line.ATTRIBUTE_NAMES), m = [f.x1 || 0, f.y1 || 0, f.x2 || 0, f.y2 || 0]; o(new a.Line(m, l(f, p))) }, a.Line.fromObject = function (n, o) { function p(m) { delete m.points, o && o(m) } var f = c(n, !0); f.points = [n.x1, n.y1, n.x2, n.y2], a.Object._fromObject("Line", f, p, "points") }; function i(n, o) { var p = n.origin, f = n.axis1, m = n.axis2, y = n.dimension, C = o.nearest, x = o.center, I = o.farthest; return function () { switch (this.get(p)) { case C: return Math.min(this.get(f), this.get(m)); case x: return Math.min(this.get(f), this.get(m)) + .5 * this.get(y); case I: return Math.max(this.get(f), this.get(m)) } } }
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.degreesToRadians; if (a.Circle) { a.warn("fabric.Circle is already defined."); return } a.Circle = a.util.createClass(a.Object, {
    type: "circle", radius: 0, startAngle: 0, endAngle: 360, cacheProperties: a.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"), _set: function (r, i) { return this.callSuper("_set", r, i), r === "radius" && this.setRadius(i), this }, toObject: function (r) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(r)) }, _toSVG: function () {
      var r, i = 0, n = 0, o = (this.endAngle - this.startAngle) % 360; if (o === 0) r = ["<circle ", "COMMON_PARTS", 'cx="' + i + '" cy="' + n + '" ', 'r="', this.radius, `" />
`]; else {
        var p = l(this.startAngle), f = l(this.endAngle), m = this.radius, y = a.util.cos(p) * m, C = a.util.sin(p) * m, x = a.util.cos(f) * m, I = a.util.sin(f) * m, D = o > 180 ? "1" : "0"; r = ['<path d="M ' + y + " " + C, " A " + m + " " + m, " 0 ", +D + " 1", " " + x + " " + I, '" ', "COMMON_PARTS", ` />
`]
      } return r
    }, _render: function (r) { r.beginPath(), r.arc(0, 0, this.radius, l(this.startAngle), l(this.endAngle), !1), this._renderPaintInOrder(r) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (r) { return this.radius = r, this.set("width", r * 2).set("height", r * 2) }
  }), a.Circle.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), a.Circle.fromElement = function (r, i) { var n = a.parseAttributes(r, a.Circle.ATTRIBUTE_NAMES); if (!c(n)) throw new Error("value of `r` attribute is required and can not be negative"); n.left = (n.left || 0) - n.radius, n.top = (n.top || 0) - n.radius, i(new a.Circle(n)) }; function c(r) { return "radius" in r && r.radius >= 0 } a.Circle.fromObject = function (r, i) { a.Object._fromObject("Circle", r, i) }
}(v), function (d) { var a = d.fabric || (d.fabric = {}); if (a.Triangle) { a.warn("fabric.Triangle is already defined"); return } a.Triangle = a.util.createClass(a.Object, { type: "triangle", width: 100, height: 100, _render: function (l) { var c = this.width / 2, r = this.height / 2; l.beginPath(), l.moveTo(-c, r), l.lineTo(0, -r), l.lineTo(c, r), l.closePath(), this._renderPaintInOrder(l) }, _toSVG: function () { var l = this.width / 2, c = this.height / 2, r = [-l + " " + c, "0 " + -c, l + " " + c].join(","); return ["<polygon ", "COMMON_PARTS", 'points="', r, '" />'] } }), a.Triangle.fromObject = function (l, c) { return a.Object._fromObject("Triangle", l, c) } }(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = Math.PI * 2; if (a.Ellipse) { a.warn("fabric.Ellipse is already defined."); return } a.Ellipse = a.util.createClass(a.Object, {
    type: "ellipse", rx: 0, ry: 0, cacheProperties: a.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (c) { this.callSuper("initialize", c), this.set("rx", c && c.rx || 0), this.set("ry", c && c.ry || 0) }, _set: function (c, r) { switch (this.callSuper("_set", c, r), c) { case "rx": this.rx = r, this.set("width", r * 2); break; case "ry": this.ry = r, this.set("height", r * 2); break }return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (c) { return this.callSuper("toObject", ["rx", "ry"].concat(c)) }, _toSVG: function () {
      return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, `" />
`]
    }, _render: function (c) { c.beginPath(), c.save(), c.transform(1, 0, 0, this.ry / this.rx, 0, 0), c.arc(0, 0, this.rx, 0, l, !1), c.restore(), this._renderPaintInOrder(c) }
  }), a.Ellipse.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), a.Ellipse.fromElement = function (c, r) { var i = a.parseAttributes(c, a.Ellipse.ATTRIBUTE_NAMES); i.left = (i.left || 0) - i.rx, i.top = (i.top || 0) - i.ry, r(new a.Ellipse(i)) }, a.Ellipse.fromObject = function (c, r) { a.Object._fromObject("Ellipse", c, r) }
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend; if (a.Rect) { a.warn("fabric.Rect is already defined"); return } a.Rect = a.util.createClass(a.Object, {
    stateProperties: a.Object.prototype.stateProperties.concat("rx", "ry"), type: "rect", rx: 0, ry: 0, cacheProperties: a.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (c) { this.callSuper("initialize", c), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (c) { var r = this.rx ? Math.min(this.rx, this.width / 2) : 0, i = this.ry ? Math.min(this.ry, this.height / 2) : 0, n = this.width, o = this.height, p = -this.width / 2, f = -this.height / 2, m = r !== 0 || i !== 0, y = 1 - .5522847498; c.beginPath(), c.moveTo(p + r, f), c.lineTo(p + n - r, f), m && c.bezierCurveTo(p + n - y * r, f, p + n, f + y * i, p + n, f + i), c.lineTo(p + n, f + o - i), m && c.bezierCurveTo(p + n, f + o - y * i, p + n - y * r, f + o, p + n - r, f + o), c.lineTo(p + r, f + o), m && c.bezierCurveTo(p + y * r, f + o, p, f + o - y * i, p, f + o - i), c.lineTo(p, f + i), m && c.bezierCurveTo(p, f + y * i, p + y * r, f, p + r, f), c.closePath(), this._renderPaintInOrder(c) }, toObject: function (c) { return this.callSuper("toObject", ["rx", "ry"].concat(c)) }, _toSVG: function () {
      var c = -this.width / 2, r = -this.height / 2; return ["<rect ", "COMMON_PARTS", 'x="', c, '" y="', r, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, `" />
`]
    }
  }), a.Rect.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), a.Rect.fromElement = function (c, r, i) { if (!c) return r(null); i = i || {}; var n = a.parseAttributes(c, a.Rect.ATTRIBUTE_NAMES); n.left = n.left || 0, n.top = n.top || 0, n.height = n.height || 0, n.width = n.width || 0; var o = new a.Rect(l(i ? a.util.object.clone(i) : {}, n)); o.visible = o.visible && o.width > 0 && o.height > 0, r(o) }, a.Rect.fromObject = function (c, r) { return a.Object._fromObject("Rect", c, r) }
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.util.array.min, r = a.util.array.max, i = a.util.toFixed, n = a.util.projectStrokeOnPoints; if (a.Polyline) { a.warn("fabric.Polyline is already defined"); return } a.Polyline = a.util.createClass(a.Object, {
    type: "polyline", points: null, exactBoundingBox: !1, cacheProperties: a.Object.prototype.cacheProperties.concat("points"), initialize: function (o, p) { p = p || {}, this.points = o || [], this.callSuper("initialize", p), this._setPositionDimensions(p) }, _projectStrokeOnPoints: function () { return n(this.points, this, !0) }, _setPositionDimensions: function (o) { var p = this._calcDimensions(o), f, m = this.exactBoundingBox ? this.strokeWidth : 0; this.width = p.width - m, this.height = p.height - m, o.fromSVG || (f = this.translateToGivenOrigin({ x: p.left - this.strokeWidth / 2 + m / 2, y: p.top - this.strokeWidth / 2 + m / 2 }, "left", "top", this.originX, this.originY)), typeof o.left > "u" && (this.left = o.fromSVG ? p.left : f.x), typeof o.top > "u" && (this.top = o.fromSVG ? p.top : f.y), this.pathOffset = { x: p.left + this.width / 2 + m / 2, y: p.top + this.height / 2 + m / 2 } }, _calcDimensions: function () { var o = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, p = c(o, "x") || 0, f = c(o, "y") || 0, m = r(o, "x") || 0, y = r(o, "y") || 0, C = m - p, x = y - f; return { left: p, top: f, width: C, height: x } }, toObject: function (o) { return l(this.callSuper("toObject", o), { points: this.points.concat() }) }, _toSVG: function () {
      for (var o = [], p = this.pathOffset.x, f = this.pathOffset.y, m = a.Object.NUM_FRACTION_DIGITS, y = 0, C = this.points.length; y < C; y++)o.push(i(this.points[y].x - p, m), ",", i(this.points[y].y - f, m), " "); return ["<" + this.type + " ", "COMMON_PARTS", 'points="', o.join(""), `" />
`]
    }, commonRender: function (o) { var p, f = this.points.length, m = this.pathOffset.x, y = this.pathOffset.y; if (!f || isNaN(this.points[f - 1].y)) return !1; o.beginPath(), o.moveTo(this.points[0].x - m, this.points[0].y - y); for (var C = 0; C < f; C++)p = this.points[C], o.lineTo(p.x - m, p.y - y); return !0 }, _render: function (o) { this.commonRender(o) && this._renderPaintInOrder(o) }, complexity: function () { return this.get("points").length }
  }), a.Polyline.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat(), a.Polyline.fromElementGenerator = function (o) { return function (p, f, m) { if (!p) return f(null); m || (m = {}); var y = a.parsePointsAttribute(p.getAttribute("points")), C = a.parseAttributes(p, a[o].ATTRIBUTE_NAMES); C.fromSVG = !0, f(new a[o](y, l(C, m))) } }, a.Polyline.fromElement = a.Polyline.fromElementGenerator("Polyline"), a.Polyline.fromObject = function (o, p) { return a.Object._fromObject("Polyline", o, p, "points") }
}(v), function (d) { var a = d.fabric || (d.fabric = {}), l = a.util.projectStrokeOnPoints; if (a.Polygon) { a.warn("fabric.Polygon is already defined"); return } a.Polygon = a.util.createClass(a.Polyline, { type: "polygon", _projectStrokeOnPoints: function () { return l(this.points, this) }, _render: function (c) { this.commonRender(c) && (c.closePath(), this._renderPaintInOrder(c)) } }), a.Polygon.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat(), a.Polygon.fromElement = a.Polyline.fromElementGenerator("Polygon"), a.Polygon.fromObject = function (c, r) { a.Object._fromObject("Polygon", c, r, "points") } }(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.array.min, c = a.util.array.max, r = a.util.object.extend, i = a.util.object.clone, n = a.util.toFixed; if (a.Path) { a.warn("fabric.Path is already defined"); return } a.Path = a.util.createClass(a.Object, {
    type: "path", path: null, cacheProperties: a.Object.prototype.cacheProperties.concat("path", "fillRule"), stateProperties: a.Object.prototype.stateProperties.concat("path"), initialize: function (o, p) { p = i(p || {}), delete p.path, this.callSuper("initialize", p), this._setPath(o || [], p) }, _setPath: function (o, p) { this.path = a.util.makePathSimpler(Array.isArray(o) ? o : a.util.parsePath(o)), a.Polyline.prototype._setPositionDimensions.call(this, p || {}) }, _renderPathCommands: function (o) { var p, f = 0, m = 0, y = 0, C = 0, x = 0, I = 0, D = -this.pathOffset.x, P = -this.pathOffset.y; o.beginPath(); for (var z = 0, et = this.path.length; z < et; ++z)switch (p = this.path[z], p[0]) { case "L": y = p[1], C = p[2], o.lineTo(y + D, C + P); break; case "M": y = p[1], C = p[2], f = y, m = C, o.moveTo(y + D, C + P); break; case "C": y = p[5], C = p[6], x = p[3], I = p[4], o.bezierCurveTo(p[1] + D, p[2] + P, x + D, I + P, y + D, C + P); break; case "Q": o.quadraticCurveTo(p[1] + D, p[2] + P, p[3] + D, p[4] + P), y = p[3], C = p[4], x = p[1], I = p[2]; break; case "z": case "Z": y = f, C = m, o.closePath(); break } }, _render: function (o) { this._renderPathCommands(o), this._renderPaintInOrder(o) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (o) { return r(this.callSuper("toObject", o), { path: this.path.map(function (p) { return p.slice() }) }) }, toDatalessObject: function (o) { var p = this.toObject(["sourcePath"].concat(o)); return p.sourcePath && delete p.path, p }, _toSVG: function () {
      var o = a.util.joinPath(this.path); return ["<path ", "COMMON_PARTS", 'd="', o, '" stroke-linecap="round" ', `/>
`]
    }, _getOffsetTransform: function () { var o = a.Object.NUM_FRACTION_DIGITS; return " translate(" + n(-this.pathOffset.x, o) + ", " + n(-this.pathOffset.y, o) + ")" }, toClipPathSVG: function (o) { var p = this._getOffsetTransform(); return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: o, additionalTransform: p }) }, toSVG: function (o) { var p = this._getOffsetTransform(); return this._createBaseSVGMarkup(this._toSVG(), { reviver: o, additionalTransform: p }) }, complexity: function () { return this.path.length }, _calcDimensions: function () { for (var o = [], p = [], f, m = 0, y = 0, C = 0, x = 0, I, D = 0, P = this.path.length; D < P; ++D) { switch (f = this.path[D], f[0]) { case "L": C = f[1], x = f[2], I = []; break; case "M": C = f[1], x = f[2], m = C, y = x, I = []; break; case "C": I = a.util.getBoundsOfCurve(C, x, f[1], f[2], f[3], f[4], f[5], f[6]), C = f[5], x = f[6]; break; case "Q": I = a.util.getBoundsOfCurve(C, x, f[1], f[2], f[1], f[2], f[3], f[4]), C = f[3], x = f[4]; break; case "z": case "Z": C = m, x = y; break }I.forEach(function (ct) { o.push(ct.x), p.push(ct.y) }), o.push(C), p.push(x) } var z = l(o) || 0, et = l(p) || 0, tt = c(o) || 0, st = c(p) || 0, dt = tt - z, q = st - et; return { left: z, top: et, width: dt, height: q } }
  }), a.Path.fromObject = function (o, p) { if (typeof o.sourcePath == "string") { var f = o.sourcePath; a.loadSVGFromURL(f, function (m) { var y = m[0]; y.setOptions(o), o.clipPath ? a.util.enlivenObjects([o.clipPath], function (C) { y.clipPath = C[0], p && p(y) }) : p && p(y) }) } else a.Object._fromObject("Path", o, p, "path") }, a.Path.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat(["d"]), a.Path.fromElement = function (o, p, f) { var m = a.parseAttributes(o, a.Path.ATTRIBUTE_NAMES); m.fromSVG = !0, p(new a.Path(m.d, r(m, f))) }
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.array.min, c = a.util.array.max; a.Group || (a.Group = a.util.createClass(a.Object, a.Collection, {
    type: "group", strokeWidth: 0, subTargetCheck: !1, cacheProperties: [], useSetOnGroup: !1, initialize: function (r, i, n) { i = i || {}, this._objects = [], n && this.callSuper("initialize", i), this._objects = r || []; for (var o = this._objects.length; o--;)this._objects[o].group = this; if (n) this._updateObjectsACoords(); else { var p = i && i.centerPoint; i.originX !== void 0 && (this.originX = i.originX), i.originY !== void 0 && (this.originY = i.originY), p || this._calcBounds(), this._updateObjectsCoords(p), delete i.centerPoint, this.callSuper("initialize", i) } this.setCoords() }, _updateObjectsACoords: function () { for (var r = !0, i = this._objects.length; i--;)this._objects[i].setCoords(r) }, _updateObjectsCoords: function (i) { for (var i = i || this.getCenterPoint(), n = this._objects.length; n--;)this._updateObjectCoords(this._objects[n], i) }, _updateObjectCoords: function (r, i) { var n = r.left, o = r.top, p = !0; r.set({ left: n - i.x, top: o - i.y }), r.group = this, r.setCoords(p) }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (r) { var i = !!this.group; return this._restoreObjectsState(), a.util.resetObjectTransform(this), r && (i && a.util.removeTransformFromObject(r, this.group.calcTransformMatrix()), this._objects.push(r), r.group = this, r._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, i ? this.group.addWithUpdate() : this.setCoords(), this }, removeWithUpdate: function (r) { return this._restoreObjectsState(), a.util.resetObjectTransform(this), this.remove(r), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _onObjectAdded: function (r) { this.dirty = !0, r.group = this, r._set("canvas", this.canvas) }, _onObjectRemoved: function (r) { this.dirty = !0, delete r.group }, _set: function (r, i) { var n = this._objects.length; if (this.useSetOnGroup) for (; n--;)this._objects[n].setOnGroup(r, i); if (r === "canvas") for (; n--;)this._objects[n]._set(r, i); a.Object.prototype._set.call(this, r, i) }, toObject: function (r) { var i = this.includeDefaultValues, n = this._objects.filter(function (p) { return !p.excludeFromExport }).map(function (p) { var f = p.includeDefaultValues; p.includeDefaultValues = i; var m = p.toObject(r); return p.includeDefaultValues = f, m }), o = a.Object.prototype.toObject.call(this, r); return o.objects = n, o }, toDatalessObject: function (r) { var i, n = this.sourcePath; if (n) i = n; else { var o = this.includeDefaultValues; i = this._objects.map(function (f) { var m = f.includeDefaultValues; f.includeDefaultValues = o; var y = f.toDatalessObject(r); return f.includeDefaultValues = m, y }) } var p = a.Object.prototype.toDatalessObject.call(this, r); return p.objects = i, p }, render: function (r) { this._transformDone = !0, this.callSuper("render", r), this._transformDone = !1 }, shouldCache: function () { var r = a.Object.prototype.shouldCache.call(this); if (r) { for (var i = 0, n = this._objects.length; i < n; i++)if (this._objects[i].willDrawShadow()) return this.ownCaching = !1, !1 } return r }, willDrawShadow: function () { if (a.Object.prototype.willDrawShadow.call(this)) return !0; for (var r = 0, i = this._objects.length; r < i; r++)if (this._objects[r].willDrawShadow()) return !0; return !1 }, isOnACache: function () { return this.ownCaching || this.group && this.group.isOnACache() }, drawObject: function (r) { for (var i = 0, n = this._objects.length; i < n; i++)this._objects[i].render(r); this._drawClipPath(r, this.clipPath) }, isCacheDirty: function (r) { if (this.callSuper("isCacheDirty", r)) return !0; if (!this.statefullCache) return !1; for (var i = 0, n = this._objects.length; i < n; i++)if (this._objects[i].isCacheDirty(!0)) { if (this._cacheCanvas) { var o = this.cacheWidth / this.zoomX, p = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-o / 2, -p / 2, o, p) } return !0 } return !1 }, _restoreObjectsState: function () { var r = this.calcOwnMatrix(); return this._objects.forEach(function (i) { a.util.addTransformToObject(i, r), delete i.group, i.setCoords() }), this }, destroy: function () { return this._objects.forEach(function (r) { r.set("dirty", !0) }), this._restoreObjectsState() }, dispose: function () { this.callSuper("dispose"), this.forEachObject(function (r) { r.dispose && r.dispose() }), this._objects = [] }, toActiveSelection: function () { if (this.canvas) { var r = this._objects, i = this.canvas; this._objects = []; var n = this.toObject(); delete n.objects; var o = new a.ActiveSelection([]); return o.set(n), o.type = "activeSelection", i.remove(this), r.forEach(function (p) { p.group = o, p.dirty = !0, i.add(p) }), o.canvas = i, o._objects = r, i._activeObject = o, o.setCoords(), o } }, ungroupOnCanvas: function () { return this._restoreObjectsState() }, setObjectsCoords: function () { var r = !0; return this.forEachObject(function (i) { i.setCoords(r) }), this }, _calcBounds: function (r) { for (var i = [], n = [], o, p, f, m = ["tr", "br", "bl", "tl"], y = 0, C = this._objects.length, x, I = m.length; y < C; ++y) { for (o = this._objects[y], f = o.calcACoords(), x = 0; x < I; x++)p = m[x], i.push(f[p].x), n.push(f[p].y); o.aCoords = f } this._getBounds(i, n, r) }, _getBounds: function (r, i, n) { var o = new a.Point(l(r), l(i)), p = new a.Point(c(r), c(i)), f = o.y || 0, m = o.x || 0, y = p.x - o.x || 0, C = p.y - o.y || 0; this.width = y, this.height = C, n || this.setPositionByOrigin({ x: m, y: f }, "left", "top") }, _toSVG: function (r) {
      for (var i = ["<g ", "COMMON_PARTS", ` >
`], n = 0, o = this._objects.length; n < o; n++)i.push("		", this._objects[n].toSVG(r)); return i.push(`</g>
`), i
    }, getSvgStyles: function () { var r = typeof this.opacity < "u" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", i = this.visible ? "" : " visibility: hidden;"; return [r, this.getSvgFilter(), i].join("") }, toClipPathSVG: function (r) { for (var i = [], n = 0, o = this._objects.length; n < o; n++)i.push("	", this._objects[n].toClipPathSVG(r)); return this._createBaseClipPathSVGMarkup(i, { reviver: r }) }
  }), a.Group.fromObject = function (r, i) { var n = r.objects, o = a.util.object.clone(r, !0); if (delete o.objects, typeof n == "string") { a.loadSVGFromURL(n, function (p) { var f = a.util.groupSVGElements(p, r, n), m = o.clipPath; delete o.clipPath, f.set(o), m ? a.util.enlivenObjects([m], function (y) { f.clipPath = y[0], i && i(f) }) : i && i(f) }); return } a.util.enlivenObjects(n, function (p) { a.util.enlivenObjectEnlivables(r, o, function () { i && i(new a.Group(p, o, !0)) }) }) })
}(v), function (d) { var a = d.fabric || (d.fabric = {}); a.ActiveSelection || (a.ActiveSelection = a.util.createClass(a.Group, { type: "activeSelection", initialize: function (l, c) { c = c || {}, this._objects = l || []; for (var r = this._objects.length; r--;)this._objects[r].group = this; c.originX && (this.originX = c.originX), c.originY && (this.originY = c.originY), this._calcBounds(), this._updateObjectsCoords(), a.Object.prototype.initialize.call(this, c), this.setCoords() }, toGroup: function () { var l = this._objects.concat(); this._objects = []; var c = a.Object.prototype.toObject.call(this), r = new a.Group([]); if (delete c.type, r.set(c), l.forEach(function (n) { n.canvas.remove(n), n.group = r }), r._objects = l, !this.canvas) return r; var i = this.canvas; return i.add(r), i._activeObject = r, r.setCoords(), r }, onDeselect: function () { return this.destroy(), !1 }, toString: function () { return "#<fabric.ActiveSelection: (" + this.complexity() + ")>" }, shouldCache: function () { return !1 }, isOnACache: function () { return !1 }, _renderControls: function (l, c, r) { l.save(), l.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", l, c), r = r || {}, typeof r.hasControls > "u" && (r.hasControls = !1), r.forActiveSelection = !0; for (var i = 0, n = this._objects.length; i < n; i++)this._objects[i]._renderControls(l, r); l.restore() } }), a.ActiveSelection.fromObject = function (l, c) { a.util.enlivenObjects(l.objects, function (r) { delete l.objects, c && c(new a.ActiveSelection(r, l, !0)) }) }) }(v), function (d) {
  var a = h.util.object.extend; if (d.fabric || (d.fabric = {}), d.fabric.Image) { h.warn("fabric.Image is already defined."); return } h.Image = h.util.createClass(h.Object, {
    type: "image", strokeWidth: 0, srcFromAttribute: !1, _lastScaleX: 1, _lastScaleY: 1, _filterScalingX: 1, _filterScalingY: 1, minimumScaleTrigger: .5, stateProperties: h.Object.prototype.stateProperties.concat("cropX", "cropY"), cacheProperties: h.Object.prototype.cacheProperties.concat("cropX", "cropY"), cacheKey: "", cropX: 0, cropY: 0, imageSmoothing: !0, initialize: function (l, c) { c || (c = {}), this.filters = [], this.cacheKey = "texture" + h.Object.__uid++, this.callSuper("initialize", c), this._initElement(l, c) }, getElement: function () { return this._element || {} }, setElement: function (l, c) { return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = l, this._originalElement = l, this._initConfig(c), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this }, removeTexture: function (l) { var c = h.filterBackend; c && c.evictCachesForKey && c.evictCachesForKey(l) }, dispose: function () { this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function (l) { h.util.cleanUpJsdomNode(this[l]), this[l] = void 0 }.bind(this)) }, getCrossOrigin: function () { return this._originalElement && (this._originalElement.crossOrigin || null) }, getOriginalSize: function () { var l = this.getElement(); return { width: l.naturalWidth || l.width, height: l.naturalHeight || l.height } }, _stroke: function (l) { if (!(!this.stroke || this.strokeWidth === 0)) { var c = this.width / 2, r = this.height / 2; l.beginPath(), l.moveTo(-c, -r), l.lineTo(c, -r), l.lineTo(c, r), l.lineTo(-c, r), l.lineTo(-c, -r), l.closePath() } }, toObject: function (l) { var c = []; this.filters.forEach(function (i) { i && c.push(i.toObject()) }); var r = a(this.callSuper("toObject", ["cropX", "cropY"].concat(l)), { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: c }); return this.resizeFilter && (r.resizeFilter = this.resizeFilter.toObject()), r }, hasCrop: function () { return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height }, _toSVG: function () {
      var l = [], c = [], r, i = this._element, n = -this.width / 2, o = -this.height / 2, p = "", f = ""; if (!i) return []; if (this.hasCrop()) {
        var m = h.Object.__uid++; l.push('<clipPath id="imageCrop_' + m + `">
`, '	<rect x="' + n + '" y="' + o + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), p = ' clip-path="url(#imageCrop_' + m + ')" '
      } if (this.imageSmoothing || (f = '" image-rendering="optimizeSpeed'), c.push("	<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(!0), '" x="', n - this.cropX, '" y="', o - this.cropY, '" width="', i.width || i.naturalWidth, '" height="', i.height || i.height, f, '"', p, `></image>
`), this.stroke || this.strokeDashArray) {
        var y = this.fill; this.fill = null, r = ["	<rect ", 'x="', n, '" y="', o, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), `"/>
`], this.fill = y
      } return this.paintFirst !== "fill" ? l = l.concat(r, c) : l = l.concat(c, r), l
    }, getSrc: function (l) { var c = l ? this._element : this._originalElement; return c ? c.toDataURL ? c.toDataURL() : this.srcFromAttribute ? c.getAttribute("src") : c.src : this.src || "" }, setSrc: function (l, c, r) { return h.util.loadImage(l, function (i, n) { this.setElement(i, r), this._setWidthHeight(), c && c(this, n) }, this, r && r.crossOrigin), this }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyResizeFilters: function () { var l = this.resizeFilter, c = this.minimumScaleTrigger, r = this.getTotalObjectScaling(), i = r.scaleX, n = r.scaleY, o = this._filteredEl || this._originalElement; if (this.group && this.set("dirty", !0), !l || i > c && n > c) { this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i, this._lastScaleY = n; return } h.filterBackend || (h.filterBackend = h.initFilterBackend()); var p = h.util.createCanvasElement(), f = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, m = o.width, y = o.height; p.width = m, p.height = y, this._element = p, this._lastScaleX = l.scaleX = i, this._lastScaleY = l.scaleY = n, h.filterBackend.applyFilters([l], o, m, y, this._element, f), this._filterScalingX = p.width / this._originalElement.width, this._filterScalingY = p.height / this._originalElement.height }, applyFilters: function (l) { if (l = l || this.filters || [], l = l.filter(function (o) { return o && !o.isNeutralState() }), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), l.length === 0) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this; var c = this._originalElement, r = c.naturalWidth || c.width, i = c.naturalHeight || c.height; if (this._element === this._originalElement) { var n = h.util.createCanvasElement(); n.width = r, n.height = i, this._element = n, this._filteredEl = n } else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, r, i), this._lastScaleX = 1, this._lastScaleY = 1; return h.filterBackend || (h.filterBackend = h.initFilterBackend()), h.filterBackend.applyFilters(l, this._originalElement, r, i, this._element, this.cacheKey), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this }, _render: function (l) { h.util.setImageSmoothing(l, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(l), this._renderPaintInOrder(l) }, drawCacheOnCanvas: function (l) { h.util.setImageSmoothing(l, this.imageSmoothing), h.Object.prototype.drawCacheOnCanvas.call(this, l) }, shouldCache: function () { return this.needsItsOwnCache() }, _renderFill: function (l) { var c = this._element; if (c) { var r = this._filterScalingX, i = this._filterScalingY, n = this.width, o = this.height, p = Math.min, f = Math.max, m = f(this.cropX, 0), y = f(this.cropY, 0), C = c.naturalWidth || c.width, x = c.naturalHeight || c.height, I = m * r, D = y * i, P = p(n * r, C - I), z = p(o * i, x - D), et = -n / 2, tt = -o / 2, st = p(n, C / r - m), dt = p(o, x / i - y); c && l.drawImage(c, I, D, P, z, et, tt, st, dt) } }, _needsResize: function () { var l = this.getTotalObjectScaling(); return l.scaleX !== this._lastScaleX || l.scaleY !== this._lastScaleY }, _resetWidthHeight: function () { this.set(this.getOriginalSize()) }, _initElement: function (l, c) { this.setElement(h.util.getById(l), c), h.util.addClass(this.getElement(), h.Image.CSS_CANVAS) }, _initConfig: function (l) { l || (l = {}), this.setOptions(l), this._setWidthHeight(l) }, _initFilters: function (l, c) { l && l.length ? h.util.enlivenObjects(l, function (r) { c && c(r) }, "fabric.Image.filters") : c && c() }, _setWidthHeight: function (l) { l || (l = {}); var c = this.getElement(); this.width = l.width || c.naturalWidth || c.width || 0, this.height = l.height || c.naturalHeight || c.height || 0 }, parsePreserveAspectRatioAttribute: function () { var l = h.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), c = this._element.width, r = this._element.height, i = 1, n = 1, o = 0, p = 0, f = 0, m = 0, y, C = this.width, x = this.height, I = { width: C, height: x }; return l && (l.alignX !== "none" || l.alignY !== "none") ? (l.meetOrSlice === "meet" && (i = n = h.util.findScaleToFit(this._element, I), y = (C - c * i) / 2, l.alignX === "Min" && (o = -y), l.alignX === "Max" && (o = y), y = (x - r * n) / 2, l.alignY === "Min" && (p = -y), l.alignY === "Max" && (p = y)), l.meetOrSlice === "slice" && (i = n = h.util.findScaleToCover(this._element, I), y = c - C / i, l.alignX === "Mid" && (f = y / 2), l.alignX === "Max" && (f = y), y = r - x / n, l.alignY === "Mid" && (m = y / 2), l.alignY === "Max" && (m = y), c = C / i, r = x / n)) : (i = C / c, n = x / r), { width: c, height: r, scaleX: i, scaleY: n, offsetLeft: o, offsetTop: p, cropX: f, cropY: m } }
  }), h.Image.CSS_CANVAS = "canvas-img", h.Image.prototype.getSvgSrc = h.Image.prototype.getSrc, h.Image.fromObject = function (l, c) { var r = h.util.object.clone(l); h.util.loadImage(r.src, function (i, n) { if (n) { c && c(null, !0); return } h.Image.prototype._initFilters.call(r, r.filters, function (o) { r.filters = o || [], h.Image.prototype._initFilters.call(r, [r.resizeFilter], function (p) { r.resizeFilter = p[0], h.util.enlivenObjectEnlivables(r, r, function () { var f = new h.Image(i, r); c(f, !1) }) }) }) }, null, r.crossOrigin) }, h.Image.fromURL = function (l, c, r) { h.util.loadImage(l, function (i, n) { c && c(new h.Image(i, r), n) }, null, r && r.crossOrigin) }, h.Image.ATTRIBUTE_NAMES = h.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), h.Image.fromElement = function (l, c, r) { var i = h.parseAttributes(l, h.Image.ATTRIBUTE_NAMES); h.Image.fromURL(i["xlink:href"], c, a(r ? h.util.object.clone(r) : {}, i)) }
}(v), h.util.object.extend(h.Object.prototype, { _getAngleValueForStraighten: function () { var d = this.angle % 360; return d > 0 ? Math.round((d - 1) / 90) * 90 : Math.round(d / 90) * 90 }, straighten: function () { return this.rotate(this._getAngleValueForStraighten()) }, fxStraighten: function (d) { d = d || {}; var a = function () { }, l = d.onComplete || a, c = d.onChange || a, r = this; return h.util.animate({ target: this, startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function (i) { r.rotate(i), c() }, onComplete: function () { r.setCoords(), l() } }) } }), h.util.object.extend(h.StaticCanvas.prototype, { straightenObject: function (d) { return d.straighten(), this.requestRenderAll(), this }, fxStraightenObject: function (d) { return d.fxStraighten({ onChange: this.requestRenderAllBound }) } }), function () {
  function d(l, c) {
    var r = "precision " + c + ` float;
void main(){}`, i = l.createShader(l.FRAGMENT_SHADER); return l.shaderSource(i, r), l.compileShader(i), !!l.getShaderParameter(i, l.COMPILE_STATUS)
  } h.isWebglSupported = function (l) { if (h.isLikelyNode) return !1; l = l || h.WebglFilterBackend.prototype.tileSize; var c = document.createElement("canvas"), r = c.getContext("webgl") || c.getContext("experimental-webgl"), i = !1; if (r) { h.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), i = h.maxTextureSize >= l; for (var n = ["highp", "mediump", "lowp"], o = 0; o < 3; o++)if (d(r, n[o])) { h.webGlPrecision = n[o]; break } } return this.isSupported = i, i }, h.WebglFilterBackend = a; function a(l) { l && l.tileSize && (this.tileSize = l.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo() } a.prototype = { tileSize: 2048, resources: {}, setupGLContext: function (l, c) { this.dispose(), this.createWebGLCanvas(l, c), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(l, c) }, chooseFastestCopyGLTo2DMethod: function (l, c) { var r = typeof window.performance < "u", i; try { new ImageData(1, 1), i = !0 } catch { i = !1 } var n = typeof ArrayBuffer < "u", o = typeof Uint8ClampedArray < "u"; if (r && i && n && o) { var p = h.util.createCanvasElement(), f = new ArrayBuffer(l * c * 4); if (h.forceGLPutImageData) { this.imageBuffer = f, this.copyGLTo2D = S; return } var m = { imageBuffer: f, destinationWidth: l, destinationHeight: c, targetCanvas: p }, y, C, x; p.width = l, p.height = c, y = window.performance.now(), _.call(m, this.gl, m), C = window.performance.now() - y, y = window.performance.now(), S.call(m, this.gl, m), x = window.performance.now() - y, C > x ? (this.imageBuffer = f, this.copyGLTo2D = S) : this.copyGLTo2D = _ } }, createWebGLCanvas: function (l, c) { var r = h.util.createCanvasElement(); r.width = l, r.height = c; var i = { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 }, n = r.getContext("webgl", i); n || (n = r.getContext("experimental-webgl", i)), n && (n.clearColor(0, 0, 0, 0), this.canvas = r, this.gl = n) }, applyFilters: function (l, c, r, i, n, o) { var p = this.gl, f; o && (f = this.getCachedTexture(o, c)); var m = { originalWidth: c.width || c.originalWidth, originalHeight: c.height || c.originalHeight, sourceWidth: r, sourceHeight: i, destinationWidth: r, destinationHeight: i, context: p, sourceTexture: this.createTexture(p, r, i, !f && c), targetTexture: this.createTexture(p, r, i), originalTexture: f || this.createTexture(p, r, i, !f && c), passes: l.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: n }, y = p.createFramebuffer(); return p.bindFramebuffer(p.FRAMEBUFFER, y), l.forEach(function (C) { C && C.applyTo(m) }), k(m), this.copyGLTo2D(p, m), p.bindTexture(p.TEXTURE_2D, null), p.deleteTexture(m.sourceTexture), p.deleteTexture(m.targetTexture), p.deleteFramebuffer(y), n.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), m }, dispose: function () { this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches() }, clearWebGLCaches: function () { this.programCache = {}, this.textureCache = {} }, createTexture: function (l, c, r, i, n) { var o = l.createTexture(); return l.bindTexture(l.TEXTURE_2D, o), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, n || l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, n || l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), i ? l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, l.RGBA, l.UNSIGNED_BYTE, i) : l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, c, r, 0, l.RGBA, l.UNSIGNED_BYTE, null), o }, getCachedTexture: function (l, c) { if (this.textureCache[l]) return this.textureCache[l]; var r = this.createTexture(this.gl, c.width, c.height, c); return this.textureCache[l] = r, r }, evictCachesForKey: function (l) { this.textureCache[l] && (this.gl.deleteTexture(this.textureCache[l]), delete this.textureCache[l]) }, copyGLTo2D: _, captureGPUInfo: function () { if (this.gpuInfo) return this.gpuInfo; var l = this.gl, c = { renderer: "", vendor: "" }; if (!l) return c; var r = l.getExtension("WEBGL_debug_renderer_info"); if (r) { var i = l.getParameter(r.UNMASKED_RENDERER_WEBGL), n = l.getParameter(r.UNMASKED_VENDOR_WEBGL); i && (c.renderer = i.toLowerCase()), n && (c.vendor = n.toLowerCase()) } return this.gpuInfo = c, c } }
}(); function k(d) { var a = d.targetCanvas, l = a.width, c = a.height, r = d.destinationWidth, i = d.destinationHeight; (l !== r || c !== i) && (a.width = r, a.height = i) } function _(d, a) { var l = d.canvas, c = a.targetCanvas, r = c.getContext("2d"); r.translate(0, c.height), r.scale(1, -1); var i = l.height - c.height; r.drawImage(l, 0, i, c.width, c.height, 0, 0, c.width, c.height) } function S(d, a) { var l = a.targetCanvas, c = l.getContext("2d"), r = a.destinationWidth, i = a.destinationHeight, n = r * i * 4, o = new Uint8Array(this.imageBuffer, 0, n), p = new Uint8ClampedArray(this.imageBuffer, 0, n); d.readPixels(0, 0, r, i, d.RGBA, d.UNSIGNED_BYTE, o); var f = new ImageData(p, r, i); c.putImageData(f, 0, 0) } (function () { var d = function () { }; h.Canvas2dFilterBackend = a; function a() { } a.prototype = { evictCachesForKey: d, dispose: d, clearWebGLCaches: d, resources: {}, applyFilters: function (l, c, r, i, n) { var o = n.getContext("2d"); o.drawImage(c, 0, 0, r, i); var p = o.getImageData(0, 0, r, i), f = o.getImageData(0, 0, r, i), m = { sourceWidth: r, sourceHeight: i, imageData: p, originalEl: c, originalImageData: f, canvasEl: n, ctx: o, filterBackend: this }; return l.forEach(function (y) { y.applyTo(m) }), (m.imageData.width !== r || m.imageData.height !== i) && (n.width = m.imageData.width, n.height = m.imageData.height), o.putImageData(m.imageData, 0, 0), m } } })(), h.Image = h.Image || {}, h.Image.filters = h.Image.filters || {}, h.Image.filters.BaseFilter = h.util.createClass({
  type: "BaseFilter", vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
void main() {
vTexCoord = aPosition;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D uTexture;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
}`, initialize: function (d) { d && this.setOptions(d) }, setOptions: function (d) { for (var a in d) this[a] = d[a] }, createProgram: function (d, a, l) { a = a || this.fragmentSource, l = l || this.vertexSource, h.webGlPrecision !== "highp" && (a = a.replace(/precision highp float/g, "precision " + h.webGlPrecision + " float")); var c = d.createShader(d.VERTEX_SHADER); if (d.shaderSource(c, l), d.compileShader(c), !d.getShaderParameter(c, d.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + d.getShaderInfoLog(c)); var r = d.createShader(d.FRAGMENT_SHADER); if (d.shaderSource(r, a), d.compileShader(r), !d.getShaderParameter(r, d.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + d.getShaderInfoLog(r)); var i = d.createProgram(); if (d.attachShader(i, c), d.attachShader(i, r), d.linkProgram(i), !d.getProgramParameter(i, d.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + d.getProgramInfoLog(i)); var n = this.getAttributeLocations(d, i), o = this.getUniformLocations(d, i) || {}; return o.uStepW = d.getUniformLocation(i, "uStepW"), o.uStepH = d.getUniformLocation(i, "uStepH"), { program: i, attributeLocations: n, uniformLocations: o } }, getAttributeLocations: function (d, a) { return { aPosition: d.getAttribLocation(a, "aPosition") } }, getUniformLocations: function () { return {} }, sendAttributeData: function (d, a, l) { var c = a.aPosition, r = d.createBuffer(); d.bindBuffer(d.ARRAY_BUFFER, r), d.enableVertexAttribArray(c), d.vertexAttribPointer(c, 2, d.FLOAT, !1, 0, 0), d.bufferData(d.ARRAY_BUFFER, l, d.STATIC_DRAW) }, _setupFrameBuffer: function (d) { var a = d.context, l, c; d.passes > 1 ? (l = d.destinationWidth, c = d.destinationHeight, (d.sourceWidth !== l || d.sourceHeight !== c) && (a.deleteTexture(d.targetTexture), d.targetTexture = d.filterBackend.createTexture(a, l, c)), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, d.targetTexture, 0)) : (a.bindFramebuffer(a.FRAMEBUFFER, null), a.finish()) }, _swapTextures: function (d) { d.passes--, d.pass++; var a = d.targetTexture; d.targetTexture = d.sourceTexture, d.sourceTexture = a }, isNeutralState: function () { var d = this.mainParameter, a = h.Image.filters[this.type].prototype; if (d) if (Array.isArray(a[d])) { for (var l = a[d].length; l--;)if (this[d][l] !== a[d][l]) return !1; return !0 } else return a[d] === this[d]; else return !1 }, applyTo: function (d) { d.webgl ? (this._setupFrameBuffer(d), this.applyToWebGL(d), this._swapTextures(d)) : this.applyTo2d(d) }, retrieveShader: function (d) { return d.programCache.hasOwnProperty(this.type) || (d.programCache[this.type] = this.createProgram(d.context)), d.programCache[this.type] }, applyToWebGL: function (d) { var a = d.context, l = this.retrieveShader(d); d.pass === 0 && d.originalTexture ? a.bindTexture(a.TEXTURE_2D, d.originalTexture) : a.bindTexture(a.TEXTURE_2D, d.sourceTexture), a.useProgram(l.program), this.sendAttributeData(a, l.attributeLocations, d.aPosition), a.uniform1f(l.uniformLocations.uStepW, 1 / d.sourceWidth), a.uniform1f(l.uniformLocations.uStepH, 1 / d.sourceHeight), this.sendUniformData(a, l.uniformLocations), a.viewport(0, 0, d.destinationWidth, d.destinationHeight), a.drawArrays(a.TRIANGLE_STRIP, 0, 4) }, bindAdditionalTexture: function (d, a, l) { d.activeTexture(l), d.bindTexture(d.TEXTURE_2D, a), d.activeTexture(d.TEXTURE0) }, unbindAdditionalTexture: function (d, a) { d.activeTexture(a), d.bindTexture(d.TEXTURE_2D, null), d.activeTexture(d.TEXTURE0) }, getMainParameter: function () { return this[this.mainParameter] }, setMainParameter: function (d) { this[this.mainParameter] = d }, sendUniformData: function () { }, createHelpLayer: function (d) { if (!d.helpLayer) { var a = document.createElement("canvas"); a.width = d.sourceWidth, a.height = d.sourceHeight, d.helpLayer = a } }, toObject: function () { var d = { type: this.type }, a = this.mainParameter; return a && (d[a] = this[a]), d }, toJSON: function () { return this.toObject() }
}), h.Image.filters.BaseFilter.fromObject = function (d, a) { var l = new h.Image.filters[d.type](d); return a && a(l), l }, function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.ColorMatrix = c(l.BaseFilter, {
    type: "ColorMatrix", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
uniform mat4 uColorMatrix;
uniform vec4 uConstants;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color *= uColorMatrix;
color += uConstants;
gl_FragColor = color;
}`, matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: !0, initialize: function (r) { this.callSuper("initialize", r), this.matrix = this.matrix.slice(0) }, applyTo2d: function (r) { var i = r.imageData, n = i.data, o = n.length, p = this.matrix, f, m, y, C, x, I = this.colorsOnly; for (x = 0; x < o; x += 4)f = n[x], m = n[x + 1], y = n[x + 2], I ? (n[x] = f * p[0] + m * p[1] + y * p[2] + p[4] * 255, n[x + 1] = f * p[5] + m * p[6] + y * p[7] + p[9] * 255, n[x + 2] = f * p[10] + m * p[11] + y * p[12] + p[14] * 255) : (C = n[x + 3], n[x] = f * p[0] + m * p[1] + y * p[2] + C * p[3] + p[4] * 255, n[x + 1] = f * p[5] + m * p[6] + y * p[7] + C * p[8] + p[9] * 255, n[x + 2] = f * p[10] + m * p[11] + y * p[12] + C * p[13] + p[14] * 255, n[x + 3] = f * p[15] + m * p[16] + y * p[17] + C * p[18] + p[19] * 255) }, getUniformLocations: function (r, i) { return { uColorMatrix: r.getUniformLocation(i, "uColorMatrix"), uConstants: r.getUniformLocation(i, "uConstants") } }, sendUniformData: function (r, i) { var n = this.matrix, o = [n[0], n[1], n[2], n[3], n[5], n[6], n[7], n[8], n[10], n[11], n[12], n[13], n[15], n[16], n[17], n[18]], p = [n[4], n[9], n[14], n[19]]; r.uniformMatrix4fv(i.uColorMatrix, !1, o), r.uniform4fv(i.uConstants, p) }
  }), a.Image.filters.ColorMatrix.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Brightness = c(l.BaseFilter, {
    type: "Brightness", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBrightness;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += uBrightness;
gl_FragColor = color;
}`, brightness: 0, mainParameter: "brightness", applyTo2d: function (r) { if (this.brightness !== 0) { var i = r.imageData, n = i.data, o, p = n.length, f = Math.round(this.brightness * 255); for (o = 0; o < p; o += 4)n[o] = n[o] + f, n[o + 1] = n[o + 1] + f, n[o + 2] = n[o + 2] + f } }, getUniformLocations: function (r, i) { return { uBrightness: r.getUniformLocation(i, "uBrightness") } }, sendUniformData: function (r, i) { r.uniform1f(i.uBrightness, this.brightness) }
  }), a.Image.filters.Brightness.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.Image.filters, r = a.util.createClass; c.Convolute = r(c.BaseFilter, {
    type: "Convolute", opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0], fragmentSource: {
      Convolute_3_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_3_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_5_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_5_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_7_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_7_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_9_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_9_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`}, retrieveShader: function (i) { var n = Math.sqrt(this.matrix.length), o = this.type + "_" + n + "_" + (this.opaque ? 1 : 0), p = this.fragmentSource[o]; return i.programCache.hasOwnProperty(o) || (i.programCache[o] = this.createProgram(i.context, p)), i.programCache[o] }, applyTo2d: function (i) { var n = i.imageData, o = n.data, p = this.matrix, f = Math.round(Math.sqrt(p.length)), m = Math.floor(f / 2), y = n.width, C = n.height, x = i.ctx.createImageData(y, C), I = x.data, D = this.opaque ? 1 : 0, P, z, et, tt, st, dt, q, ct, W, Dt, Lt, it, O; for (Lt = 0; Lt < C; Lt++)for (Dt = 0; Dt < y; Dt++) { for (st = (Lt * y + Dt) * 4, P = 0, z = 0, et = 0, tt = 0, O = 0; O < f; O++)for (it = 0; it < f; it++)q = Lt + O - m, dt = Dt + it - m, !(q < 0 || q >= C || dt < 0 || dt >= y) && (ct = (q * y + dt) * 4, W = p[O * f + it], P += o[ct] * W, z += o[ct + 1] * W, et += o[ct + 2] * W, D || (tt += o[ct + 3] * W)); I[st] = P, I[st + 1] = z, I[st + 2] = et, D ? I[st + 3] = o[st + 3] : I[st + 3] = tt } i.imageData = x }, getUniformLocations: function (i, n) { return { uMatrix: i.getUniformLocation(n, "uMatrix"), uOpaque: i.getUniformLocation(n, "uOpaque"), uHalfSize: i.getUniformLocation(n, "uHalfSize"), uSize: i.getUniformLocation(n, "uSize") } }, sendUniformData: function (i, n) { i.uniform1fv(n.uMatrix, this.matrix) }, toObject: function () { return l(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix }) }
  }), a.Image.filters.Convolute.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Grayscale = c(l.BaseFilter, {
    type: "Grayscale", fragmentSource: {
      average: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float average = (color.r + color.b + color.g) / 3.0;
gl_FragColor = vec4(average, average, average, color.a);
}`, lightness: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
gl_FragColor = vec4(average, average, average, col.a);
}`, luminosity: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
gl_FragColor = vec4(average, average, average, col.a);
}`}, mode: "average", mainParameter: "mode", applyTo2d: function (r) { var i = r.imageData, n = i.data, o, p = n.length, f, m = this.mode; for (o = 0; o < p; o += 4)m === "average" ? f = (n[o] + n[o + 1] + n[o + 2]) / 3 : m === "lightness" ? f = (Math.min(n[o], n[o + 1], n[o + 2]) + Math.max(n[o], n[o + 1], n[o + 2])) / 2 : m === "luminosity" && (f = .21 * n[o] + .72 * n[o + 1] + .07 * n[o + 2]), n[o] = f, n[o + 1] = f, n[o + 2] = f }, retrieveShader: function (r) { var i = this.type + "_" + this.mode; if (!r.programCache.hasOwnProperty(i)) { var n = this.fragmentSource[this.mode]; r.programCache[i] = this.createProgram(r.context, n) } return r.programCache[i] }, getUniformLocations: function (r, i) { return { uMode: r.getUniformLocation(i, "uMode") } }, sendUniformData: function (r, i) { var n = 1; r.uniform1i(i.uMode, n) }, isNeutralState: function () { return !1 }
  }), a.Image.filters.Grayscale.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Invert = c(l.BaseFilter, {
    type: "Invert", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform int uInvert;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
if (uInvert == 1) {
gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
} else {
gl_FragColor = color;
}
}`, invert: !0, mainParameter: "invert", applyTo2d: function (r) { var i = r.imageData, n = i.data, o, p = n.length; for (o = 0; o < p; o += 4)n[o] = 255 - n[o], n[o + 1] = 255 - n[o + 1], n[o + 2] = 255 - n[o + 2] }, isNeutralState: function () { return !this.invert }, getUniformLocations: function (r, i) { return { uInvert: r.getUniformLocation(i, "uInvert") } }, sendUniformData: function (r, i) { r.uniform1i(i.uInvert, this.invert) }
  }), a.Image.filters.Invert.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.Image.filters, r = a.util.createClass; c.Noise = r(c.BaseFilter, {
    type: "Noise", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uStepH;
uniform float uNoise;
uniform float uSeed;
varying vec2 vTexCoord;
float rand(vec2 co, float seed, float vScale) {
return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
}
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
gl_FragColor = color;
}`, mainParameter: "noise", noise: 0, applyTo2d: function (i) { if (this.noise !== 0) { var n = i.imageData, o = n.data, p, f = o.length, m = this.noise, y; for (p = 0, f = o.length; p < f; p += 4)y = (.5 - Math.random()) * m, o[p] += y, o[p + 1] += y, o[p + 2] += y } }, getUniformLocations: function (i, n) { return { uNoise: i.getUniformLocation(n, "uNoise"), uSeed: i.getUniformLocation(n, "uSeed") } }, sendUniformData: function (i, n) { i.uniform1f(n.uNoise, this.noise / 255), i.uniform1f(n.uSeed, Math.random()) }, toObject: function () { return l(this.callSuper("toObject"), { noise: this.noise }) }
  }), a.Image.filters.Noise.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Pixelate = c(l.BaseFilter, {
    type: "Pixelate", blocksize: 4, mainParameter: "blocksize", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBlocksize;
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
float blockW = uBlocksize * uStepW;
float blockH = uBlocksize * uStepW;
int posX = int(vTexCoord.x / blockW);
int posY = int(vTexCoord.y / blockH);
float fposX = float(posX);
float fposY = float(posY);
vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
vec4 color = texture2D(uTexture, squareCoords);
gl_FragColor = color;
}`, applyTo2d: function (r) { var i = r.imageData, n = i.data, o = i.height, p = i.width, f, m, y, C, x, I, D, P, z, et, tt; for (m = 0; m < o; m += this.blocksize)for (y = 0; y < p; y += this.blocksize)for (f = m * 4 * p + y * 4, C = n[f], x = n[f + 1], I = n[f + 2], D = n[f + 3], et = Math.min(m + this.blocksize, o), tt = Math.min(y + this.blocksize, p), P = m; P < et; P++)for (z = y; z < tt; z++)f = P * 4 * p + z * 4, n[f] = C, n[f + 1] = x, n[f + 2] = I, n[f + 3] = D }, isNeutralState: function () { return this.blocksize === 1 }, getUniformLocations: function (r, i) { return { uBlocksize: r.getUniformLocation(i, "uBlocksize"), uStepW: r.getUniformLocation(i, "uStepW"), uStepH: r.getUniformLocation(i, "uStepH") } }, sendUniformData: function (r, i) { r.uniform1f(i.uBlocksize, this.blocksize) }
  }), a.Image.filters.Pixelate.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.extend, c = a.Image.filters, r = a.util.createClass; c.RemoveColor = r(c.BaseFilter, {
    type: "RemoveColor", color: "#FFFFFF", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
gl_FragColor.a = 0.0;
}
}`, distance: .02, useAlpha: !1, applyTo2d: function (i) { var n = i.imageData, o = n.data, p, f = this.distance * 255, m, y, C, x = new a.Color(this.color).getSource(), I = [x[0] - f, x[1] - f, x[2] - f], D = [x[0] + f, x[1] + f, x[2] + f]; for (p = 0; p < o.length; p += 4)m = o[p], y = o[p + 1], C = o[p + 2], m > I[0] && y > I[1] && C > I[2] && m < D[0] && y < D[1] && C < D[2] && (o[p + 3] = 0) }, getUniformLocations: function (i, n) { return { uLow: i.getUniformLocation(n, "uLow"), uHigh: i.getUniformLocation(n, "uHigh") } }, sendUniformData: function (i, n) { var o = new a.Color(this.color).getSource(), p = parseFloat(this.distance), f = [0 + o[0] / 255 - p, 0 + o[1] / 255 - p, 0 + o[2] / 255 - p, 1], m = [o[0] / 255 + p, o[1] / 255 + p, o[2] / 255 + p, 1]; i.uniform4fv(n.uLow, f), i.uniform4fv(n.uHigh, m) }, toObject: function () { return l(this.callSuper("toObject"), { color: this.color, distance: this.distance }) }
  }), a.Image.filters.RemoveColor.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) { var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass, r = { Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0], Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0], Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0], Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0], Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0], BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0] }; for (var i in r) l[i] = c(l.ColorMatrix, { type: i, matrix: r[i], mainParameter: !1, colorsOnly: !0 }), a.Image.filters[i].fromObject = a.Image.filters.BaseFilter.fromObject }(v), function (d) {
  var a = d.fabric, l = a.Image.filters, c = a.util.createClass; l.BlendColor = c(l.BaseFilter, {
    type: "BlendColor", color: "#F95C63", mode: "multiply", alpha: 1, fragmentSource: {
      multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, diff: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `if (uColor.r < 0.5) {
gl_FragColor.r *= 2.0 * uColor.r;
} else {
gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
}
if (uColor.g < 0.5) {
gl_FragColor.g *= 2.0 * uColor.g;
} else {
gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
}
if (uColor.b < 0.5) {
gl_FragColor.b *= 2.0 * uColor.b;
} else {
gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
}
`, tint: `gl_FragColor.rgb *= (1.0 - uColor.a);
gl_FragColor.rgb += uColor.rgb;
`}, buildSource: function (r) {
      return `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uColor;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
gl_FragColor = color;
if (color.a > 0.0) {
`+ this.fragmentSource[r] + `}
}`}, retrieveShader: function (r) { var i = this.type + "_" + this.mode, n; return r.programCache.hasOwnProperty(i) || (n = this.buildSource(this.mode), r.programCache[i] = this.createProgram(r.context, n)), r.programCache[i] }, applyTo2d: function (r) { var i = r.imageData, n = i.data, o = n.length, p, f, m, y, C, x, I, D = 1 - this.alpha; I = new a.Color(this.color).getSource(), p = I[0] * this.alpha, f = I[1] * this.alpha, m = I[2] * this.alpha; for (var P = 0; P < o; P += 4)switch (y = n[P], C = n[P + 1], x = n[P + 2], this.mode) { case "multiply": n[P] = y * p / 255, n[P + 1] = C * f / 255, n[P + 2] = x * m / 255; break; case "screen": n[P] = 255 - (255 - y) * (255 - p) / 255, n[P + 1] = 255 - (255 - C) * (255 - f) / 255, n[P + 2] = 255 - (255 - x) * (255 - m) / 255; break; case "add": n[P] = y + p, n[P + 1] = C + f, n[P + 2] = x + m; break; case "diff": case "difference": n[P] = Math.abs(y - p), n[P + 1] = Math.abs(C - f), n[P + 2] = Math.abs(x - m); break; case "subtract": n[P] = y - p, n[P + 1] = C - f, n[P + 2] = x - m; break; case "darken": n[P] = Math.min(y, p), n[P + 1] = Math.min(C, f), n[P + 2] = Math.min(x, m); break; case "lighten": n[P] = Math.max(y, p), n[P + 1] = Math.max(C, f), n[P + 2] = Math.max(x, m); break; case "overlay": n[P] = p < 128 ? 2 * y * p / 255 : 255 - 2 * (255 - y) * (255 - p) / 255, n[P + 1] = f < 128 ? 2 * C * f / 255 : 255 - 2 * (255 - C) * (255 - f) / 255, n[P + 2] = m < 128 ? 2 * x * m / 255 : 255 - 2 * (255 - x) * (255 - m) / 255; break; case "exclusion": n[P] = p + y - 2 * p * y / 255, n[P + 1] = f + C - 2 * f * C / 255, n[P + 2] = m + x - 2 * m * x / 255; break; case "tint": n[P] = p + y * D, n[P + 1] = f + C * D, n[P + 2] = m + x * D } }, getUniformLocations: function (r, i) { return { uColor: r.getUniformLocation(i, "uColor") } }, sendUniformData: function (r, i) { var n = new a.Color(this.color).getSource(); n[0] = this.alpha * n[0] / 255, n[1] = this.alpha * n[1] / 255, n[2] = this.alpha * n[2] / 255, n[3] = this.alpha, r.uniform4fv(i.uColor, n) }, toObject: function () { return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha } }
  }), a.Image.filters.BlendColor.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric, l = a.Image.filters, c = a.util.createClass; l.BlendImage = c(l.BaseFilter, {
    type: "BlendImage", image: null, mode: "multiply", alpha: 1, vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
uniform mat3 uTransformMatrix;
void main() {
vTexCoord = aPosition;
vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: {
      multiply: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.rgba *= color2.rgba;
gl_FragColor = color;
}`, mask: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.a = color2.a;
gl_FragColor = color;
}`}, retrieveShader: function (r) { var i = this.type + "_" + this.mode, n = this.fragmentSource[this.mode]; return r.programCache.hasOwnProperty(i) || (r.programCache[i] = this.createProgram(r.context, n)), r.programCache[i] }, applyToWebGL: function (r) { var i = r.context, n = this.createTexture(r.filterBackend, this.image); this.bindAdditionalTexture(i, n, i.TEXTURE1), this.callSuper("applyToWebGL", r), this.unbindAdditionalTexture(i, i.TEXTURE1) }, createTexture: function (r, i) { return r.getCachedTexture(i.cacheKey, i._element) }, calculateMatrix: function () { var r = this.image, i = r._element.width, n = r._element.height; return [1 / r.scaleX, 0, 0, 0, 1 / r.scaleY, 0, -r.left / i, -r.top / n, 1] }, applyTo2d: function (r) { var i = r.imageData, n = r.filterBackend.resources, o = i.data, p = o.length, f = i.width, m = i.height, y, C, x, I, D, P, z, et, tt, st, dt = this.image, q; n.blendImage || (n.blendImage = a.util.createCanvasElement()), tt = n.blendImage, st = tt.getContext("2d"), tt.width !== f || tt.height !== m ? (tt.width = f, tt.height = m) : st.clearRect(0, 0, f, m), st.setTransform(dt.scaleX, 0, 0, dt.scaleY, dt.left, dt.top), st.drawImage(dt._element, 0, 0, f, m), q = st.getImageData(0, 0, f, m).data; for (var ct = 0; ct < p; ct += 4)switch (D = o[ct], P = o[ct + 1], z = o[ct + 2], et = o[ct + 3], y = q[ct], C = q[ct + 1], x = q[ct + 2], I = q[ct + 3], this.mode) { case "multiply": o[ct] = D * y / 255, o[ct + 1] = P * C / 255, o[ct + 2] = z * x / 255, o[ct + 3] = et * I / 255; break; case "mask": o[ct + 3] = I; break } }, getUniformLocations: function (r, i) { return { uTransformMatrix: r.getUniformLocation(i, "uTransformMatrix"), uImage: r.getUniformLocation(i, "uImage") } }, sendUniformData: function (r, i) { var n = this.calculateMatrix(); r.uniform1i(i.uImage, 1), r.uniformMatrix3fv(i.uTransformMatrix, !1, n) }, toObject: function () { return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha } }
  }), a.Image.filters.BlendImage.fromObject = function (r, i) { a.Image.fromObject(r.image, function (n) { var o = a.util.object.clone(r); o.image = n, i(new a.Image.filters.BlendImage(o)) }) }
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = Math.pow, c = Math.floor, r = Math.sqrt, i = Math.abs, n = Math.round, o = Math.sin, p = Math.ceil, f = a.Image.filters, m = a.util.createClass; f.Resize = m(f.BaseFilter, {
    type: "Resize", resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, getUniformLocations: function (y, C) { return { uDelta: y.getUniformLocation(C, "uDelta"), uTaps: y.getUniformLocation(C, "uTaps") } }, sendUniformData: function (y, C) { y.uniform2fv(C.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), y.uniform1fv(C.uTaps, this.taps) }, retrieveShader: function (y) { var C = this.getFilterWindow(), x = this.type + "_" + C; if (!y.programCache.hasOwnProperty(x)) { var I = this.generateShader(C); y.programCache[x] = this.createProgram(y.context, I) } return y.programCache[x] }, getFilterWindow: function () { var y = this.tempScale; return Math.ceil(this.lanczosLobes / y) }, getTaps: function () { for (var y = this.lanczosCreate(this.lanczosLobes), C = this.tempScale, x = this.getFilterWindow(), I = new Array(x), D = 1; D <= x; D++)I[D - 1] = y(D * C); return I }, generateShader: function (I) {
      for (var C = new Array(I), x = this.fragmentSourceTOP, I, D = 1; D <= I; D++)C[D - 1] = D + ".0 * uDelta"; return x += "uniform float uTaps[" + I + `];
`, x += `void main() {
`, x += `  vec4 color = texture2D(uTexture, vTexCoord);
`, x += `  float sum = 1.0;
`, C.forEach(function (P, z) {
        x += "  color += texture2D(uTexture, vTexCoord + " + P + ") * uTaps[" + z + `];
`, x += "  color += texture2D(uTexture, vTexCoord - " + P + ") * uTaps[" + z + `];
`, x += "  sum += 2.0 * uTaps[" + z + `];
`}), x += `  gl_FragColor = color / sum;
`, x += "}", x
    }, fragmentSourceTOP: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
`, applyTo: function (y) { y.webgl ? (y.passes++, this.width = y.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = y.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), y.destinationWidth = this.dW, this._setupFrameBuffer(y), this.applyToWebGL(y), this._swapTextures(y), y.sourceWidth = y.destinationWidth, this.height = y.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), y.destinationHeight = this.dH, this._setupFrameBuffer(y), this.applyToWebGL(y), this._swapTextures(y), y.sourceHeight = y.destinationHeight) : this.applyTo2d(y) }, isNeutralState: function () { return this.scaleX === 1 && this.scaleY === 1 }, lanczosCreate: function (y) { return function (C) { if (C >= y || C <= -y) return 0; if (C < 11920929e-14 && C > -11920929e-14) return 1; C *= Math.PI; var x = C / y; return o(C) / C * o(x) / x } }, applyTo2d: function (y) { var C = y.imageData, x = this.scaleX, I = this.scaleY; this.rcpScaleX = 1 / x, this.rcpScaleY = 1 / I; var D = C.width, P = C.height, z = n(D * x), et = n(P * I), tt; this.resizeType === "sliceHack" ? tt = this.sliceByTwo(y, D, P, z, et) : this.resizeType === "hermite" ? tt = this.hermiteFastResize(y, D, P, z, et) : this.resizeType === "bilinear" ? tt = this.bilinearFiltering(y, D, P, z, et) : this.resizeType === "lanczos" && (tt = this.lanczosResize(y, D, P, z, et)), y.imageData = tt }, sliceByTwo: function (y, C, x, I, D) { var P = y.imageData, z = .5, et = !1, tt = !1, st = C * z, dt = x * z, q = a.filterBackend.resources, ct, W, Dt = 0, Lt = 0, it = C, O = 0; for (q.sliceByTwo || (q.sliceByTwo = document.createElement("canvas")), ct = q.sliceByTwo, (ct.width < C * 1.5 || ct.height < x) && (ct.width = C * 1.5, ct.height = x), W = ct.getContext("2d"), W.clearRect(0, 0, C * 1.5, x), W.putImageData(P, 0, 0), I = c(I), D = c(D); !et || !tt;)C = st, x = dt, I < c(st * z) ? st = c(st * z) : (st = I, et = !0), D < c(dt * z) ? dt = c(dt * z) : (dt = D, tt = !0), W.drawImage(ct, Dt, Lt, C, x, it, O, st, dt), Dt = it, Lt = O, O += dt; return W.getImageData(Dt, Lt, I, D) }, lanczosResize: function (y, C, x, I, D) { function P(G) { var U, lt, H, R, K, J, ht, ut, _t, mt, St; for (O.x = (G + .5) * dt, V.x = c(O.x), U = 0; U < D; U++) { for (O.y = (U + .5) * q, V.y = c(O.y), K = 0, J = 0, ht = 0, ut = 0, _t = 0, lt = V.x - Dt; lt <= V.x + Dt; lt++)if (!(lt < 0 || lt >= C)) { mt = c(1e3 * i(lt - O.x)), it[mt] || (it[mt] = {}); for (var gt = V.y - Lt; gt <= V.y + Lt; gt++)gt < 0 || gt >= x || (St = c(1e3 * i(gt - O.y)), it[mt][St] || (it[mt][St] = st(r(l(mt * ct, 2) + l(St * W, 2)) / 1e3)), H = it[mt][St], H > 0 && (R = (gt * C + lt) * 4, K += H, J += H * z[R], ht += H * z[R + 1], ut += H * z[R + 2], _t += H * z[R + 3])) } R = (U * I + G) * 4, tt[R] = J / K, tt[R + 1] = ht / K, tt[R + 2] = ut / K, tt[R + 3] = _t / K } return ++G < I ? P(G) : et } var z = y.imageData.data, et = y.ctx.createImageData(I, D), tt = et.data, st = this.lanczosCreate(this.lanczosLobes), dt = this.rcpScaleX, q = this.rcpScaleY, ct = 2 / this.rcpScaleX, W = 2 / this.rcpScaleY, Dt = p(dt * this.lanczosLobes / 2), Lt = p(q * this.lanczosLobes / 2), it = {}, O = {}, V = {}; return P(0) }, bilinearFiltering: function (y, C, x, I, D) { var P, z, et, tt, st, dt, q, ct, W, Dt, Lt, it, O = 0, V, G = this.rcpScaleX, U = this.rcpScaleY, lt = 4 * (C - 1), H = y.imageData, R = H.data, K = y.ctx.createImageData(I, D), J = K.data; for (q = 0; q < D; q++)for (ct = 0; ct < I; ct++)for (st = c(G * ct), dt = c(U * q), W = G * ct - st, Dt = U * q - dt, V = 4 * (dt * C + st), Lt = 0; Lt < 4; Lt++)P = R[V + Lt], z = R[V + 4 + Lt], et = R[V + lt + Lt], tt = R[V + lt + 4 + Lt], it = P * (1 - W) * (1 - Dt) + z * W * (1 - Dt) + et * Dt * (1 - W) + tt * W * Dt, J[O++] = it; return K }, hermiteFastResize: function (y, C, x, I, D) { for (var P = this.rcpScaleX, z = this.rcpScaleY, et = p(P / 2), tt = p(z / 2), st = y.imageData, dt = st.data, q = y.ctx.createImageData(I, D), ct = q.data, W = 0; W < D; W++)for (var Dt = 0; Dt < I; Dt++) { for (var Lt = (Dt + W * I) * 4, it = 0, O = 0, V = 0, G = 0, U = 0, lt = 0, H = 0, R = (W + .5) * z, K = c(W * z); K < (W + 1) * z; K++)for (var J = i(R - (K + .5)) / tt, ht = (Dt + .5) * P, ut = J * J, _t = c(Dt * P); _t < (Dt + 1) * P; _t++) { var mt = i(ht - (_t + .5)) / et, St = r(ut + mt * mt); St > 1 && St < -1 || (it = 2 * St * St * St - 3 * St * St + 1, it > 0 && (mt = 4 * (_t + K * C), H += it * dt[mt + 3], V += it, dt[mt + 3] < 255 && (it = it * dt[mt + 3] / 250), G += it * dt[mt], U += it * dt[mt + 1], lt += it * dt[mt + 2], O += it)) } ct[Lt] = G / O, ct[Lt + 1] = U / O, ct[Lt + 2] = lt / O, ct[Lt + 3] = H / V } return q }, toObject: function () { return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes } }
  }), a.Image.filters.Resize.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Contrast = c(l.BaseFilter, {
    type: "Contrast", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uContrast;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
gl_FragColor = color;
}`, contrast: 0, mainParameter: "contrast", applyTo2d: function (r) { if (this.contrast !== 0) { var i = r.imageData, n, p, o = i.data, p = o.length, f = Math.floor(this.contrast * 255), m = 259 * (f + 255) / (255 * (259 - f)); for (n = 0; n < p; n += 4)o[n] = m * (o[n] - 128) + 128, o[n + 1] = m * (o[n + 1] - 128) + 128, o[n + 2] = m * (o[n + 2] - 128) + 128 } }, getUniformLocations: function (r, i) { return { uContrast: r.getUniformLocation(i, "uContrast") } }, sendUniformData: function (r, i) { r.uniform1f(i.uContrast, this.contrast) }
  }), a.Image.filters.Contrast.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Saturation = c(l.BaseFilter, {
    type: "Saturation", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uSaturation;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float rgMax = max(color.r, color.g);
float rgbMax = max(rgMax, color.b);
color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
gl_FragColor = color;
}`, saturation: 0, mainParameter: "saturation", applyTo2d: function (r) { if (this.saturation !== 0) { var i = r.imageData, n = i.data, o = n.length, p = -this.saturation, f, m; for (f = 0; f < o; f += 4)m = Math.max(n[f], n[f + 1], n[f + 2]), n[f] += m !== n[f] ? (m - n[f]) * p : 0, n[f + 1] += m !== n[f + 1] ? (m - n[f + 1]) * p : 0, n[f + 2] += m !== n[f + 2] ? (m - n[f + 2]) * p : 0 } }, getUniformLocations: function (r, i) { return { uSaturation: r.getUniformLocation(i, "uSaturation") } }, sendUniformData: function (r, i) { r.uniform1f(i.uSaturation, -this.saturation) }
  }), a.Image.filters.Saturation.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Vibrance = c(l.BaseFilter, {
    type: "Vibrance", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uVibrance;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float max = max(color.r, max(color.g, color.b));
float avg = (color.r + color.g + color.b) / 3.0;
float amt = (abs(max - avg) * 2.0) * uVibrance;
color.r += max != color.r ? (max - color.r) * amt : 0.00;
color.g += max != color.g ? (max - color.g) * amt : 0.00;
color.b += max != color.b ? (max - color.b) * amt : 0.00;
gl_FragColor = color;
}`, vibrance: 0, mainParameter: "vibrance", applyTo2d: function (r) { if (this.vibrance !== 0) { var i = r.imageData, n = i.data, o = n.length, p = -this.vibrance, f, m, y, C; for (f = 0; f < o; f += 4)m = Math.max(n[f], n[f + 1], n[f + 2]), y = (n[f] + n[f + 1] + n[f + 2]) / 3, C = Math.abs(m - y) * 2 / 255 * p, n[f] += m !== n[f] ? (m - n[f]) * C : 0, n[f + 1] += m !== n[f + 1] ? (m - n[f + 1]) * C : 0, n[f + 2] += m !== n[f + 2] ? (m - n[f + 2]) * C : 0 } }, getUniformLocations: function (r, i) { return { uVibrance: r.getUniformLocation(i, "uVibrance") } }, sendUniformData: function (r, i) { r.uniform1f(i.uVibrance, -this.vibrance) }
  }), a.Image.filters.Vibrance.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Blur = c(l.BaseFilter, {
    type: "Blur", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
const float nSamples = 15.0;
vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
float random(vec3 scale) {
return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
}
void main() {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(v3offset);
for (float t = -nSamples; t <= nSamples; t++) {
float percent = (t + offset - 0.5) / nSamples;
float weight = 1.0 - abs(percent);
color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
total += weight;
}
gl_FragColor = color / total;
}`, blur: 0, mainParameter: "blur", applyTo: function (r) { r.webgl ? (this.aspectRatio = r.sourceWidth / r.sourceHeight, r.passes++, this._setupFrameBuffer(r), this.horizontal = !0, this.applyToWebGL(r), this._swapTextures(r), this._setupFrameBuffer(r), this.horizontal = !1, this.applyToWebGL(r), this._swapTextures(r)) : this.applyTo2d(r) }, applyTo2d: function (r) { r.imageData = this.simpleBlur(r) }, simpleBlur: function (r) { var i = r.filterBackend.resources, n, o, p = r.imageData.width, f = r.imageData.height; i.blurLayer1 || (i.blurLayer1 = a.util.createCanvasElement(), i.blurLayer2 = a.util.createCanvasElement()), n = i.blurLayer1, o = i.blurLayer2, (n.width !== p || n.height !== f) && (o.width = n.width = p, o.height = n.height = f); var m = n.getContext("2d"), y = o.getContext("2d"), C = 15, x, I, D, P, z = this.blur * .06 * .5; for (m.putImageData(r.imageData, 0, 0), y.clearRect(0, 0, p, f), P = -C; P <= C; P++)x = (Math.random() - .5) / 4, I = P / C, D = z * I * p + x, y.globalAlpha = 1 - Math.abs(I), y.drawImage(n, D, x), m.drawImage(o, 0, 0), y.globalAlpha = 1, y.clearRect(0, 0, o.width, o.height); for (P = -C; P <= C; P++)x = (Math.random() - .5) / 4, I = P / C, D = z * I * f + x, y.globalAlpha = 1 - Math.abs(I), y.drawImage(n, x, D), m.drawImage(o, 0, 0), y.globalAlpha = 1, y.clearRect(0, 0, o.width, o.height); r.ctx.drawImage(n, 0, 0); var et = r.ctx.getImageData(0, 0, n.width, n.height); return m.globalAlpha = 1, m.clearRect(0, 0, n.width, n.height), et }, getUniformLocations: function (r, i) { return { delta: r.getUniformLocation(i, "uDelta") } }, sendUniformData: function (r, i) { var n = this.chooseRightDelta(); r.uniform2fv(i.delta, n) }, chooseRightDelta: function () { var r = 1, i = [0, 0], n; return this.horizontal ? this.aspectRatio > 1 && (r = 1 / this.aspectRatio) : this.aspectRatio < 1 && (r = this.aspectRatio), n = r * this.blur * .12, this.horizontal ? i[0] = n : i[1] = n, i }
  }), l.Blur.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Gamma = c(l.BaseFilter, {
    type: "Gamma", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec3 uGamma;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec3 correction = (1.0 / uGamma);
color.r = pow(color.r, correction.r);
color.g = pow(color.g, correction.g);
color.b = pow(color.b, correction.b);
gl_FragColor = color;
gl_FragColor.rgb *= color.a;
}`, gamma: [1, 1, 1], mainParameter: "gamma", initialize: function (r) { this.gamma = [1, 1, 1], l.BaseFilter.prototype.initialize.call(this, r) }, applyTo2d: function (r) { var i = r.imageData, n = i.data, o = this.gamma, p = n.length, f = 1 / o[0], m = 1 / o[1], y = 1 / o[2], C; for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), C = 0, p = 256; C < p; C++)this.rVals[C] = Math.pow(C / 255, f) * 255, this.gVals[C] = Math.pow(C / 255, m) * 255, this.bVals[C] = Math.pow(C / 255, y) * 255; for (C = 0, p = n.length; C < p; C += 4)n[C] = this.rVals[n[C]], n[C + 1] = this.gVals[n[C + 1]], n[C + 2] = this.bVals[n[C + 2]] }, getUniformLocations: function (r, i) { return { uGamma: r.getUniformLocation(i, "uGamma") } }, sendUniformData: function (r, i) { r.uniform3fv(i.uGamma, this.gamma) }
  }), a.Image.filters.Gamma.fromObject = a.Image.filters.BaseFilter.fromObject
}(v), function (d) { var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.Composed = c(l.BaseFilter, { type: "Composed", subFilters: [], initialize: function (r) { this.callSuper("initialize", r), this.subFilters = this.subFilters.slice(0) }, applyTo: function (r) { r.passes += this.subFilters.length - 1, this.subFilters.forEach(function (i) { i.applyTo(r) }) }, toObject: function () { return a.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function (r) { return r.toObject() }) }) }, isNeutralState: function () { return !this.subFilters.some(function (r) { return !r.isNeutralState() }) } }), a.Image.filters.Composed.fromObject = function (r, i) { var n = r.subFilters || [], o = n.map(function (f) { return new a.Image.filters[f.type](f) }), p = new a.Image.filters.Composed({ subFilters: o }); return i && i(p), p } }(v), function (d) { var a = d.fabric || (d.fabric = {}), l = a.Image.filters, c = a.util.createClass; l.HueRotation = c(l.ColorMatrix, { type: "HueRotation", rotation: 0, mainParameter: "rotation", calculateMatrix: function () { var r = this.rotation * Math.PI, i = a.util.cos(r), n = a.util.sin(r), o = 1 / 3, p = Math.sqrt(o) * n, f = 1 - i; this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = i + f / 3, this.matrix[1] = o * f - p, this.matrix[2] = o * f + p, this.matrix[5] = o * f + p, this.matrix[6] = i + o * f, this.matrix[7] = o * f - p, this.matrix[10] = o * f - p, this.matrix[11] = o * f + p, this.matrix[12] = i + o * f }, isNeutralState: function (r) { return this.calculateMatrix(), l.BaseFilter.prototype.isNeutralState.call(this, r) }, applyTo: function (r) { this.calculateMatrix(), l.BaseFilter.prototype.applyTo.call(this, r) } }), a.Image.filters.HueRotation.fromObject = a.Image.filters.BaseFilter.fromObject }(v), function (d) {
  var a = d.fabric || (d.fabric = {}), l = a.util.object.clone; if (a.Text) { a.warn("fabric.Text is already defined"); return } var c = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" "); a.Text = a.util.createClass(a.Object, {
    _dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: "left", fontStyle: "normal", lineHeight: 1.16, superscript: { size: .6, baseline: -.35 }, subscript: { size: .6, baseline: .11 }, textBackgroundColor: "", stateProperties: a.Object.prototype.stateProperties.concat(c), cacheProperties: a.Object.prototype.cacheProperties.concat(c), stroke: null, shadow: null, path: null, pathStartOffset: 0, pathSide: "left", pathAlign: "baseline", _fontSizeFraction: .222, offsets: { underline: .1, linethrough: -.315, overline: -.88 }, _fontSizeMult: 1.13, charSpacing: 0, styles: null, _measuringContext: null, deltaY: 0, direction: "ltr", _styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"], __charBounds: [], CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, initialize: function (r, i) { this.styles = i ? i.styles || {} : {}, this.text = r, this.__skipDimension = !0, this.callSuper("initialize", i), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" }) }, setPathInfo: function () { var r = this.path; r && (r.segmentsInfo = a.util.getPathSegmentsInfo(r.path)) }, getMeasuringContext: function () { return a._measuringContext || (a._measuringContext = this.canvas && this.canvas.contextCache || a.util.createCanvasElement().getContext("2d")), a._measuringContext }, _splitText: function () { var r = this._splitTextIntoLines(this.text); return this.textLines = r.lines, this._textLines = r.graphemeLines, this._unwrappedTextLines = r._unwrappedLines, this._text = r.graphemeText, r }, initDimensions: function () { this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, enlargeSpaces: function () { for (var r, i, n, o, p, f, m, y = 0, C = this._textLines.length; y < C; y++)if (!(this.textAlign !== "justify" && (y === C - 1 || this.isEndOfWrapping(y))) && (o = 0, p = this._textLines[y], i = this.getLineWidth(y), i < this.width && (m = this.textLines[y].match(this._reSpacesAndTabs)))) { n = m.length, r = (this.width - i) / n; for (var x = 0, I = p.length; x <= I; x++)f = this.__charBounds[y][x], this._reSpaceAndTab.test(p[x]) ? (f.width += r, f.kernedWidth += r, f.left += o, o += r) : f.left += o } }, isEndOfWrapping: function (r) { return r === this._textLines.length - 1 }, missingNewlineOffset: function () { return 1 }, toString: function () { return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>' }, _getCacheCanvasDimensions: function () { var r = this.callSuper("_getCacheCanvasDimensions"), i = this.fontSize; return r.width += i * r.zoomX, r.height += i * r.zoomY, r }, _render: function (r) { var i = this.path; i && !i.isNotVisible() && i._render(r), this._setTextStyles(r), this._renderTextLinesBackground(r), this._renderTextDecoration(r, "underline"), this._renderText(r), this._renderTextDecoration(r, "overline"), this._renderTextDecoration(r, "linethrough") }, _renderText: function (r) { this.paintFirst === "stroke" ? (this._renderTextStroke(r), this._renderTextFill(r)) : (this._renderTextFill(r), this._renderTextStroke(r)) }, _setTextStyles: function (r, i, n) { if (r.textBaseline = "alphabetical", this.path) switch (this.pathAlign) { case "center": r.textBaseline = "middle"; break; case "ascender": r.textBaseline = "top"; break; case "descender": r.textBaseline = "bottom"; break }r.font = this._getFontDeclaration(i, n) }, calcTextWidth: function () { for (var r = this.getLineWidth(0), i = 1, n = this._textLines.length; i < n; i++) { var o = this.getLineWidth(i); o > r && (r = o) } return r }, _renderTextLine: function (r, i, n, o, p, f) { this._renderChars(r, i, n, o, p, f) }, _renderTextLinesBackground: function (r) { if (!(!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))) { for (var i, n, o = r.fillStyle, p, f, m = this._getLeftOffset(), y = this._getTopOffset(), C = 0, x = 0, I, D, P = this.path, z, et = 0, tt = this._textLines.length; et < tt; et++) { if (i = this.getHeightOfLine(et), !this.textBackgroundColor && !this.styleHas("textBackgroundColor", et)) { y += i; continue } p = this._textLines[et], n = this._getLineLeftOffset(et), x = 0, C = 0, f = this.getValueOfPropertyAt(et, 0, "textBackgroundColor"); for (var st = 0, dt = p.length; st < dt; st++)I = this.__charBounds[et][st], D = this.getValueOfPropertyAt(et, st, "textBackgroundColor"), P ? (r.save(), r.translate(I.renderLeft, I.renderTop), r.rotate(I.angle), r.fillStyle = D, D && r.fillRect(-I.width / 2, -i / this.lineHeight * (1 - this._fontSizeFraction), I.width, i / this.lineHeight), r.restore()) : D !== f ? (z = m + n + C, this.direction === "rtl" && (z = this.width - z - x), r.fillStyle = f, f && r.fillRect(z, y, x, i / this.lineHeight), C = I.left, x = I.width, f = D) : x += I.kernedWidth; D && !P && (z = m + n + C, this.direction === "rtl" && (z = this.width - z - x), r.fillStyle = D, r.fillRect(z, y, x, i / this.lineHeight)), y += i } r.fillStyle = o, this._removeShadow(r) } }, getFontCache: function (r) { var i = r.fontFamily.toLowerCase(); a.charWidthsCache[i] || (a.charWidthsCache[i] = {}); var n = a.charWidthsCache[i], o = r.fontStyle.toLowerCase() + "_" + (r.fontWeight + "").toLowerCase(); return n[o] || (n[o] = {}), n[o] }, _measureChar: function (r, i, n, o) { var p = this.getFontCache(i), f = this._getFontDeclaration(i), m = this._getFontDeclaration(o), y = n + r, C = f === m, x, I, D, P = i.fontSize / this.CACHE_FONT_SIZE, z; if (n && p[n] !== void 0 && (D = p[n]), p[r] !== void 0 && (z = x = p[r]), C && p[y] !== void 0 && (I = p[y], z = I - D), x === void 0 || D === void 0 || I === void 0) { var et = this.getMeasuringContext(); this._setTextStyles(et, i, !0) } return x === void 0 && (z = x = et.measureText(r).width, p[r] = x), D === void 0 && C && n && (D = et.measureText(n).width, p[n] = D), C && I === void 0 && (I = et.measureText(y).width, p[y] = I, z = I - D), { width: x * P, kernedWidth: z * P } }, getHeightOfChar: function (r, i) { return this.getValueOfPropertyAt(r, i, "fontSize") }, measureLine: function (r) { var i = this._measureLine(r); return this.charSpacing !== 0 && (i.width -= this._getWidthOfCharSpacing()), i.width < 0 && (i.width = 0), i }, _measureLine: function (r) { var i = 0, n, o, p = this._textLines[r], f, m, y = 0, C = new Array(p.length), x = 0, I, D, P = this.path, z = this.pathSide === "right"; for (this.__charBounds[r] = C, n = 0; n < p.length; n++)o = p[n], m = this._getGraphemeBox(o, r, n, f), C[n] = m, i += m.kernedWidth, f = o; if (C[n] = { left: m ? m.left + m.width : 0, width: 0, kernedWidth: 0, height: this.fontSize }, P) { switch (D = P.segmentsInfo[P.segmentsInfo.length - 1].length, I = a.util.getPointOnPath(P.path, 0, P.segmentsInfo), I.x += P.pathOffset.x, I.y += P.pathOffset.y, this.textAlign) { case "left": x = z ? D - i : 0; break; case "center": x = (D - i) / 2; break; case "right": x = z ? 0 : D - i; break }for (x += this.pathStartOffset * (z ? -1 : 1), n = z ? p.length - 1 : 0; z ? n >= 0 : n < p.length; z ? n-- : n++)m = C[n], x > D ? x %= D : x < 0 && (x += D), this._setGraphemeOnPath(x, m, I), x += m.kernedWidth } return { width: i, numOfSpaces: y } }, _setGraphemeOnPath: function (r, i, n) { var o = r + i.kernedWidth / 2, p = this.path, f = a.util.getPointOnPath(p.path, o, p.segmentsInfo); i.renderLeft = f.x - n.x, i.renderTop = f.y - n.y, i.angle = f.angle + (this.pathSide === "right" ? Math.PI : 0) }, _getGraphemeBox: function (r, i, n, o, p) { var f = this.getCompleteStyleDeclaration(i, n), m = o ? this.getCompleteStyleDeclaration(i, n - 1) : {}, y = this._measureChar(r, f, o, m), C = y.kernedWidth, x = y.width, I; this.charSpacing !== 0 && (I = this._getWidthOfCharSpacing(), x += I, C += I); var D = { width: x, left: 0, height: f.fontSize, kernedWidth: C, deltaY: f.deltaY }; if (n > 0 && !p) { var P = this.__charBounds[i][n - 1]; D.left = P.left + P.width + y.kernedWidth - y.width } return D }, getHeightOfLine: function (r) { if (this.__lineHeights[r]) return this.__lineHeights[r]; for (var i = this._textLines[r], n = this.getHeightOfChar(r, 0), o = 1, p = i.length; o < p; o++)n = Math.max(this.getHeightOfChar(r, o), n); return this.__lineHeights[r] = n * this.lineHeight * this._fontSizeMult }, calcTextHeight: function () { for (var r, i = 0, n = 0, o = this._textLines.length; n < o; n++)r = this.getHeightOfLine(n), i += n === o - 1 ? r / this.lineHeight : r; return i }, _getLeftOffset: function () { return this.direction === "ltr" ? -this.width / 2 : this.width / 2 }, _getTopOffset: function () { return -this.height / 2 }, _renderTextCommon: function (r, i) { r.save(); for (var n = 0, o = this._getLeftOffset(), p = this._getTopOffset(), f = 0, m = this._textLines.length; f < m; f++) { var y = this.getHeightOfLine(f), C = y / this.lineHeight, x = this._getLineLeftOffset(f); this._renderTextLine(i, r, this._textLines[f], o + x, p + n + C, f), n += y } r.restore() }, _renderTextFill: function (r) { !this.fill && !this.styleHas("fill") || this._renderTextCommon(r, "fillText") }, _renderTextStroke: function (r) { (!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles() || (this.shadow && !this.shadow.affectStroke && this._removeShadow(r), r.save(), this._setLineDash(r, this.strokeDashArray), r.beginPath(), this._renderTextCommon(r, "strokeText"), r.closePath(), r.restore()) }, _renderChars: function (r, i, n, o, p, f) { var m = this.getHeightOfLine(f), y = this.textAlign.indexOf("justify") !== -1, C, x, I = "", D, P = 0, z, et = this.path, tt = !y && this.charSpacing === 0 && this.isEmptyStyles(f) && !et, st = this.direction === "ltr", dt = this.direction === "ltr" ? 1 : -1, q, ct = i.canvas.getAttribute("dir"); if (i.save(), ct !== this.direction && (i.canvas.setAttribute("dir", st ? "ltr" : "rtl"), i.direction = st ? "ltr" : "rtl", i.textAlign = st ? "left" : "right"), p -= m * this._fontSizeFraction / this.lineHeight, tt) { this._renderChar(r, i, f, 0, n.join(""), o, p, m), i.restore(); return } for (var W = 0, Dt = n.length - 1; W <= Dt; W++)z = W === Dt || this.charSpacing || et, I += n[W], D = this.__charBounds[f][W], P === 0 ? (o += dt * (D.kernedWidth - D.width), P += D.width) : P += D.kernedWidth, y && !z && this._reSpaceAndTab.test(n[W]) && (z = !0), z || (C = C || this.getCompleteStyleDeclaration(f, W), x = this.getCompleteStyleDeclaration(f, W + 1), z = a.util.hasStyleChanged(C, x, !1)), z && (et ? (i.save(), i.translate(D.renderLeft, D.renderTop), i.rotate(D.angle), this._renderChar(r, i, f, W, I, -P / 2, 0, m), i.restore()) : (q = o, this._renderChar(r, i, f, W, I, q, p, m)), I = "", C = x, o += dt * P, P = 0); i.restore() }, _applyPatternGradientTransformText: function (r) { var i = a.util.createCanvasElement(), n, o = this.width + this.strokeWidth, p = this.height + this.strokeWidth; return i.width = o, i.height = p, n = i.getContext("2d"), n.beginPath(), n.moveTo(0, 0), n.lineTo(o, 0), n.lineTo(o, p), n.lineTo(0, p), n.closePath(), n.translate(o / 2, p / 2), n.fillStyle = r.toLive(n), this._applyPatternGradientTransform(n, r), n.fill(), n.createPattern(i, "no-repeat") }, handleFiller: function (r, i, n) { var o, p; return n.toLive ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? (o = -this.width / 2, p = -this.height / 2, r.translate(o, p), r[i] = this._applyPatternGradientTransformText(n), { offsetX: o, offsetY: p }) : (r[i] = n.toLive(r, this), this._applyPatternGradientTransform(r, n)) : (r[i] = n, { offsetX: 0, offsetY: 0 }) }, _setStrokeStyles: function (r, i) { return r.lineWidth = i.strokeWidth, r.lineCap = this.strokeLineCap, r.lineDashOffset = this.strokeDashOffset, r.lineJoin = this.strokeLineJoin, r.miterLimit = this.strokeMiterLimit, this.handleFiller(r, "strokeStyle", i.stroke) }, _setFillStyles: function (r, i) { return this.handleFiller(r, "fillStyle", i.fill) }, _renderChar: function (r, i, n, o, p, f, m) { var y = this._getStyleDeclaration(n, o), C = this.getCompleteStyleDeclaration(n, o), x = r === "fillText" && C.fill, I = r === "strokeText" && C.stroke && C.strokeWidth, D, P; !I && !x || (i.save(), x && (D = this._setFillStyles(i, C)), I && (P = this._setStrokeStyles(i, C)), i.font = this._getFontDeclaration(C), y && y.textBackgroundColor && this._removeShadow(i), y && y.deltaY && (m += y.deltaY), x && i.fillText(p, f - D.offsetX, m - D.offsetY), I && i.strokeText(p, f - P.offsetX, m - P.offsetY), i.restore()) }, setSuperscript: function (r, i) { return this._setScript(r, i, this.superscript) }, setSubscript: function (r, i) { return this._setScript(r, i, this.subscript) }, _setScript: function (r, i, n) { var o = this.get2DCursorLocation(r, !0), p = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "fontSize"), f = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "deltaY"), m = { fontSize: p * n.size, deltaY: f + p * n.baseline }; return this.setSelectionStyles(m, r, i), this }, _getLineLeftOffset: function (r) { var i = this.getLineWidth(r), n = this.width - i, o = this.textAlign, p = this.direction, m, f = 0, m = this.isEndOfWrapping(r); return o === "justify" || o === "justify-center" && !m || o === "justify-right" && !m || o === "justify-left" && !m ? 0 : (o === "center" && (f = n / 2), o === "right" && (f = n), o === "justify-center" && (f = n / 2), o === "justify-right" && (f = n), p === "rtl" && (f -= n), f) }, _clearCache: function () { this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [] }, _shouldClearDimensionCache: function () { var r = this._forceClearCache; return r || (r = this.hasStateChanged("_dimensionAffectingProps")), r && (this.dirty = !0, this._forceClearCache = !1), r }, getLineWidth: function (r) { if (this.__lineWidths[r] !== void 0) return this.__lineWidths[r]; var i = this.measureLine(r), n = i.width; return this.__lineWidths[r] = n, n }, _getWidthOfCharSpacing: function () { return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0 }, getValueOfPropertyAt: function (r, i, n) { var o = this._getStyleDeclaration(r, i); return o && typeof o[n] < "u" ? o[n] : this[n] }, _renderTextDecoration: function (r, i) { if (!(!this[i] && !this.styleHas(i))) { for (var n, o, p, f, m, y, C, x, I = this._getLeftOffset(), D = this._getTopOffset(), P, z, et, tt, st, dt, q, ct, W = this.path, Dt = this._getWidthOfCharSpacing(), Lt = this.offsets[i], it = 0, O = this._textLines.length; it < O; it++) { if (n = this.getHeightOfLine(it), !this[i] && !this.styleHas(i, it)) { D += n; continue } C = this._textLines[it], dt = n / this.lineHeight, f = this._getLineLeftOffset(it), z = 0, et = 0, x = this.getValueOfPropertyAt(it, 0, i), ct = this.getValueOfPropertyAt(it, 0, "fill"), P = D + dt * (1 - this._fontSizeFraction), o = this.getHeightOfChar(it, 0), m = this.getValueOfPropertyAt(it, 0, "deltaY"); for (var V = 0, G = C.length; V < G; V++)if (tt = this.__charBounds[it][V], st = this.getValueOfPropertyAt(it, V, i), q = this.getValueOfPropertyAt(it, V, "fill"), p = this.getHeightOfChar(it, V), y = this.getValueOfPropertyAt(it, V, "deltaY"), W && st && q) r.save(), r.fillStyle = ct, r.translate(tt.renderLeft, tt.renderTop), r.rotate(tt.angle), r.fillRect(-tt.kernedWidth / 2, Lt * p + y, tt.kernedWidth, this.fontSize / 15), r.restore(); else if ((st !== x || q !== ct || p !== o || y !== m) && et > 0) { var U = I + f + z; this.direction === "rtl" && (U = this.width - U - et), x && ct && (r.fillStyle = ct, r.fillRect(U, P + Lt * o + m, et, this.fontSize / 15)), z = tt.left, et = tt.width, x = st, ct = q, o = p, m = y } else et += tt.kernedWidth; var U = I + f + z; this.direction === "rtl" && (U = this.width - U - et), r.fillStyle = q, st && q && r.fillRect(U, P + Lt * o + m, et - Dt, this.fontSize / 15), D += n } this._removeShadow(r) } }, _getFontDeclaration: function (r, i) { var n = r || this, o = this.fontFamily, p = a.Text.genericFonts.indexOf(o.toLowerCase()) > -1, f = o === void 0 || o.indexOf("'") > -1 || o.indexOf(",") > -1 || o.indexOf('"') > -1 || p ? n.fontFamily : '"' + n.fontFamily + '"'; return [a.isLikelyNode ? n.fontWeight : n.fontStyle, a.isLikelyNode ? n.fontStyle : n.fontWeight, i ? this.CACHE_FONT_SIZE + "px" : n.fontSize + "px", f].join(" ") }, render: function (r) { this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", r))) }, _splitTextIntoLines: function (r) {
      for (var i = r.split(this._reNewline), n = new Array(i.length), o = [`
`], p = [], f = 0; f < i.length; f++)n[f] = a.util.string.graphemeSplit(i[f]), p = p.concat(n[f], o); return p.pop(), { _unwrappedLines: n, lines: i, graphemeText: p, graphemeLines: n }
    }, toObject: function (r) { var i = c.concat(r), n = this.callSuper("toObject", i); return n.styles = a.util.stylesToArray(this.styles, this.text), n.path && (n.path = this.path.toObject()), n }, set: function (r, i) { this.callSuper("set", r, i); var n = !1, o = !1; if (typeof r == "object") for (var p in r) p === "path" && this.setPathInfo(), n = n || this._dimensionAffectingProps.indexOf(p) !== -1, o = o || p === "path"; else n = this._dimensionAffectingProps.indexOf(r) !== -1, o = r === "path"; return o && this.setPathInfo(), n && (this.initDimensions(), this.setCoords()), this }, complexity: function () { return 1 }
  }), a.Text.ATTRIBUTE_NAMES = a.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), a.Text.DEFAULT_SVG_FONT_SIZE = 16, a.Text.fromElement = function (r, i, n) { if (!r) return i(null); var o = a.parseAttributes(r, a.Text.ATTRIBUTE_NAMES), p = o.textAnchor || "left"; if (n = a.util.object.extend(n ? l(n) : {}, o), n.top = n.top || 0, n.left = n.left || 0, o.textDecoration) { var f = o.textDecoration; f.indexOf("underline") !== -1 && (n.underline = !0), f.indexOf("overline") !== -1 && (n.overline = !0), f.indexOf("line-through") !== -1 && (n.linethrough = !0), delete n.textDecoration } "dx" in o && (n.left += o.dx), "dy" in o && (n.top += o.dy), "fontSize" in n || (n.fontSize = a.Text.DEFAULT_SVG_FONT_SIZE); var m = ""; "textContent" in r ? m = r.textContent : "firstChild" in r && r.firstChild !== null && "data" in r.firstChild && r.firstChild.data !== null && (m = r.firstChild.data), m = m.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "); var y = n.strokeWidth; n.strokeWidth = 0; var C = new a.Text(m, n), x = C.getScaledHeight() / C.height, I = (C.height + C.strokeWidth) * C.lineHeight - C.height, D = I * x, P = C.getScaledHeight() + D, z = 0; p === "center" && (z = C.getScaledWidth() / 2), p === "right" && (z = C.getScaledWidth()), C.set({ left: C.left - z, top: C.top - (P - C.fontSize * (.07 + C._fontSizeFraction)) / C.lineHeight, strokeWidth: typeof y < "u" ? y : 1 }), i(C) }, a.Text.fromObject = function (r, i) { var n = l(r), o = r.path; return delete n.path, a.Object._fromObject("Text", n, function (p) { p.styles = a.util.stylesFromArray(r.styles, r.text), o ? a.Object._fromObject("Path", o, function (f) { p.set("path", f), i(p) }, "path") : i(p) }, "text") }, a.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], a.util.createAccessors && a.util.createAccessors(a.Text)
}(v), function () { h.util.object.extend(h.Text.prototype, { isEmptyStyles: function (d) { if (!this.styles || typeof d < "u" && !this.styles[d]) return !0; var a = typeof d > "u" ? this.styles : { line: this.styles[d] }; for (var l in a) for (var c in a[l]) for (var r in a[l][c]) return !1; return !0 }, styleHas: function (d, a) { if (!this.styles || !d || d === "" || typeof a < "u" && !this.styles[a]) return !1; var l = typeof a > "u" ? this.styles : { 0: this.styles[a] }; for (var c in l) for (var r in l[c]) if (typeof l[c][r][d] < "u") return !0; return !1 }, cleanStyle: function (d) { if (!this.styles || !d || d === "") return !1; var a = this.styles, l = 0, c, r, i = !0, n = 0, o; for (var p in a) { c = 0; for (var f in a[p]) { var o = a[p][f], m = o.hasOwnProperty(d); l++, m ? (r ? o[d] !== r && (i = !1) : r = o[d], o[d] === this[d] && delete o[d]) : i = !1, Object.keys(o).length !== 0 ? c++ : delete a[p][f] } c === 0 && delete a[p] } for (var y = 0; y < this._textLines.length; y++)n += this._textLines[y].length; i && l === n && (this[d] = r, this.removeStyle(d)) }, removeStyle: function (d) { if (!(!this.styles || !d || d === "")) { var a = this.styles, l, c, r; for (c in a) { l = a[c]; for (r in l) delete l[r][d], Object.keys(l[r]).length === 0 && delete l[r]; Object.keys(l).length === 0 && delete a[c] } } }, _extendStyles: function (d, a) { var l = this.get2DCursorLocation(d); this._getLineStyle(l.lineIndex) || this._setLineStyle(l.lineIndex), this._getStyleDeclaration(l.lineIndex, l.charIndex) || this._setStyleDeclaration(l.lineIndex, l.charIndex, {}), h.util.object.extend(this._getStyleDeclaration(l.lineIndex, l.charIndex), a) }, get2DCursorLocation: function (d, a) { typeof d > "u" && (d = this.selectionStart); for (var l = a ? this._unwrappedTextLines : this._textLines, c = l.length, r = 0; r < c; r++) { if (d <= l[r].length) return { lineIndex: r, charIndex: d }; d -= l[r].length + this.missingNewlineOffset(r) } return { lineIndex: r - 1, charIndex: l[r - 1].length < d ? l[r - 1].length : d } }, getSelectionStyles: function (d, a, l) { typeof d > "u" && (d = this.selectionStart || 0), typeof a > "u" && (a = this.selectionEnd || d); for (var c = [], r = d; r < a; r++)c.push(this.getStyleAtPosition(r, l)); return c }, getStyleAtPosition: function (d, a) { var l = this.get2DCursorLocation(d), c = a ? this.getCompleteStyleDeclaration(l.lineIndex, l.charIndex) : this._getStyleDeclaration(l.lineIndex, l.charIndex); return c || {} }, setSelectionStyles: function (d, a, l) { typeof a > "u" && (a = this.selectionStart || 0), typeof l > "u" && (l = this.selectionEnd || a); for (var c = a; c < l; c++)this._extendStyles(c, d); return this._forceClearCache = !0, this }, _getStyleDeclaration: function (d, a) { var l = this.styles && this.styles[d]; return l ? l[a] : null }, getCompleteStyleDeclaration: function (d, a) { for (var l = this._getStyleDeclaration(d, a) || {}, c = {}, r, i = 0; i < this._styleProperties.length; i++)r = this._styleProperties[i], c[r] = typeof l[r] > "u" ? this[r] : l[r]; return c }, _setStyleDeclaration: function (d, a, l) { this.styles[d][a] = l }, _deleteStyleDeclaration: function (d, a) { delete this.styles[d][a] }, _getLineStyle: function (d) { return !!this.styles[d] }, _setLineStyle: function (d) { this.styles[d] = {} }, _deleteLineStyle: function (d) { delete this.styles[d] } }) }(), function () { function d(a) { a.textDecoration && (a.textDecoration.indexOf("underline") > -1 && (a.underline = !0), a.textDecoration.indexOf("line-through") > -1 && (a.linethrough = !0), a.textDecoration.indexOf("overline") > -1 && (a.overline = !0), delete a.textDecoration) } h.IText = h.util.createClass(h.Text, h.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: !1, __widthOfSpace: [], inCompositionMode: !1, initialize: function (a, l) { this.callSuper("initialize", a, l), this.initBehavior() }, setSelectionStart: function (a) { a = Math.max(a, 0), this._updateAndFire("selectionStart", a) }, setSelectionEnd: function (a) { a = Math.min(a, this.text.length), this._updateAndFire("selectionEnd", a) }, _updateAndFire: function (a, l) { this[a] !== l && (this._fireSelectionChanged(), this[a] = l), this._updateTextarea() }, _fireSelectionChanged: function () { this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this }) }, initDimensions: function () { this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions") }, render: function (a) { this.clearContextTop(), this.callSuper("render", a), this.cursorOffsetCache = {}, this.renderCursorOrSelection() }, _render: function (a) { this.callSuper("_render", a) }, clearContextTop: function (a) { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var l = this.canvas.contextTop, c = this.canvas.viewportTransform; l.save(), l.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this.transform(l), this._clearTextArea(l), a || l.restore() } }, renderCursorOrSelection: function () { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var a = this._getCursorBoundaries(), l = this.canvas.contextTop; this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(a, l) : this.renderSelection(a, l), l.restore() } }, _clearTextArea: function (a) { var l = this.width + 4, c = this.height + 4; a.clearRect(-l / 2, -c / 2, l, c) }, _getCursorBoundaries: function (a) { typeof a > "u" && (a = this.selectionStart); var l = this._getLeftOffset(), c = this._getTopOffset(), r = this._getCursorBoundariesOffsets(a); return { left: l, top: c, leftOffset: r.left, topOffset: r.top } }, _getCursorBoundariesOffsets: function (a) { if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache; var l, c, r, i = 0, n = 0, o, p = this.get2DCursorLocation(a); r = p.charIndex, c = p.lineIndex; for (var f = 0; f < c; f++)i += this.getHeightOfLine(f); l = this._getLineLeftOffset(c); var m = this.__charBounds[c][r]; return m && (n = m.left), this.charSpacing !== 0 && r === this._textLines[c].length && (n -= this._getWidthOfCharSpacing()), o = { top: i, left: l + (n > 0 ? n : 0) }, this.direction === "rtl" && (o.left *= -1), this.cursorOffsetCache = o, this.cursorOffsetCache }, renderCursor: function (a, l) { var c = this.get2DCursorLocation(), r = c.lineIndex, i = c.charIndex > 0 ? c.charIndex - 1 : 0, n = this.getValueOfPropertyAt(r, i, "fontSize"), o = this.scaleX * this.canvas.getZoom(), p = this.cursorWidth / o, f = a.topOffset, m = this.getValueOfPropertyAt(r, i, "deltaY"); f += (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - n * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(a, l), l.fillStyle = this.cursorColor || this.getValueOfPropertyAt(r, i, "fill"), l.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, l.fillRect(a.left + a.leftOffset - p / 2, f + a.top + m, p, n) }, renderSelection: function (a, l) { for (var c = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, r = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, i = this.textAlign.indexOf("justify") !== -1, n = this.get2DCursorLocation(c), o = this.get2DCursorLocation(r), p = n.lineIndex, f = o.lineIndex, m = n.charIndex < 0 ? 0 : n.charIndex, y = o.charIndex < 0 ? 0 : o.charIndex, C = p; C <= f; C++) { var x = this._getLineLeftOffset(C) || 0, I = this.getHeightOfLine(C), D = 0, P = 0, z = 0; if (C === p && (P = this.__charBounds[p][m].left), C >= p && C < f) z = i && !this.isEndOfWrapping(C) ? this.width : this.getLineWidth(C) || 5; else if (C === f) if (y === 0) z = this.__charBounds[f][y].left; else { var et = this._getWidthOfCharSpacing(); z = this.__charBounds[f][y - 1].left + this.__charBounds[f][y - 1].width - et } D = I, (this.lineHeight < 1 || C === f && this.lineHeight > 1) && (I /= this.lineHeight); var tt = a.left + x + P, st = z - P, dt = I, q = 0; this.inCompositionMode ? (l.fillStyle = this.compositionColor || "black", dt = 1, q = I) : l.fillStyle = this.selectionColor, this.direction === "rtl" && (tt = this.width - tt - st), l.fillRect(tt, a.top + a.topOffset + q, st, dt), a.topOffset += D } }, getCurrentCharFontSize: function () { var a = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(a.l, a.c, "fontSize") }, getCurrentCharColor: function () { var a = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(a.l, a.c, "fill") }, _getCurrentCharIndex: function () { var a = this.get2DCursorLocation(this.selectionStart, !0), l = a.charIndex > 0 ? a.charIndex - 1 : 0; return { l: a.lineIndex, c: l } } }), h.IText.fromObject = function (a, l) { var c = h.util.stylesFromArray(a.styles, a.text), r = Object.assign({}, a, { styles: c }); if (d(r), r.styles) for (var i in r.styles) for (var n in r.styles[i]) d(r.styles[i][n]); h.Object._fromObject("IText", r, l, "text") } }(), function () {
  var d = h.util.object.clone; h.util.object.extend(h.IText.prototype, {
    initBehavior: function () { this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this) }, onDeselect: function () { this.isEditing && this.exitEditing(), this.selected = !1 }, initAddedHandler: function () { var a = this; this.on("added", function () { var l = a.canvas; l && (l._hasITextHandlers || (l._hasITextHandlers = !0, a._initCanvasHandlers(l)), l._iTextInstances = l._iTextInstances || [], l._iTextInstances.push(a)) }) }, initRemovedHandler: function () { var a = this; this.on("removed", function () { var l = a.canvas; l && (l._iTextInstances = l._iTextInstances || [], h.util.removeFromArray(l._iTextInstances, a), l._iTextInstances.length === 0 && (l._hasITextHandlers = !1, a._removeCanvasHandlers(l))) }) }, _initCanvasHandlers: function (a) { a._mouseUpITextHandler = function () { a._iTextInstances && a._iTextInstances.forEach(function (l) { l.__isMousedown = !1 }) }, a.on("mouse:up", a._mouseUpITextHandler) }, _removeCanvasHandlers: function (a) { a.off("mouse:up", a._mouseUpITextHandler) }, _tick: function () { this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete") }, _animateCursor: function (a, l, c, r) { var i; return i = { isAborted: !1, abort: function () { this.isAborted = !0 } }, a.animate("_currentCursorOpacity", l, { duration: c, onComplete: function () { i.isAborted || a[r]() }, onChange: function () { a.canvas && a.selectionStart === a.selectionEnd && a.renderCursorOrSelection() }, abort: function () { return i.isAborted } }), i }, _onTickComplete: function () { var a = this; this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () { a._currentTickCompleteState = a._animateCursor(a, 0, this.cursorDuration / 2, "_tick") }, 100) }, initDelayedCursor: function (a) { var l = this, c = a ? 0 : this.cursorDelay; this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () { l._tick() }, c) }, abortCursorAnimation: function () { var a = this._currentTickState || this._currentTickCompleteState, l = this.canvas; this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, a && l && l.clearContext(l.contextTop || l.contextContainer) }, selectAll: function () { return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this }, getSelectedText: function () { return this._text.slice(this.selectionStart, this.selectionEnd).join("") }, findWordBoundaryLeft: function (a) { var l = 0, c = a - 1; if (this._reSpace.test(this._text[c])) for (; this._reSpace.test(this._text[c]);)l++, c--; for (; /\S/.test(this._text[c]) && c > -1;)l++, c--; return a - l }, findWordBoundaryRight: function (a) { var l = 0, c = a; if (this._reSpace.test(this._text[c])) for (; this._reSpace.test(this._text[c]);)l++, c++; for (; /\S/.test(this._text[c]) && c < this._text.length;)l++, c++; return a + l }, findLineBoundaryLeft: function (a) { for (var l = 0, c = a - 1; !/\n/.test(this._text[c]) && c > -1;)l++, c--; return a - l }, findLineBoundaryRight: function (a) { for (var l = 0, c = a; !/\n/.test(this._text[c]) && c < this._text.length;)l++, c++; return a + l }, searchWordBoundary: function (a, l) { for (var c = this._text, r = this._reSpace.test(c[a]) ? a - 1 : a, i = c[r], n = h.reNonWord; !n.test(i) && r > 0 && r < c.length;)r += l, i = c[r]; return n.test(i) && (r += l === 1 ? 0 : 1), r }, selectWord: function (a) { a = a || this.selectionStart; var l = this.searchWordBoundary(a, -1), c = this.searchWordBoundary(a, 1); this.selectionStart = l, this.selectionEnd = c, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection() }, selectLine: function (a) { a = a || this.selectionStart; var l = this.findLineBoundaryLeft(a), c = this.findLineBoundaryRight(a); return this.selectionStart = l, this.selectionEnd = c, this._fireSelectionChanged(), this._updateTextarea(), this }, enterEditing: function (a) { if (!(this.isEditing || !this.editable)) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(a), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this }, exitEditingOnOthers: function (a) { a._iTextInstances && a._iTextInstances.forEach(function (l) { l.selected = !1, l.isEditing && l.exitEditing() }) }, initMouseMoveHandler: function () { this.canvas.on("mouse:move", this.mouseMoveHandler) }, mouseMoveHandler: function (a) { if (!(!this.__isMousedown || !this.isEditing)) { document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus(); var l = this.getSelectionStartFromPointer(a.e), c = this.selectionStart, r = this.selectionEnd; (l !== this.__selectionStartOnMouseDown || c === r) && (c === l || r === l) || (l > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = l) : (this.selectionStart = l, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== c || this.selectionEnd !== r) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection())) } }, _setEditingProps: function () { this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0 }, fromStringToGraphemeSelection: function (a, l, c) { var r = c.slice(0, a), i = h.util.string.graphemeSplit(r).length; if (a === l) return { selectionStart: i, selectionEnd: i }; var n = c.slice(a, l), o = h.util.string.graphemeSplit(n).length; return { selectionStart: i, selectionEnd: i + o } }, fromGraphemeToStringSelection: function (a, l, c) { var r = c.slice(0, a), i = r.join("").length; if (a === l) return { selectionStart: i, selectionEnd: i }; var n = c.slice(a, l), o = n.join("").length; return { selectionStart: i, selectionEnd: i + o } }, _updateTextarea: function () { if (this.cursorOffsetCache = {}, !!this.hiddenTextarea) { if (!this.inCompositionMode) { var a = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text); this.hiddenTextarea.selectionStart = a.selectionStart, this.hiddenTextarea.selectionEnd = a.selectionEnd } this.updateTextareaPosition() } }, updateFromTextArea: function () { if (this.hiddenTextarea) { this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()); var a = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value); this.selectionEnd = this.selectionStart = a.selectionEnd, this.inCompositionMode || (this.selectionStart = a.selectionStart), this.updateTextareaPosition() } }, updateTextareaPosition: function () { if (this.selectionStart === this.selectionEnd) { var a = this._calcTextareaPosition(); this.hiddenTextarea.style.left = a.left, this.hiddenTextarea.style.top = a.top } }, _calcTextareaPosition: function () { if (!this.canvas) return { x: 1, y: 1 }; var a = this.inCompositionMode ? this.compositionStart : this.selectionStart, l = this._getCursorBoundaries(a), c = this.get2DCursorLocation(a), r = c.lineIndex, i = c.charIndex, n = this.getValueOfPropertyAt(r, i, "fontSize") * this.lineHeight, o = l.leftOffset, p = this.calcTransformMatrix(), f = { x: l.left + o, y: l.top + l.topOffset + n }, m = this.canvas.getRetinaScaling(), y = this.canvas.upperCanvasEl, C = y.width / m, x = y.height / m, I = C - n, D = x - n, P = y.clientWidth / C, z = y.clientHeight / x; return f = h.util.transformPoint(f, p), f = h.util.transformPoint(f, this.canvas.viewportTransform), f.x *= P, f.y *= z, f.x < 0 && (f.x = 0), f.x > I && (f.x = I), f.y < 0 && (f.y = 0), f.y > D && (f.y = D), f.x += this.canvas._offset.left, f.y += this.canvas._offset.top, { left: f.x + "px", top: f.y + "px", fontSize: n + "px", charHeight: n } }, _saveEditingProps: function () { this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor } }, _restoreEditingProps: function () { this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor)) }, exitEditing: function () { var a = this._textBeforeEdit !== this.text, l = this.hiddenTextarea; return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, l && (l.blur && l.blur(), l.parentNode && l.parentNode.removeChild(l)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), a && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), a && this.canvas.fire("object:modified", { target: this })), this }, _removeExtraneousStyles: function () { for (var a in this.styles) this._textLines[a] || delete this.styles[a] }, removeStyleFromTo: function (a, l) { var c = this.get2DCursorLocation(a, !0), r = this.get2DCursorLocation(l, !0), i = c.lineIndex, n = c.charIndex, o = r.lineIndex, p = r.charIndex, f, m; if (i !== o) { if (this.styles[i]) for (f = n; f < this._unwrappedTextLines[i].length; f++)delete this.styles[i][f]; if (this.styles[o]) for (f = p; f < this._unwrappedTextLines[o].length; f++)m = this.styles[o][f], m && (this.styles[i] || (this.styles[i] = {}), this.styles[i][n + f - p] = m); for (f = i + 1; f <= o; f++)delete this.styles[f]; this.shiftLineStyles(o, i - o) } else if (this.styles[i]) { m = this.styles[i]; var y = p - n, C, x; for (f = n; f < p; f++)delete m[f]; for (x in this.styles[i]) C = parseInt(x, 10), C >= p && (m[C - y] = m[x], delete m[x]) } }, shiftLineStyles: function (a, l) { var c = d(this.styles); for (var r in this.styles) { var i = parseInt(r, 10); i > a && (this.styles[i + l] = c[i], c[i - l] || delete this.styles[i]) } }, restartCursorIfNeeded: function () { (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor() }, insertNewlineStyleObject: function (a, l, c, r) { var i, n = {}, o = !1, p = this._unwrappedTextLines[a].length === l; c || (c = 1), this.shiftLineStyles(a, c), this.styles[a] && (i = this.styles[a][l === 0 ? l : l - 1]); for (var f in this.styles[a]) { var m = parseInt(f, 10); m >= l && (o = !0, n[m - l] = this.styles[a][f], p && l === 0 || delete this.styles[a][f]) } var y = !1; for (o && !p && (this.styles[a + c] = n, y = !0), y && c--; c > 0;)r && r[c - 1] ? this.styles[a + c] = { 0: d(r[c - 1]) } : i ? this.styles[a + c] = { 0: d(i) } : delete this.styles[a + c], c--; this._forceClearCache = !0 }, insertCharStyleObject: function (a, l, c, r) { this.styles || (this.styles = {}); var i = this.styles[a], n = i ? d(i) : {}; c || (c = 1); for (var o in n) { var p = parseInt(o, 10); p >= l && (i[p + c] = n[p], n[p - c] || delete i[p]) } if (this._forceClearCache = !0, r) { for (; c--;)Object.keys(r[c]).length && (this.styles[a] || (this.styles[a] = {}), this.styles[a][l + c] = d(r[c])); return } if (i) for (var f = i[l ? l - 1 : 1]; f && c--;)this.styles[a][l + c] = d(f) }, insertNewStyleBlock: function (a, l, c) {
      for (var r = this.get2DCursorLocation(l, !0), i = [0], n = 0, o = 0; o < a.length; o++)a[o] === `
`? (n++, i[n] = 0) : i[n]++; i[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, i[0], c), c = c && c.slice(i[0] + 1)), n && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + i[0], n); for (var o = 1; o < n; o++)i[o] > 0 ? this.insertCharStyleObject(r.lineIndex + o, 0, i[o], c) : c && this.styles[r.lineIndex + o] && c[0] && (this.styles[r.lineIndex + o][0] = c[0]), c = c && c.slice(i[o] + 1); i[o] > 0 && this.insertCharStyleObject(r.lineIndex + o, 0, i[o], c)
    }, setSelectionStartEndWithShift: function (a, l, c) { c <= a ? (l === a ? this._selectionDirection = "left" : this._selectionDirection === "right" && (this._selectionDirection = "left", this.selectionEnd = a), this.selectionStart = c) : c > a && c < l ? this._selectionDirection === "right" ? this.selectionEnd = c : this.selectionStart = c : (l === a ? this._selectionDirection = "right" : this._selectionDirection === "left" && (this._selectionDirection = "right", this.selectionStart = l), this.selectionEnd = c) }, setSelectionInBoundaries: function () { var a = this.text.length; this.selectionStart > a ? this.selectionStart = a : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > a ? this.selectionEnd = a : this.selectionEnd < 0 && (this.selectionEnd = 0) }
  })
}(), h.util.object.extend(h.IText.prototype, { initDoubleClickSimulation: function () { this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown) }, onMouseDown: function (d) { if (this.canvas) { this.__newClickTime = +new Date; var a = d.pointer; this.isTripleClick(a) && (this.fire("tripleclick", d), this._stopEvent(d.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = a, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected } }, isTripleClick: function (d) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === d.x && this.__lastPointer.y === d.y }, _stopEvent: function (d) { d.preventDefault && d.preventDefault(), d.stopPropagation && d.stopPropagation() }, initCursorSelectionHandlers: function () { this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks() }, doubleClickHandler: function (d) { this.isEditing && this.selectWord(this.getSelectionStartFromPointer(d.e)) }, tripleClickHandler: function (d) { this.isEditing && this.selectLine(this.getSelectionStartFromPointer(d.e)) }, initClicks: function () { this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler) }, _mouseDownHandler: function (d) { !this.canvas || !this.editable || d.e.button && d.e.button !== 1 || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(d.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())) }, _mouseDownHandlerBefore: function (d) { !this.canvas || !this.editable || d.e.button && d.e.button !== 1 || (this.selected = this === this.canvas._activeObject) }, initMousedownHandler: function () { this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore) }, initMouseupHandler: function () { this.on("mouseup", this.mouseUpHandler) }, mouseUpHandler: function (d) { if (this.__isMousedown = !1, !(!this.editable || this.group || d.transform && d.transform.actionPerformed || d.e.button && d.e.button !== 1)) { if (this.canvas) { var a = this.canvas._activeObject; if (a && a !== this) return } this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(d.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0 } }, setCursorByClick: function (d) { var a = this.getSelectionStartFromPointer(d), l = this.selectionStart, c = this.selectionEnd; d.shiftKey ? this.setSelectionStartEndWithShift(l, c, a) : (this.selectionStart = a, this.selectionEnd = a), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea()) }, getSelectionStartFromPointer: function (d) { for (var a = this.getLocalPointer(d), l = 0, c = 0, r = 0, i = 0, n = 0, o, p, f = 0, m = this._textLines.length; f < m && r <= a.y; f++)r += this.getHeightOfLine(f) * this.scaleY, n = f, f > 0 && (i += this._textLines[f - 1].length + this.missingNewlineOffset(f - 1)); o = this._getLineLeftOffset(n), c = o * this.scaleX, p = this._textLines[n], this.direction === "rtl" && (a.x = this.width * this.scaleX - a.x + c); for (var y = 0, C = p.length; y < C && (l = c, c += this.__charBounds[n][y].kernedWidth * this.scaleX, c <= a.x); y++)i++; return this._getNewSelectionStartFromOffset(a, l, c, i, C) }, _getNewSelectionStartFromOffset: function (d, a, l, c, r) { var i = d.x - a, n = l - d.x, o = n > i || n < 0 ? 0 : 1, p = c + o; return this.flipX && (p = r - p), p > this._text.length && (p = this._text.length), p } }), h.util.object.extend(h.IText.prototype, { initHiddenTextarea: function () { this.hiddenTextarea = h.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off"); var d = this._calcTextareaPosition(); this.hiddenTextarea.style.cssText = "position: absolute; top: " + d.top + "; left: " + d.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + d.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : h.document.body.appendChild(this.hiddenTextarea), h.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), h.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), h.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), h.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), h.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), h.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), h.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), h.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), h.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (h.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0) }, keysMap: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown" }, keysMapRtl: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorLeft", 36: "moveCursorRight", 37: "moveCursorRight", 38: "moveCursorUp", 39: "moveCursorLeft", 40: "moveCursorDown" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function () { this.hiddenTextarea && this.hiddenTextarea.focus() }, onKeyDown: function (d) { if (this.isEditing) { var a = this.direction === "rtl" ? this.keysMapRtl : this.keysMap; if (d.keyCode in a) this[a[d.keyCode]](d); else if (d.keyCode in this.ctrlKeysMapDown && (d.ctrlKey || d.metaKey)) this[this.ctrlKeysMapDown[d.keyCode]](d); else return; d.stopImmediatePropagation(), d.preventDefault(), d.keyCode >= 33 && d.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll() } }, onKeyUp: function (d) { if (!this.isEditing || this._copyDone || this.inCompositionMode) { this._copyDone = !1; return } if (d.keyCode in this.ctrlKeysMapUp && (d.ctrlKey || d.metaKey)) this[this.ctrlKeysMapUp[d.keyCode]](d); else return; d.stopImmediatePropagation(), d.preventDefault(), this.canvas && this.canvas.requestRenderAll() }, onInput: function (d) { var a = this.fromPaste; if (this.fromPaste = !1, d && d.stopPropagation(), !!this.isEditing) { var l = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, c = this._text.length, r = l.length, i, n, o = r - c, p = this.selectionStart, f = this.selectionEnd, m = p !== f, y, C, x; if (this.hiddenTextarea.value === "") { this.styles = {}, this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()); return } var I = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), D = p > I.selectionStart; m ? (i = this._text.slice(p, f), o += f - p) : r < c && (D ? i = this._text.slice(f + o, f) : i = this._text.slice(p, p - o)), n = l.slice(I.selectionEnd - o, I.selectionEnd), i && i.length && (n.length && (y = this.getSelectionStyles(p, p + 1, !1), y = n.map(function () { return y[0] })), m ? (C = p, x = f) : D ? (C = f - i.length, x = f) : (C = f, x = f + i.length), this.removeStyleFromTo(C, x)), n.length && (a && n.join("") === h.copiedText && !h.disableStyleCopyPaste && (y = h.copiedTextStyle), this.insertNewStyleBlock(n, p, y)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()) } }, onCompositionStart: function () { this.inCompositionMode = !0 }, onCompositionEnd: function () { this.inCompositionMode = !1 }, onCompositionUpdate: function (d) { this.compositionStart = d.target.selectionStart, this.compositionEnd = d.target.selectionEnd, this.updateTextareaPosition() }, copy: function () { this.selectionStart !== this.selectionEnd && (h.copiedText = this.getSelectedText(), h.disableStyleCopyPaste ? h.copiedTextStyle = null : h.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0) }, paste: function () { this.fromPaste = !0 }, _getClipboardData: function (d) { return d && d.clipboardData || h.window.clipboardData }, _getWidthBeforeCursor: function (d, a) { var l = this._getLineLeftOffset(d), c; return a > 0 && (c = this.__charBounds[d][a - 1], l += c.left + c.width), l }, getDownCursorOffset: function (d, a) { var l = this._getSelectionForOffset(d, a), c = this.get2DCursorLocation(l), r = c.lineIndex; if (r === this._textLines.length - 1 || d.metaKey || d.keyCode === 34) return this._text.length - l; var i = c.charIndex, n = this._getWidthBeforeCursor(r, i), o = this._getIndexOnLine(r + 1, n), p = this._textLines[r].slice(i); return p.length + o + 1 + this.missingNewlineOffset(r) }, _getSelectionForOffset: function (d, a) { return d.shiftKey && this.selectionStart !== this.selectionEnd && a ? this.selectionEnd : this.selectionStart }, getUpCursorOffset: function (d, a) { var l = this._getSelectionForOffset(d, a), c = this.get2DCursorLocation(l), r = c.lineIndex; if (r === 0 || d.metaKey || d.keyCode === 33) return -l; var i = c.charIndex, n = this._getWidthBeforeCursor(r, i), o = this._getIndexOnLine(r - 1, n), p = this._textLines[r].slice(0, i), f = this.missingNewlineOffset(r - 1); return -this._textLines[r - 1].length + o - p.length + (1 - f) }, _getIndexOnLine: function (d, a) { for (var l = this._textLines[d], c = this._getLineLeftOffset(d), r = c, i = 0, n, o, p = 0, f = l.length; p < f; p++)if (n = this.__charBounds[d][p].width, r += n, r > a) { o = !0; var m = r - n, y = r, C = Math.abs(m - a), x = Math.abs(y - a); i = x < C ? p : p - 1; break } return o || (i = l.length - 1), i }, moveCursorDown: function (d) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", d) }, moveCursorUp: function (d) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", d) }, _moveCursorUpOrDown: function (d, a) { var l = "get" + d + "CursorOffset", c = this[l](a, this._selectionDirection === "right"); a.shiftKey ? this.moveCursorWithShift(c) : this.moveCursorWithoutShift(c), c !== 0 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorWithShift: function (d) { var a = this._selectionDirection === "left" ? this.selectionStart + d : this.selectionEnd + d; return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, a), d !== 0 }, moveCursorWithoutShift: function (d) { return d < 0 ? (this.selectionStart += d, this.selectionEnd = this.selectionStart) : (this.selectionEnd += d, this.selectionStart = this.selectionEnd), d !== 0 }, moveCursorLeft: function (d) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", d) }, _move: function (d, a, l) { var c; if (d.altKey) c = this["findWordBoundary" + l](this[a]); else if (d.metaKey || d.keyCode === 35 || d.keyCode === 36) c = this["findLineBoundary" + l](this[a]); else return this[a] += l === "Left" ? -1 : 1, !0; if (typeof c < "u" && this[a] !== c) return this[a] = c, !0 }, _moveLeft: function (d, a) { return this._move(d, a, "Left") }, _moveRight: function (d, a) { return this._move(d, a, "Right") }, moveCursorLeftWithoutShift: function (d) { var a = !0; return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (a = this._moveLeft(d, "selectionStart")), this.selectionEnd = this.selectionStart, a }, moveCursorLeftWithShift: function (d) { if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) return this._moveLeft(d, "selectionEnd"); if (this.selectionStart !== 0) return this._selectionDirection = "left", this._moveLeft(d, "selectionStart") }, moveCursorRight: function (d) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", d) }, _moveCursorLeftOrRight: function (d, a) { var l = "moveCursor" + d + "With"; this._currentCursorOpacity = 1, a.shiftKey ? l += "Shift" : l += "outShift", this[l](a) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorRightWithShift: function (d) { if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) return this._moveRight(d, "selectionStart"); if (this.selectionEnd !== this._text.length) return this._selectionDirection = "right", this._moveRight(d, "selectionEnd") }, moveCursorRightWithoutShift: function (d) { var a = !0; return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (a = this._moveRight(d, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, a }, removeChars: function (d, a) { typeof a > "u" && (a = d + 1), this.removeStyleFromTo(d, a), this._text.splice(d, a - d), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() }, insertChars: function (d, a, l, c) { typeof c > "u" && (c = l), c > l && this.removeStyleFromTo(l, c); var r = h.util.string.graphemeSplit(d); this.insertNewStyleBlock(r, l, a), this._text = [].concat(this._text.slice(0, l), r, this._text.slice(c)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() } }), function () {
  var d = h.util.toFixed, a = /  +/g; h.util.object.extend(h.Text.prototype, {
    _toSVG: function () { var l = this._getSVGLeftTopOffsets(), c = this._getSVGTextAndBg(l.textTop, l.textLeft); return this._wrapSVGTextAndBg(c) }, toSVG: function (l) { return this._createBaseSVGMarkup(this._toSVG(), { reviver: l, noStyle: !0, withShadow: !0 }) }, _getSVGLeftTopOffsets: function () { return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) } }, _wrapSVGTextAndBg: function (l) {
      var c = !0, r = this.getSvgTextDecoration(this); return [l.textBgRects.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", r ? 'text-decoration="' + r + '" ' : "", 'style="', this.getSvgStyles(c), '"', this.addPaintOrder(), " >", l.textSpans.join(""), `</text>
`]
    }, _getSVGTextAndBg: function (l, c) { var r = [], i = [], n = l, o; this._setSVGBg(i); for (var p = 0, f = this._textLines.length; p < f; p++)o = this._getLineLeftOffset(p), (this.textBackgroundColor || this.styleHas("textBackgroundColor", p)) && this._setSVGTextLineBg(i, p, c + o, n), this._setSVGTextLineText(r, p, c + o, n), n += this.getHeightOfLine(p); return { textSpans: r, textBgRects: i } }, _createTextCharSpan: function (l, c, r, i) { var n = l !== l.trim() || l.match(a), o = this.getSvgSpanStyles(c, n), p = o ? 'style="' + o + '"' : "", f = c.deltaY, m = "", y = h.Object.NUM_FRACTION_DIGITS; return f && (m = ' dy="' + d(f, y) + '" '), ['<tspan x="', d(r, y), '" y="', d(i, y), '" ', m, p, ">", h.util.string.escapeXml(l), "</tspan>"].join("") }, _setSVGTextLineText: function (l, c, r, i) { var n = this.getHeightOfLine(c), o = this.textAlign.indexOf("justify") !== -1, p, f, m = "", y, C, x = 0, I = this._textLines[c], D; i += n * (1 - this._fontSizeFraction) / this.lineHeight; for (var P = 0, z = I.length - 1; P <= z; P++)D = P === z || this.charSpacing, m += I[P], y = this.__charBounds[c][P], x === 0 ? (r += y.kernedWidth - y.width, x += y.width) : x += y.kernedWidth, o && !D && this._reSpaceAndTab.test(I[P]) && (D = !0), D || (p = p || this.getCompleteStyleDeclaration(c, P), f = this.getCompleteStyleDeclaration(c, P + 1), D = h.util.hasStyleChanged(p, f, !0)), D && (C = this._getStyleDeclaration(c, P) || {}, l.push(this._createTextCharSpan(m, C, r, i)), m = "", p = f, r += x, x = 0) }, _pushTextBgRect: function (l, c, r, i, n, o) {
      var p = h.Object.NUM_FRACTION_DIGITS; l.push("		<rect ", this._getFillAttributes(c), ' x="', d(r, p), '" y="', d(i, p), '" width="', d(n, p), '" height="', d(o, p), `"></rect>
`)
    }, _setSVGTextLineBg: function (l, c, r, i) { for (var n = this._textLines[c], o = this.getHeightOfLine(c) / this.lineHeight, p = 0, f = 0, m, y, C = this.getValueOfPropertyAt(c, 0, "textBackgroundColor"), x = 0, I = n.length; x < I; x++)m = this.__charBounds[c][x], y = this.getValueOfPropertyAt(c, x, "textBackgroundColor"), y !== C ? (C && this._pushTextBgRect(l, C, r + f, i, p, o), f = m.left, p = m.width, C = y) : p += m.kernedWidth; y && this._pushTextBgRect(l, y, r + f, i, p, o) }, _getFillAttributes: function (l) { var c = l && typeof l == "string" ? new h.Color(l) : ""; return !c || !c.getSource() || c.getAlpha() === 1 ? 'fill="' + l + '"' : 'opacity="' + c.getAlpha() + '" fill="' + c.setAlpha(1).toRgb() + '"' }, _getSVGLineTopOffset: function (l) { for (var c = 0, r = 0, i = 0; i < l; i++)c += this.getHeightOfLine(i); return r = this.getHeightOfLine(i), { lineTop: c, offset: (this._fontSizeMult - this._fontSizeFraction) * r / (this.lineHeight * this._fontSizeMult) } }, getSvgStyles: function (l) { var c = h.Object.prototype.getSvgStyles.call(this, l); return c + " white-space: pre;" }
  })
}(), function (d) {
  var a = d.fabric || (d.fabric = {}); a.Textbox = a.util.createClass(a.IText, a.Observable, {
    type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingFlip: !0, noScaleCache: !1, _dimensionAffectingProps: a.Text.prototype._dimensionAffectingProps.concat("width"), _wordJoiners: /[ \t\r]/, splitByGrapheme: !1, initDimensions: function () { this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, _generateStyleMap: function (l) {
      for (var c = 0, r = 0, i = 0, n = {}, o = 0; o < l.graphemeLines.length; o++)l.graphemeText[i] === `
`&& o > 0 ? (r = 0, i++, c++) : !this.splitByGrapheme && this._reSpaceAndTab.test(l.graphemeText[i]) && o > 0 && (r++, i++), n[o] = { line: c, offset: r }, i += l.graphemeLines[o].length, r += l.graphemeLines[o].length; return n
    }, styleHas: function (l, c) { if (this._styleMap && !this.isWrapping) { var r = this._styleMap[c]; r && (c = r.line) } return a.Text.prototype.styleHas.call(this, l, c) }, isEmptyStyles: function (l) { if (!this.styles) return !0; var c = 0, r = l + 1, i, n, o = !1, p = this._styleMap[l], f = this._styleMap[l + 1]; p && (l = p.line, c = p.offset), f && (r = f.line, o = r === l, i = f.offset), n = typeof l > "u" ? this.styles : { line: this.styles[l] }; for (var m in n) for (var y in n[m]) if (y >= c && (!o || y < i)) for (var C in n[m][y]) return !1; return !0 }, _getStyleDeclaration: function (l, c) { if (this._styleMap && !this.isWrapping) { var r = this._styleMap[l]; if (!r) return null; l = r.line, c = r.offset + c } return this.callSuper("_getStyleDeclaration", l, c) }, _setStyleDeclaration: function (l, c, r) { var i = this._styleMap[l]; l = i.line, c = i.offset + c, this.styles[l][c] = r }, _deleteStyleDeclaration: function (l, c) { var r = this._styleMap[l]; l = r.line, c = r.offset + c, delete this.styles[l][c] }, _getLineStyle: function (l) { var c = this._styleMap[l]; return !!this.styles[c.line] }, _setLineStyle: function (l) { var c = this._styleMap[l]; this.styles[c.line] = {} }, _wrapText: function (l, c) { var r = [], i; for (this.isWrapping = !0, i = 0; i < l.length; i++)r = r.concat(this._wrapLine(l[i], i, c)); return this.isWrapping = !1, r }, _measureWord: function (l, c, r) { var i = 0, n, o = !0; r = r || 0; for (var p = 0, f = l.length; p < f; p++) { var m = this._getGraphemeBox(l[p], c, p + r, n, o); i += m.kernedWidth, n = l[p] } return i }, _wrapLine: function (l, c, r, tt) { var n = 0, o = this.splitByGrapheme, p = [], f = [], m = o ? a.util.string.graphemeSplit(l) : l.split(this._wordJoiners), y = "", C = 0, x = o ? "" : " ", I = 0, D = 0, P = 0, z = !0, et = this._getWidthOfCharSpacing(), tt = tt || 0; m.length === 0 && m.push([]), r -= tt; for (var st = 0; st < m.length; st++)y = o ? m[st] : a.util.string.graphemeSplit(m[st]), I = this._measureWord(y, c, C), C += y.length, n += D + I - et, n > r && !z ? (p.push(f), f = [], n = I, z = !0) : n += et, !z && !o && f.push(x), f = f.concat(y), D = o ? 0 : this._measureWord([x], c, C), C++, z = !1, I > P && (P = I); return st && p.push(f), P + tt > this.dynamicMinWidth && (this.dynamicMinWidth = P - et + tt), p }, isEndOfWrapping: function (l) { return !this._styleMap[l + 1] || this._styleMap[l + 1].line !== this._styleMap[l].line }, missingNewlineOffset: function (l) { return this.splitByGrapheme ? this.isEndOfWrapping(l) ? 1 : 0 : 1 }, _splitTextIntoLines: function (l) { for (var c = a.Text.prototype._splitTextIntoLines.call(this, l), r = this._wrapText(c.lines, this.width), i = new Array(r.length), n = 0; n < r.length; n++)i[n] = r[n].join(""); return c.lines = i, c.graphemeLines = r, c }, getMinWidth: function () { return Math.max(this.minWidth, this.dynamicMinWidth) }, _removeExtraneousStyles: function () { var l = {}; for (var c in this._styleMap) this._textLines[c] && (l[this._styleMap[c].line] = 1); for (var c in this.styles) l[c] || delete this.styles[c] }, toObject: function (l) { return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(l)) }
  }), a.Textbox.fromObject = function (l, c) { var r = a.util.stylesFromArray(l.styles, l.text), i = Object.assign({}, l, { styles: r }); return a.Object._fromObject("Textbox", i, c, "text") }
}(v), function () { var d = h.controlsUtils, a = d.scaleSkewCursorStyleHandler, l = d.scaleCursorStyleHandler, c = d.scalingEqually, r = d.scalingYOrSkewingX, i = d.scalingXOrSkewingY, n = d.scaleOrSkewActionName, o = h.Object.prototype.controls; if (o.ml = new h.Control({ x: -.5, y: 0, cursorStyleHandler: a, actionHandler: i, getActionName: n }), o.mr = new h.Control({ x: .5, y: 0, cursorStyleHandler: a, actionHandler: i, getActionName: n }), o.mb = new h.Control({ x: 0, y: .5, cursorStyleHandler: a, actionHandler: r, getActionName: n }), o.mt = new h.Control({ x: 0, y: -.5, cursorStyleHandler: a, actionHandler: r, getActionName: n }), o.tl = new h.Control({ x: -.5, y: -.5, cursorStyleHandler: l, actionHandler: c }), o.tr = new h.Control({ x: .5, y: -.5, cursorStyleHandler: l, actionHandler: c }), o.bl = new h.Control({ x: -.5, y: .5, cursorStyleHandler: l, actionHandler: c }), o.br = new h.Control({ x: .5, y: .5, cursorStyleHandler: l, actionHandler: c }), o.mtr = new h.Control({ x: 0, y: -.5, actionHandler: d.rotationWithSnapping, cursorStyleHandler: d.rotationStyleHandler, offsetY: -40, withConnection: !0, actionName: "rotate" }), h.Textbox) { var p = h.Textbox.prototype.controls = {}; p.mtr = o.mtr, p.tr = o.tr, p.br = o.br, p.tl = o.tl, p.bl = o.bl, p.mt = o.mt, p.mb = o.mb, p.mr = new h.Control({ x: .5, y: 0, actionHandler: d.changeWidth, cursorStyleHandler: a, actionName: "resizing" }), p.ml = new h.Control({ x: -.5, y: 0, actionHandler: d.changeWidth, cursorStyleHandler: a, actionName: "resizing" }) } }()
})(ne); const Km = ["onMousewheel"], ku = .05, va = "refer", qm = { __name: "editorMain", props: { draggable: { type: Object, default: null }, canvasInfo: { type: Object, required: !0 } }, emits: ["updataSize", "addDOM", "updataDOM", "updataDOMArray", "removeDOM", "selectDom", "updataIndex"], setup(v, { expose: h, emit: b }) { const E = v; let k = ["referenceLine", "datunBox"]; var _ = []; const S = ye(null), d = ye(null), a = { x: 0, y: 0 }; let l, c = 0, r = 0, i; const n = ye(null), o = (it, O = 2) => parseFloat(it.toFixed(O)), p = it => { k.includes(it.name) || b("updataDOM", { uuid: it.uuid, left: o(it.left), top: o(it.top), width: o(it.width * it.scaleX), height: o(it.height * it.scaleY), angle: it.angle, name: it.name, angleX: 0, angleY: 0 }) }, f = it => { let O = [], V = it._objects; for (let G = 0; G < V.length; G++) { if (k.includes(it.name)) continue; let U = V[G], lt = { uuid: U.uuid, left: o(U.left * it.scaleX + it.left + it.width * it.scaleX / 2), top: o(U.top * it.scaleY + it.top + it.height * it.scaleY / 2), width: o(U.width * U.scaleX * it.scaleX), height: o(U.height * U.scaleY * it.scaleY), angle: it.angle + U.angle, angleX: -o(it.width * it.scaleX / 2 + U.left * it.scaleX), angleY: -o(it.height * it.scaleY / 2 + U.top * it.scaleX), name: U.name }; O.push(lt) } b("updataDOMArray", O) }; function m(it, O, V) { let G = new ne.fabric.Rect({ top: it, left: O, width: V.width || 100, height: V.height || 50, fill: "transparent", type: V.type, mark: V.mark, fabricType: V.fabricType, name: V.name, componentsuuid: V.uuid, uuid: Dc(), angle: 0 }); i.add(G) } const y = () => { c = d.value.offsetWidth, r = d.value.offsetHeight, S.value.setAttribute("width", c), S.value.setAttribute("height", r), i = new ne.fabric.Canvas(S.value, { backgroundColor: "transparent", hasRotatingPoint: !1 }), i.setWidth(c), i.setHeight(r), l = new ne.fabric.Rect({ top: 0, left: 0, fill: "transparent", width: 0, height: 0, name: va, selectable: !1 }), i.add(l), D(), i.on("object:moving", function (it) { let O = it.target; it.target._objects ? f(it.target) : p(O) }), i.on("object:scaling", function (it) { let O = it.target; it.target._objects ? f(it.target) : p(O) }), i.on("object:rotating", function (it) { let O = it.target; it.target._objects ? f(it.target) : p(O) }), i.on("object:skewing", function (it) { it.target }), i.on("object:resizing", function (it) { let O = it.target; it.target._objects ? f(it.target) : p(O) }), i.on("object:added", function (it) { let O = it.target; k.includes(O.name) || b("addDOM", { name: O.name, left: o(O.left), top: o(O.top), width: o(O.width), height: o(O.height), uuid: O.uuid, angle: O.angle, angleX: O.angleX || 0, angleY: O.angleY || 0, zIndex: O.zIndex || i.getObjects().length, mtl: O.mtl || 0, mtr: O.mtr || 0, mbl: O.mbl || 0, mbr: O.mbr || 0, btl: O.btl || 0, btr: O.btr || 0, bbl: O.bbl || 0, bbr: O.bbr || 0, alignH: O.alignH || "", alignW: O.alignW || "", type: O.type, mark: O.mark, componentsuuid: O.componentsuuid, fabricType: O.fabricType, attribute: O.attribute || {}, style: O.style || {}, data: O.data || {}, scaleX: O.scaleX || 1, scaleY: O.scaleY || 1, lockMovementX: O.lockMovementX || !1, lockMovementY: O.lockMovementY || !1 }) }), i.on("object:removed", function (it) { it.target }), i.on("object:selected", function (it) { let O = it.target; k.includes(O.name) }), i.on("object:deselected", function (it) { it.target }), i.on("after:render", function (it) { }), i.on("object:removed", function (it) { var O = it.target; b("removeDOM", O.uuid) }), i.on("selection:created", function (it) { var O = it.selected.filter(V => !k.includes(V.name)); n.value = O }), i.on("selection:updated", function (it) { var O = it.selected.filter(V => !k.includes(V.name)); n.value = O }), i.on("selection:cleared", function () { n.value = null }), ne.fabric.Object.prototype.borderColor = "#F3AF02", ne.fabric.Object.prototype.cornerStyle = "circle", ne.fabric.Object.prototype.cornerColor = "white", ne.fabric.Object.prototype.cornerSize = 10, ne.fabric.Object.prototype.transparentCorners = !1, ne.fabric.Object.prototype.cornerStrokeColor = "gray", ne.fabric.Object.prototype.setControlsVisibility({ mtr: !1 }), i.on("mouse:down", it => { let O = it.e; E.canvasInfo.moveing && (i.isDragging = !0, i.lastPosX = O.clientX, i.lastPosY = O.clientY) }), i.on("mouse:move", it => { if (i.isDragging) { let O = it.e, V = i.viewportTransform; V[4] += O.clientX - i.lastPosX, V[5] += O.clientY - i.lastPosY, i.requestRenderAll(), i.lastPosX = O.clientX, i.lastPosY = O.clientY, i.setViewportTransform(i.viewportTransform), dt() } }), i.on("mouse:up", () => { i.isDragging = !1 }), i.on("object:modified", it => { it.target; var O = i.toJSON(); _.push(O) }), i.on("drop", function (it) { let O = { left: i.getSelectionElement().getBoundingClientRect().left, top: i.getSelectionElement().getBoundingClientRect().top }, V = { x: it.e.x - O.left, y: it.e.y - O.top, markId: 1 }, G = i.restorePointerVpt(V), U = E.draggable; if (U) switch (U.fabricType) { case "rect": m(G.y, G.x, U); break } }) }, C = () => { d.value && (c = d.value.offsetWidth, r = d.value.offsetHeight, S.value.setAttribute("width", c), S.value.setAttribute("height", r), i.setWidth(c), i.setHeight(r), i.renderAll(), D()) }; La(() => { y(), window.addEventListener("resize", C, !1) }); const x = it => { let O = it.layerX, V = it.layerY; if (it.wheelDelta > 0) { if (i.getZoom() < .5) return; i.zoomToPoint(new ne.fabric.Point(O, V), i.getZoom() - ku) } else { if (i.getZoom() > 3.5) return; i.zoomToPoint(new ne.fabric.Point(O, V), i.getZoom() + ku) } D("referenceLine") }, I = it => { a.x = it.layerX, a.y = it.layerY }, D = it => { let G = i.getObjects().filter(lt => lt.name == va)[0].getBoundingRect(); const U = { w: c / G.width, h: r / G.height, left: G.left / G.width, top: G.top / G.height, x: (a.x + G.left) * G.width, y: (a.y + G.top) * G.height, zoom: i.getZoom() }; it === "referenceLine" && i && ct(), b("updataSize", U) }; wn(() => E.canvasInfo.moveing, it => { it && i ? (i.discardActiveObject(), i.selection = !1, i.requestRenderAll()) : i && (i.selection = !0) }), wn(() => n.value, it => { if (it) { let O = it.map(G => G.uuid), V = it.map(G => ({ uuid: G.uuid, lockMovementX: G.lockMovementX, lockMovementY: G.lockMovementY })); b("selectDom", O), b("updataDOMArray", V) } else b("selectDom", null) }, { immediate: !0 }); let P = ["left", "top"]; const z = (it, O, V) => { let U = i.getObjects().filter(lt => lt.uuid == V); if (U && U.length == 1) { if (P.includes(it) && (U[0][it] = O, b("updataDOM", { uuid: V, [it]: O })), it == "width") { let lt = O / U[0].scaleX; U[0].set("width", lt), b("updataDOM", { uuid: V, width: O }) } if (it == "height") { let lt = O / U[0].scaleY; U[0][it] = lt, b("updataDOM", { uuid: V, height: O }) } it == "zIndex" && (U[0].moveTo(O), b("updataIndex", { value: O, uuid: V })), it == "lockMovementY" && (U[0].lockMovementY = O, b("updataDOM", { [it]: O, uuid: V })), it == "lockMovementX" && (U[0].lockMovementX = O, b("updataDOM", { [it]: O, uuid: V })), i.renderAll() } }, et = it => { if (it) { n.value = null; let V = i.getObjects().filter(G => it.includes(G.uuid)); for (let G = 0; G < V.length; G++)i.remove(V[G]); i.discardActiveObject(), i.renderAll() } else i.clear(), i.add(l), D() }; function tt() { if (_.length > 1) { _.pop(); var it = _[_.length - 1]; i.loadFromJSON(it) } } function st() { if (!(_.length < 2)) { var it = _[_.length - 2]; i.loadFromJSON(it), _.pop() } } const dt = () => { var it = i.viewportTransform; let O = it[4], V = it[5]; (O != 0 || V != 0) && D("referenceLine") }, q = (it, O) => { let U = i.getObjects().filter(lt => lt.name == va)[0].getBoundingRect(); if (it == "lineW") { let lt = parseFloat(i.width), H = parseFloat(O.value), R = i.getZoom(), K = new ne.fabric.Line([0, 0, lt, 0], { stroke: "red", strokeWidth: 1, selectable: !1, strokeDashArray: [3, 3], hoverCursor: "pointer" }), J = new ne.fabric.Text(H + " px", { left: 25, top: 5, fontSize: 12, fill: "#fff" }), ht = "M10 0 L0 10 M0 0 L10 10", ut = new ne.fabric.Path(ht, { stroke: "red", strokeWidth: 1, selectable: !1, left: 10, top: 5, hoverCursor: "text" }); K.hoverCursor = "row-resize"; let _t = new ne.fabric.Group([K, J, ut], { left: -(U.left / U.width), top: H, width: lt, name: "referenceLine", selectable: !1, lockMovementX: !0, lineType: it, scaleX: 1 / R, scaleY: 1 / R }); i.add(_t), _t.on("click", St => { }); let mt = _t.item(1); _t.on("mousedown", function (St) { if (St.pointer.x < 20) { i.remove(_t), i.discardActiveObject(), i.renderAll(); return } i.selection = !1; var gt = { x: St.target.left, y: St.target.top, offsetX: St.e.offsetX, offsetY: St.e.offsetY, scaleX: St.target.scaleX, scaleY: St.target.scaleY }; ne.fabric.util.addListener(document, "mousemove", ft), ne.fabric.util.addListener(document, "mouseup", wt); function ft(xt) { if (E.canvasInfo.moveing) return; let pt = (xt.offsetY - gt.offsetY) * gt.scaleY + gt.y; _t.set({ top: pt }), mt.set({ text: parseInt(pt) + "px" }), i.requestRenderAll() } function wt() { i.setZoom(i.getZoom()), i.selection = !0, ne.fabric.util.removeListener(document, "mousemove", ft), ne.fabric.util.removeListener(document, "mouseup", wt) } }) } else { let lt = parseFloat(i.height), H = parseFloat(O.value), R = i.getZoom(), K = new ne.fabric.Line([0, 0, 0, lt], { stroke: "red", strokeWidth: 1, selectable: !1, strokeDashArray: [3, 3] }), J = new ne.fabric.Text(H + " px", { left: 25, top: 5, fontSize: 12, fill: "#fff" }), ht = "M10 0 L0 10 M0 0 L10 10", ut = new ne.fabric.Path(ht, { stroke: "red", strokeWidth: 1, selectable: !1, left: 10, top: 5 }), _t = new ne.fabric.Group([K, J, ut], { left: H, top: -(U.top / U.height), height: i.height, name: "referenceLine", selectable: !1, lockMovementY: !0, lineType: it, scaleX: 1 / R, scaleY: 1 / R }); _t.hoverCursor = "col-resize", i.add(_t), _t.on("mousedown", function (mt) { if (mt.pointer.y < 20) { i.remove(_t), i.discardActiveObject(), i.renderAll(); return } i.selection = !1; var St = { x: mt.target.left, y: mt.target.top, offsetX: mt.e.offsetX, offsetY: mt.e.offsetY, scaleX: mt.target.scaleX, scaleY: mt.target.scaleY }; ne.fabric.util.addListener(document, "mousemove", gt), ne.fabric.util.addListener(document, "mouseup", ft); function gt(wt) { if (E.canvasInfo.moveing) return; var xt = _t.item(1); let pt = (wt.offsetX - St.offsetX) * St.scaleX + St.x; _t.set({ left: pt }), xt.set({ text: parseInt(pt) + "px" }), i.requestRenderAll() } function ft() { i.setZoom(i.getZoom()), i.selection = !0, ne.fabric.util.removeListener(document, "mousemove", gt), ne.fabric.util.removeListener(document, "mouseup", ft) } }) } }, ct = () => { let V = i.getObjects().filter(H => H.name == va)[0].getBoundingRect(), U = i.getObjects().filter(H => k.includes(H.name)), lt = i.getZoom(); for (let H = 0; H < U.length; H++)U[H].lineType == "lineW" ? U[H].set({ scaleX: 1 / lt, scaleY: 1 / lt, left: -(V.left / V.width), width: i.width }) : U[H].set({ scaleX: 1 / lt, scaleY: 1 / lt, top: -(V.top / V.height), height: i.height }), i.renderAll() }; function W(it) { let O = new ne.fabric.Rect({ ...it, fill: "transparent" }); i.add(O) } return h({ updataFiles: z, deleteItem: et, undo: tt, redo: st, creatLine: q, setCanvas: it => { for (let O in it) W(it[O]) }, selectCanvas: it => { let V = i.getObjects().filter(G => G.uuid == it.uuid); V.length > 0 && (i.setActiveObject(V[0]), i.renderAll()) } }), (it, O) => (zt(), fe("div", { class: "td-editor-main-box", ref_key: "apEditorMain", ref: d, onMousewheel: Tc(x, ["prevent"]), onMousemove: I }, [Vt("canvas", { ref_key: "apEditorCanvas", ref: S, width: "100%", height: "100%" }, null, 512)], 40, Km)) } }; const Jm = ["set-key"], Zm = { __name: "editorWhiteboard", props: { editorMainInfo: { type: Object, require: !0 }, positionInfo: { type: Object, require: !0 }, domData: { type: Object, default: {} }, domInfo: { type: Object, default: {} } }, setup(v) { const h = v, b = qe(() => Object.values(h.domData)), E = Js({ left: 5e3, top: 5e3, x: 0, y: 0 }), k = qe(() => ({ left: -E.left + "px", top: -E.top + "px", transformOrigin: `${E.left}px ${E.top}px`, transform: `scale(${h.positionInfo.zoom})`, width: `${h.positionInfo.w * 200}px`, height: `${h.positionInfo.h * 200}px` })); return (_, S) => (zt(), fe("div", { class: "td-editor-whiteboard", style: ha({ height: v.editorMainInfo.h + "px", width: v.editorMainInfo.w + "px" }) }, [Vt("div", { class: "td-editor-whiteboard-box", style: ha(k.value) }, [(zt(!0), fe(Xi, null, Ki(b.value, d => (zt(), fe("div", { key: d.uuid + d.width + d.height + d.mtl + d.mtr + d.mbr + d.mbl, class: "td-editor-whiteboard-box-item", style: ha({ left: E.left + h.positionInfo.left + d.left + "px", top: E.top + h.positionInfo.top + d.top + "px", width: d.width + "px", height: d.height + "px", transform: `rotate(${d.angle}deg)`, transformOrigin: `${d.angleX}px ${d.angleY}px`, zIndex: d.zIndex, borderRadius: `${d.btl}px ${d.btr}px ${d.bbr}px ${d.bbl}px`, padding: `${d.mtl}px ${d.mtr}px ${d.mbr}px ${d.mbl}px`, alignItems: `${d.alignW}`, justifyContent: `${d.alignH}` }), "set-key": d.uuid }, [(zt(), le(Fu(d.type), Ec({ class: "td-editor-whiteboard-box-item-com", key: d.uuid }, d.attribute), null, 16))], 12, Jm))), 128)), Vt("h1", null, Tn(v.domInfo.backgroundColor), 1), Vt("div", { class: "td-editor-whiteboard-border", style: ha({ left: E.left + h.positionInfo.left + "px", top: E.top + h.positionInfo.top + "px", width: v.domInfo.width, height: v.domInfo.height, backgroundColor: v.domInfo.backgroundColor ? v.domInfo.backgroundColor : "transparent" }) }, null, 4)], 4)], 4)) } }, $m = Ci(Zm, [["__scopeId", "data-v-07992c1d"]]); const t0 = { class: "td-editor" }, e0 = { class: "td-editor-rod" }, i0 = { __name: "index", props: { domData: { type: Object, required: !0 }, draggable: { type: Object, default: null }, canvasInfo: { type: Object, required: !0 }, domInfo: { type: Object, required: !0 } }, emits: ["addDOM", "updataDOM", "updataDOMArray", "removeDOM", "selectDom", "updataIndex"], setup(v, { expose: h, emit: b }) { const E = ye(null), k = ye(null), _ = D => { b("addDOM", D) }, S = D => { b("updataDOM", D) }, d = D => { b("updataDOMArray", D) }, a = D => { b("removeDOM", D) }, l = D => { b("updataDOM", { uuid: D.uuid, zIndex: D.value }) }, c = Js({ w: 0, h: 0 }), r = ye({ w: 0, h: 0, left: 0, top: 0, x: 0, y: 0, zoom: 0 }), i = D => { r.value = { ...D } }, n = () => { c.w = k.value.offsetWidth, c.h = k.value.offsetHeight }; La(() => { n() }); const o = D => { b("selectDom", D) }; return h({ updataFiles: (D, P, z) => { E.value.updataFiles(D, P, z) }, deleteItem: D => { E.value.deleteItem(D) }, undo: () => { E.value.undo() }, redo: () => { E.value.redo() }, creatLine: (D, P) => { E.value.creatLine(D, P) }, setCanvas: D => { E.value.setCanvas(D) }, selectCanvas: D => { E.value.selectCanvas(D) } }), (D, P) => (zt(), fe("div", t0, [Vt("div", e0, [Jt(Gm, { positionInfo: r.value }, null, 8, ["positionInfo"])]), Vt("div", { class: "td-editor-main", ref_key: "editorMain", ref: k }, [Jt(qm, { onUpdataSize: i, onAddDOM: _, onUpdataDOM: S, onUpdataDOMArray: d, onRemoveDOM: a, onSelectDom: o, onUpdataIndex: l, draggable: v.draggable, canvasInfo: v.canvasInfo, ref_key: "EditorMainRef", ref: E }, null, 8, ["draggable", "canvasInfo"]), Jt($m, { editorMainInfo: c, positionInfo: r.value, domData: v.domData, class: "td-editor-mainBoard", domInfo: v.domInfo }, null, 8, ["editorMainInfo", "positionInfo", "domData", "domInfo"])], 512)])) } }, r0 = Ci(i0, [["__scopeId", "data-v-02e20b7b"]]); const n0 = { class: "arrayValue" }, a0 = { __name: "arrayValue", props: { modelValue: { default: () => [], type: Array }, length: { default: 1, type: Number } }, emits: ["update:modelValue", "change"], setup(v, { emit: h }) { const b = v; function E(S) { return /^#(?:[0-9a-fA-F]{3}){1,2}$/.test(S) } const k = ye(b.modelValue ? b.modelValue.join(",") : ""), _ = S => { if (S.length > 0) { let d = S.split(","), a = -1; for (let l = 0; l < d.length; l++)if (!E(d[l])) { a = l; break } a > -1 ? Ws.error("第" + (a + 1) + "个值不符合颜色值") : (d.length > b.length && (d.length = b.length), h("update:modelValue", d), h("change", d)) } }; return (S, d) => { const a = ce("el-input"); return zt(), fe("div", n0, [Jt(a, { modelValue: k.value, "onUpdate:modelValue": d[0] || (d[0] = l => k.value = l), placeholder: "请使用 , 分割多值", onChange: _ }, null, 8, ["modelValue"])]) } } }, s0 = Ci(a0, [["__scopeId", "data-v-b4141bc3"]]); const o0 = { class: "td-editor-style" }, l0 = { __name: "styleItem", props: { itemData: Object, itemTable: Object, active: { type: Array, default: null }, type: String, selectId: String }, setup(v) { const h = v, b = ye(h.active), E = qe(() => h.itemData), k = xa("updataRight", null), _ = d => { h.selectId && k(d, E.value[d], h.selectId, h.type) }, S = d => { h.selectId && k(d, E.value[d], h.selectId, h.type) }; return (d, a) => { const l = ce("el-input-number"), c = ce("el-option"), r = ce("el-select"), i = ce("el-input"), n = ce("el-switch"), o = ce("el-radio"), p = ce("el-radio-group"), f = ce("el-color-picker"), m = ce("el-form-item"), y = ce("el-form"), C = ce("el-collapse-item"), x = ce("el-collapse"); return zt(), fe("div", o0, [Jt(x, { modelValue: b.value, "onUpdate:modelValue": a[0] || (a[0] = I => b.value = I) }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(v.itemTable, (I, D) => (zt(), le(C, { title: I.name, name: I.value, key: D }, { default: Oe(() => [Jt(y, { model: E.value, "label-width": "100px", style: { "padding-right": "10px", "box-sizing": "border-box" }, "label-position": "top" }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(I.children, (P, z) => (zt(), le(m, { label: P.name, key: z, precision: 2 }, { default: Oe(() => [P.type === "el-input-number" ? (zt(), le(l, { key: 0, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => _(P.field), min: isNaN(P.min) ? P.min : -1 / 0, max: isNaN(P.max) ? P.max : 1 / 0 }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange", "min", "max"])) : Re("", !0), P.type === "el-select" ? (zt(), le(r, { key: 1, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => S(P.field), style: { width: "100%" } }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(P.options, et => (zt(), le(c, { key: et.value, label: et.label, value: et.value }, null, 8, ["label", "value"]))), 128))]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue", "onChange"])) : Re("", !0), P.type === "el-input" ? (zt(), le(i, { key: 2, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onInput: et => _(P.field) }, null, 8, ["modelValue", "onUpdate:modelValue", "onInput"])) : Re("", !0), P.type === "el-switch" ? (zt(), le(n, { key: 3, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => _(P.field) }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])) : Re("", !0), P.type === "el-radio" ? (zt(), le(p, { key: 4, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => _(P.field) }, { default: Oe(() => [(zt(!0), fe(Xi, null, Ki(P.options, (et, tt) => (zt(), le(o, { label: et.value, size: "large", key: tt }, { default: Oe(() => [Ns(Tn(et.label), 1)]), _: 2 }, 1032, ["label"]))), 128))]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue", "onChange"])) : Re("", !0), P.type === "el-color-picker" ? (zt(), le(f, { key: 5, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => _(P.field), "show-alpha": "", predefine: P.predefineColors }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange", "predefine"])) : Re("", !0), P.type === "ArrayColorValue" ? (zt(), le(s0, { key: 6, modelValue: E.value[P.field], "onUpdate:modelValue": et => E.value[P.field] = et, onChange: et => _(P.field), length: 2 }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])) : Re("", !0)]), _: 2 }, 1032, ["label"]))), 128))]), _: 2 }, 1032, ["model"])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 }, 8, ["modelValue"])]) } } }, Mu = Ci(l0, [["__scopeId", "data-v-89ae80f5"]]); var Qs = { exports: {} }, Ou; function kn() {
  return Ou || (Ou = 1, function (v, h) {
    (function (b, E) { v.exports = E() })(Ic, function () {
      var b = navigator.userAgent, E = navigator.platform, k = /gecko\/\d/i.test(b), _ = /MSIE \d/.test(b), S = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(b), d = /Edge\/(\d+)/.exec(b), a = _ || S || d, l = a && (_ ? document.documentMode || 6 : +(d || S)[1]), c = !d && /WebKit\//.test(b), r = c && /Qt\/\d+\.\d+/.test(b), i = !d && /Chrome\/(\d+)/.exec(b), n = i && +i[1], o = /Opera\//.test(b), p = /Apple Computer/.test(navigator.vendor), f = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(b), m = /PhantomJS/.test(b), y = p && (/Mobile\/\w+/.test(b) || navigator.maxTouchPoints > 2), C = /Android/.test(b), x = y || C || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(b), I = y || /Mac/.test(E), D = /\bCrOS\b/.test(b), P = /win/i.test(E), z = o && b.match(/Version\/(\d*\.\d*)/); z && (z = Number(z[1])), z && z >= 15 && (o = !1, c = !0); var et = I && (r || o && (z == null || z < 12.11)), tt = k || a && l >= 9; function st(t) { return new RegExp("(^|\\s)" + t + "(?:$|\\s)\\s*") } var dt = function (t, e) { var u = t.className, s = st(e).exec(u); if (s) { var g = u.slice(s.index + s[0].length); t.className = u.slice(0, s.index) + (g ? s[1] + g : "") } }; function q(t) { for (var e = t.childNodes.length; e > 0; --e)t.removeChild(t.firstChild); return t } function ct(t, e) { return q(t).appendChild(e) } function W(t, e, u, s) { var g = document.createElement(t); if (u && (g.className = u), s && (g.style.cssText = s), typeof e == "string") g.appendChild(document.createTextNode(e)); else if (e) for (var A = 0; A < e.length; ++A)g.appendChild(e[A]); return g } function Dt(t, e, u, s) { var g = W(t, e, u, s); return g.setAttribute("role", "presentation"), g } var Lt; document.createRange ? Lt = function (t, e, u, s) { var g = document.createRange(); return g.setEnd(s || t, u), g.setStart(t, e), g } : Lt = function (t, e, u) { var s = document.body.createTextRange(); try { s.moveToElementText(t.parentNode) } catch { return s } return s.collapse(!0), s.moveEnd("character", u), s.moveStart("character", e), s }; function it(t, e) { if (e.nodeType == 3 && (e = e.parentNode), t.contains) return t.contains(e); do if (e.nodeType == 11 && (e = e.host), e == t) return !0; while (e = e.parentNode) } function O(t) { var e; try { e = t.activeElement } catch { e = t.body || null } for (; e && e.shadowRoot && e.shadowRoot.activeElement;)e = e.shadowRoot.activeElement; return e } function V(t, e) { var u = t.className; st(e).test(u) || (t.className += (u ? " " : "") + e) } function G(t, e) { for (var u = t.split(" "), s = 0; s < u.length; s++)u[s] && !st(u[s]).test(e) && (e += " " + u[s]); return e } var U = function (t) { t.select() }; y ? U = function (t) { t.selectionStart = 0, t.selectionEnd = t.value.length } : a && (U = function (t) { try { t.select() } catch { } }); function lt(t) { return t.display.wrapper.ownerDocument } function H(t) { return lt(t).defaultView } function R(t) { var e = Array.prototype.slice.call(arguments, 1); return function () { return t.apply(null, e) } } function K(t, e, u) { e || (e = {}); for (var s in t) t.hasOwnProperty(s) && (u !== !1 || !e.hasOwnProperty(s)) && (e[s] = t[s]); return e } function J(t, e, u, s, g) { e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length)); for (var A = s || 0, w = g || 0; ;) { var T = t.indexOf("	", A); if (T < 0 || T >= e) return w + (e - A); w += T - A, w += u - w % u, A = T + 1 } } var ht = function () { this.id = null, this.f = null, this.time = 0, this.handler = R(this.onTimeout, this) }; ht.prototype.onTimeout = function (t) { t.id = 0, t.time <= +new Date ? t.f() : setTimeout(t.handler, t.time - +new Date) }, ht.prototype.set = function (t, e) { this.f = e; var u = +new Date + t; (!this.id || u < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, t), this.time = u) }; function ut(t, e) { for (var u = 0; u < t.length; ++u)if (t[u] == e) return u; return -1 } var _t = 50, mt = { toString: function () { return "CodeMirror.Pass" } }, St = { scroll: !1 }, gt = { origin: "*mouse" }, ft = { origin: "+move" }; function wt(t, e, u) { for (var s = 0, g = 0; ;) { var A = t.indexOf("	", s); A == -1 && (A = t.length); var w = A - s; if (A == t.length || g + w >= e) return s + Math.min(w, e - g); if (g += A - s, g += u - g % u, s = A + 1, g >= e) return s } } var xt = [""]; function pt(t) { for (; xt.length <= t;)xt.push(vt(xt) + " "); return xt[t] } function vt(t) { return t[t.length - 1] } function kt(t, e) { for (var u = [], s = 0; s < t.length; s++)u[s] = e(t[s], s); return u } function L(t, e, u) { for (var s = 0, g = u(e); s < t.length && u(t[s]) <= g;)s++; t.splice(s, 0, e) } function N() { } function Q(t, e) { var u; return Object.create ? u = Object.create(t) : (N.prototype = t, u = new N), e && K(e, u), u } var $ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; function rt(t) { return /\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || $.test(t)) } function at(t, e) { return e ? e.source.indexOf("\\w") > -1 && rt(t) ? !0 : e.test(t) : rt(t) } function yt(t) { for (var e in t) if (t.hasOwnProperty(e) && t[e]) return !1; return !0 } var bt = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/; function Et(t) { return t.charCodeAt(0) >= 768 && bt.test(t) } function Ft(t, e, u) { for (; (u < 0 ? e > 0 : e < t.length) && Et(t.charAt(e));)e += u; return e } function Qt(t, e, u) { for (var s = e > u ? -1 : 1; ;) { if (e == u) return e; var g = (e + u) / 2, A = s < 0 ? Math.ceil(g) : Math.floor(g); if (A == e) return t(A) ? e : u; t(A) ? u = A : e = A + s } } function jt(t, e, u, s) { if (!t) return s(e, u, "ltr", 0); for (var g = !1, A = 0; A < t.length; ++A) { var w = t[A]; (w.from < u && w.to > e || e == u && w.to == e) && (s(Math.max(w.from, e), Math.min(w.to, u), w.level == 1 ? "rtl" : "ltr", A), g = !0) } g || s(e, u, "ltr") } var Gt = null; function Kt(t, e, u) { var s; Gt = null; for (var g = 0; g < t.length; ++g) { var A = t[g]; if (A.from < e && A.to > e) return g; A.to == e && (A.from != A.to && u == "before" ? s = g : Gt = g), A.from == e && (A.from != A.to && u != "before" ? s = g : Gt = g) } return s ?? Gt } var ae = function () { var t = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", e = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111"; function u(M) { return M <= 247 ? t.charAt(M) : 1424 <= M && M <= 1524 ? "R" : 1536 <= M && M <= 1785 ? e.charAt(M - 1536) : 1774 <= M && M <= 2220 ? "r" : 8192 <= M && M <= 8203 ? "w" : M == 8204 ? "b" : "L" } var s = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, g = /[stwN]/, A = /[LRr]/, w = /[Lb1n]/, T = /[1n]/; function B(M, Y, j) { this.level = M, this.from = Y, this.to = j } return function (M, Y) { var j = Y == "ltr" ? "L" : "R"; if (M.length == 0 || Y == "ltr" && !s.test(M)) return !1; for (var ot = M.length, nt = [], Ct = 0; Ct < ot; ++Ct)nt.push(u(M.charCodeAt(Ct))); for (var Tt = 0, Bt = j; Tt < ot; ++Tt) { var Mt = nt[Tt]; Mt == "m" ? nt[Tt] = Bt : Bt = Mt } for (var Pt = 0, Ot = j; Pt < ot; ++Pt) { var Rt = nt[Pt]; Rt == "1" && Ot == "r" ? nt[Pt] = "n" : A.test(Rt) && (Ot = Rt, Rt == "r" && (nt[Pt] = "R")) } for (var Yt = 1, Nt = nt[0]; Yt < ot - 1; ++Yt) { var Xt = nt[Yt]; Xt == "+" && Nt == "1" && nt[Yt + 1] == "1" ? nt[Yt] = "1" : Xt == "," && Nt == nt[Yt + 1] && (Nt == "1" || Nt == "n") && (nt[Yt] = Nt), Nt = Xt } for (var se = 0; se < ot; ++se) { var Ie = nt[se]; if (Ie == ",") nt[se] = "N"; else if (Ie == "%") { var he = void 0; for (he = se + 1; he < ot && nt[he] == "%"; ++he); for (var Ge = se && nt[se - 1] == "!" || he < ot && nt[he] == "1" ? "1" : "N", Ye = se; Ye < he; ++Ye)nt[Ye] = Ge; se = he - 1 } } for (var Ae = 0, Ve = j; Ae < ot; ++Ae) { var Me = nt[Ae]; Ve == "L" && Me == "1" ? nt[Ae] = "L" : A.test(Me) && (Ve = Me) } for (var _e = 0; _e < ot; ++_e)if (g.test(nt[_e])) { var Ce = void 0; for (Ce = _e + 1; Ce < ot && g.test(nt[Ce]); ++Ce); for (var pe = (_e ? nt[_e - 1] : j) == "L", ze = (Ce < ot ? nt[Ce] : j) == "L", Mr = pe == ze ? pe ? "L" : "R" : j, ji = _e; ji < Ce; ++ji)nt[ji] = Mr; _e = Ce - 1 } for (var Le = [], mi, Be = 0; Be < ot;)if (w.test(nt[Be])) { var Ms = Be; for (++Be; Be < ot && w.test(nt[Be]); ++Be); Le.push(new B(0, Ms, Be)) } else { var Mi = Be, ar = Le.length, sr = Y == "rtl" ? 1 : 0; for (++Be; Be < ot && nt[Be] != "L"; ++Be); for (var Pe = Mi; Pe < Be;)if (T.test(nt[Pe])) { Mi < Pe && (Le.splice(ar, 0, new B(1, Mi, Pe)), ar += sr); var Or = Pe; for (++Pe; Pe < Be && T.test(nt[Pe]); ++Pe); Le.splice(ar, 0, new B(2, Or, Pe)), ar += sr, Mi = Pe } else ++Pe; Mi < Be && Le.splice(ar, 0, new B(1, Mi, Be)) } return Y == "ltr" && (Le[0].level == 1 && (mi = M.match(/^\s+/)) && (Le[0].from = mi[0].length, Le.unshift(new B(0, 0, mi[0].length))), vt(Le).level == 1 && (mi = M.match(/\s+$/)) && (vt(Le).to -= mi[0].length, Le.push(new B(0, ot - mi[0].length, ot)))), Y == "rtl" ? Le.reverse() : Le } }(); function ee(t, e) { var u = t.order; return u == null && (u = t.order = ae(t.text, e)), u } var ke = [], It = function (t, e, u) { if (t.addEventListener) t.addEventListener(e, u, !1); else if (t.attachEvent) t.attachEvent("on" + e, u); else { var s = t._handlers || (t._handlers = {}); s[e] = (s[e] || ke).concat(u) } }; function Li(t, e) { return t._handlers && t._handlers[e] || ke } function be(t, e, u) { if (t.removeEventListener) t.removeEventListener(e, u, !1); else if (t.detachEvent) t.detachEvent("on" + e, u); else { var s = t._handlers, g = s && s[e]; if (g) { var A = ut(g, u); A > -1 && (s[e] = g.slice(0, A).concat(g.slice(A + 1))) } } } function ie(t, e) { var u = Li(t, e); if (u.length) for (var s = Array.prototype.slice.call(arguments, 2), g = 0; g < u.length; ++g)u[g].apply(null, s) } function oe(t, e, u) { return typeof e == "string" && (e = { type: e, preventDefault: function () { this.defaultPrevented = !0 } }), ie(t, u || e.type, t, e), ti(e) || e.codemirrorIgnore } function qi(t) { var e = t._handlers && t._handlers.cursorActivity; if (e) for (var u = t.curOp.cursorActivityHandlers || (t.curOp.cursorActivityHandlers = []), s = 0; s < e.length; ++s)ut(u, e[s]) == -1 && u.push(e[s]) } function we(t, e) { return Li(t, e).length > 0 } function ve(t) { t.prototype.on = function (e, u) { It(this, e, u) }, t.prototype.off = function (e, u) { be(this, e, u) } } function de(t) { t.preventDefault ? t.preventDefault() : t.returnValue = !1 } function fi(t) { t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0 } function ti(t) { return t.defaultPrevented != null ? t.defaultPrevented : t.returnValue == !1 } function wi(t) { de(t), fi(t) } function Qe(t) { return t.target || t.srcElement } function Wr(t) { var e = t.which; return e == null && (t.button & 1 ? e = 1 : t.button & 2 ? e = 3 : t.button & 4 && (e = 2)), I && t.ctrlKey && e == 1 && (e = 3), e } var Qa = function () { if (a && l < 9) return !1; var t = W("div"); return "draggable" in t || "dragDrop" in t }(), Ze; function Wa(t) { if (Ze == null) { var e = W("span", "​"); ct(t, W("span", [e, document.createTextNode("x")])), t.firstChild.offsetHeight != 0 && (Ze = e.offsetWidth <= 1 && e.offsetHeight > 2 && !(a && l < 8)) } var u = Ze ? W("span", "​") : W("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px"); return u.setAttribute("cm-text", ""), u } var hr; function Mn(t) { if (hr != null) return hr; var e = ct(t, document.createTextNode("AخA")), u = Lt(e, 0, 1).getBoundingClientRect(), s = Lt(e, 1, 2).getBoundingClientRect(); return q(t), !u || u.left == u.right ? !1 : hr = s.right - u.right < 3 } var Nr = `

b`.split(/\n/).length != 3 ? function (t) {
        for (var e = 0, u = [], s = t.length; e <= s;) {
          var g = t.indexOf(`
`, e); g == -1 && (g = t.length); var A = t.slice(e, t.charAt(g - 1) == "\r" ? g - 1 : g), w = A.indexOf("\r"); w != -1 ? (u.push(A.slice(0, w)), e += w + 1) : (u.push(A), e = g + 1)
        } return u
      } : function (t) { return t.split(/\r\n?|\n/) }, Fi = window.getSelection ? function (t) { try { return t.selectionStart != t.selectionEnd } catch { return !1 } } : function (t) { var e; try { e = t.ownerDocument.selection.createRange() } catch { } return !e || e.parentElement() != t ? !1 : e.compareEndPoints("StartToEnd", e) != 0 }, hi = function () { var t = W("div"); return "oncopy" in t ? !0 : (t.setAttribute("oncopy", "return;"), typeof t.oncopy == "function") }(), ci = null; function On(t) { if (ci != null) return ci; var e = ct(t, W("span", "x")), u = e.getBoundingClientRect(), s = Lt(e, 0, 1).getBoundingClientRect(); return ci = Math.abs(u.left - s.left) > 1 } var ei = {}, Pi = {}; function Dn(t, e) { arguments.length > 2 && (e.dependencies = Array.prototype.slice.call(arguments, 2)), ei[t] = e } function cr(t, e) { Pi[t] = e } function Ue(t) { if (typeof t == "string" && Pi.hasOwnProperty(t)) t = Pi[t]; else if (t && typeof t.name == "string" && Pi.hasOwnProperty(t.name)) { var e = Pi[t.name]; typeof e == "string" && (e = { name: e }), t = Q(e, t), t.name = e.name } else { if (typeof t == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(t)) return Ue("application/xml"); if (typeof t == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(t)) return Ue("application/json") } return typeof t == "string" ? { name: t } : t || { name: "null" } } function xi(t, e) { e = Ue(e); var u = ei[e.name]; if (!u) return xi(t, "text/plain"); var s = u(t, e); if (Ri.hasOwnProperty(e.name)) { var g = Ri[e.name]; for (var A in g) g.hasOwnProperty(A) && (s.hasOwnProperty(A) && (s["_" + A] = s[A]), s[A] = g[A]) } if (s.name = e.name, e.helperType && (s.helperType = e.helperType), e.modeProps) for (var w in e.modeProps) s[w] = e.modeProps[w]; return s } var Ri = {}; function Ln(t, e) { var u = Ri.hasOwnProperty(t) ? Ri[t] : Ri[t] = {}; K(e, u) } function _i(t, e) { if (e === !0) return e; if (t.copyState) return t.copyState(e); var u = {}; for (var s in e) { var g = e[s]; g instanceof Array && (g = g.concat([])), u[s] = g } return u } function Qi(t, e) { for (var u; t.innerMode && (u = t.innerMode(e), !(!u || u.mode == t));)e = u.state, t = u.mode; return u || { mode: t, state: e } } function Yr(t, e, u) { return t.startState ? t.startState(e, u) : !0 } var ge = function (t, e, u) { this.pos = this.start = 0, this.string = t, this.tabSize = e || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = u }; ge.prototype.eol = function () { return this.pos >= this.string.length }, ge.prototype.sol = function () { return this.pos == this.lineStart }, ge.prototype.peek = function () { return this.string.charAt(this.pos) || void 0 }, ge.prototype.next = function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++) }, ge.prototype.eat = function (t) { var e = this.string.charAt(this.pos), u; if (typeof t == "string" ? u = e == t : u = e && (t.test ? t.test(e) : t(e)), u) return ++this.pos, e }, ge.prototype.eatWhile = function (t) { for (var e = this.pos; this.eat(t);); return this.pos > e }, ge.prototype.eatSpace = function () { for (var t = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos; return this.pos > t }, ge.prototype.skipToEnd = function () { this.pos = this.string.length }, ge.prototype.skipTo = function (t) { var e = this.string.indexOf(t, this.pos); if (e > -1) return this.pos = e, !0 }, ge.prototype.backUp = function (t) { this.pos -= t }, ge.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = J(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? J(this.string, this.lineStart, this.tabSize) : 0) }, ge.prototype.indentation = function () { return J(this.string, null, this.tabSize) - (this.lineStart ? J(this.string, this.lineStart, this.tabSize) : 0) }, ge.prototype.match = function (t, e, u) { if (typeof t == "string") { var s = function (w) { return u ? w.toLowerCase() : w }, g = this.string.substr(this.pos, t.length); if (s(g) == s(t)) return e !== !1 && (this.pos += t.length), !0 } else { var A = this.string.slice(this.pos).match(t); return A && A.index > 0 ? null : (A && e !== !1 && (this.pos += A[0].length), A) } }, ge.prototype.current = function () { return this.string.slice(this.start, this.pos) }, ge.prototype.hideFirstChars = function (t, e) { this.lineStart += t; try { return e() } finally { this.lineStart -= t } }, ge.prototype.lookAhead = function (t) { var e = this.lineOracle; return e && e.lookAhead(t) }, ge.prototype.baseToken = function () { var t = this.lineOracle; return t && t.baseToken(this.pos) }; function Wt(t, e) { if (e -= t.first, e < 0 || e >= t.size) throw new Error("There is no line " + (e + t.first) + " in the document."); for (var u = t; !u.lines;)for (var s = 0; ; ++s) { var g = u.children[s], A = g.chunkSize(); if (e < A) { u = g; break } e -= A } return u.lines[e] } function Si(t, e, u) { var s = [], g = e.line; return t.iter(e.line, u.line + 1, function (A) { var w = A.text; g == u.line && (w = w.slice(0, u.ch)), g == e.line && (w = w.slice(e.ch)), s.push(w), ++g }), s } function dr(t, e, u) { var s = []; return t.iter(e, u, function (g) { s.push(g.text) }), s } function $e(t, e) { var u = e - t.height; if (u) for (var s = t; s; s = s.parent)s.height += u } function $t(t) { if (t.parent == null) return null; for (var e = t.parent, u = ut(e.lines, t), s = e.parent; s; e = s, s = s.parent)for (var g = 0; s.children[g] != e; ++g)u += s.children[g].chunkSize(); return u + e.first } function di(t, e) { var u = t.first; t: do { for (var s = 0; s < t.children.length; ++s) { var g = t.children[s], A = g.height; if (e < A) { t = g; continue t } e -= A, u += g.chunkSize() } return u } while (!t.lines); for (var w = 0; w < t.lines.length; ++w) { var T = t.lines[w], B = T.height; if (e < B) break; e -= B } return u + w } function F(t, e) { return e >= t.first && e < t.first + t.size } function X(t, e) { return String(t.lineNumberFormatter(e + t.firstLineNumber)) } function Z(t, e, u) { if (u === void 0 && (u = null), !(this instanceof Z)) return new Z(t, e, u); this.line = t, this.ch = e, this.sticky = u } function At(t, e) { return t.line - e.line || t.ch - e.ch } function Ut(t, e) { return t.sticky == e.sticky && At(t, e) == 0 } function qt(t) { return Z(t.line, t.ch) } function Zt(t, e) { return At(t, e) < 0 ? e : t } function xe(t, e) { return At(t, e) < 0 ? t : e } function Xe(t, e) { return Math.max(t.first, Math.min(e, t.first + t.size - 1)) } function Ht(t, e) { if (e.line < t.first) return Z(t.first, 0); var u = t.first + t.size - 1; return e.line > u ? Z(u, Wt(t, u).text.length) : Tf(e, Wt(t, e.line).text.length) } function Tf(t, e) { var u = t.ch; return u == null || u > e ? Z(t.line, e) : u < 0 ? Z(t.line, 0) : t } function lo(t, e) { for (var u = [], s = 0; s < e.length; s++)u[s] = Ht(t, e[s]); return u } var Fn = function (t, e) { this.state = t, this.lookAhead = e }, gi = function (t, e, u, s) { this.state = e, this.doc = t, this.line = u, this.maxLookAhead = s || 0, this.baseTokens = null, this.baseTokenPos = 1 }; gi.prototype.lookAhead = function (t) { var e = this.doc.getLine(this.line + t); return e != null && t > this.maxLookAhead && (this.maxLookAhead = t), e }, gi.prototype.baseToken = function (t) { if (!this.baseTokens) return null; for (; this.baseTokens[this.baseTokenPos] <= t;)this.baseTokenPos += 2; var e = this.baseTokens[this.baseTokenPos + 1]; return { type: e && e.replace(/( |^)overlay .*/, ""), size: this.baseTokens[this.baseTokenPos] - t } }, gi.prototype.nextLine = function () { this.line++, this.maxLookAhead > 0 && this.maxLookAhead-- }, gi.fromSaved = function (t, e, u) { return e instanceof Fn ? new gi(t, _i(t.mode, e.state), u, e.lookAhead) : new gi(t, _i(t.mode, e), u) }, gi.prototype.save = function (t) { var e = t !== !1 ? _i(this.doc.mode, this.state) : this.state; return this.maxLookAhead > 0 ? new Fn(e, this.maxLookAhead) : e }; function uo(t, e, u, s) { var g = [t.state.modeGen], A = {}; vo(t, e.text, t.doc.mode, u, function (M, Y) { return g.push(M, Y) }, A, s); for (var w = u.state, T = function (M) { u.baseTokens = g; var Y = t.state.overlays[M], j = 1, ot = 0; u.state = !0, vo(t, e.text, Y.mode, u, function (nt, Ct) { for (var Tt = j; ot < nt;) { var Bt = g[j]; Bt > nt && g.splice(j, 1, nt, g[j + 1], Bt), j += 2, ot = Math.min(nt, Bt) } if (Ct) if (Y.opaque) g.splice(Tt, j - Tt, nt, "overlay " + Ct), j = Tt + 2; else for (; Tt < j; Tt += 2) { var Mt = g[Tt + 1]; g[Tt + 1] = (Mt ? Mt + " " : "") + "overlay " + Ct } }, A), u.state = w, u.baseTokens = null, u.baseTokenPos = 1 }, B = 0; B < t.state.overlays.length; ++B)T(B); return { styles: g, classes: A.bgClass || A.textClass ? A : null } } function fo(t, e, u) { if (!e.styles || e.styles[0] != t.state.modeGen) { var s = Vr(t, $t(e)), g = e.text.length > t.options.maxHighlightLength && _i(t.doc.mode, s.state), A = uo(t, e, s); g && (s.state = g), e.stateAfter = s.save(!g), e.styles = A.styles, A.classes ? e.styleClasses = A.classes : e.styleClasses && (e.styleClasses = null), u === t.doc.highlightFrontier && (t.doc.modeFrontier = Math.max(t.doc.modeFrontier, ++t.doc.highlightFrontier)) } return e.styles } function Vr(t, e, u) { var s = t.doc, g = t.display; if (!s.mode.startState) return new gi(s, !0, e); var A = Ef(t, e, u), w = A > s.first && Wt(s, A - 1).stateAfter, T = w ? gi.fromSaved(s, w, A) : new gi(s, Yr(s.mode), A); return s.iter(A, e, function (B) { Na(t, B.text, T); var M = T.line; B.stateAfter = M == e - 1 || M % 5 == 0 || M >= g.viewFrom && M < g.viewTo ? T.save() : null, T.nextLine() }), u && (s.modeFrontier = T.line), T } function Na(t, e, u, s) { var g = t.doc.mode, A = new ge(e, t.options.tabSize, u); for (A.start = A.pos = s || 0, e == "" && ho(g, u.state); !A.eol();)Ya(g, A, u.state), A.start = A.pos } function ho(t, e) { if (t.blankLine) return t.blankLine(e); if (t.innerMode) { var u = Qi(t, e); if (u.mode.blankLine) return u.mode.blankLine(u.state) } } function Ya(t, e, u, s) { for (var g = 0; g < 10; g++) { s && (s[0] = Qi(t, u).mode); var A = t.token(e, u); if (e.pos > e.start) return A } throw new Error("Mode " + t.name + " failed to advance stream.") } var co = function (t, e, u) { this.start = t.start, this.end = t.pos, this.string = t.current(), this.type = e || null, this.state = u }; function go(t, e, u, s) { var g = t.doc, A = g.mode, w; e = Ht(g, e); var T = Wt(g, e.line), B = Vr(t, e.line, u), M = new ge(T.text, t.options.tabSize, B), Y; for (s && (Y = []); (s || M.pos < e.ch) && !M.eol();)M.start = M.pos, w = Ya(A, M, B.state), s && Y.push(new co(M, w, _i(g.mode, B.state))); return s ? Y : new co(M, w, B.state) } function po(t, e) { if (t) for (; ;) { var u = t.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!u) break; t = t.slice(0, u.index) + t.slice(u.index + u[0].length); var s = u[1] ? "bgClass" : "textClass"; e[s] == null ? e[s] = u[2] : new RegExp("(?:^|\\s)" + u[2] + "(?:$|\\s)").test(e[s]) || (e[s] += " " + u[2]) } return t } function vo(t, e, u, s, g, A, w) { var T = u.flattenSpans; T == null && (T = t.options.flattenSpans); var B = 0, M = null, Y = new ge(e, t.options.tabSize, s), j, ot = t.options.addModeClass && [null]; for (e == "" && po(ho(u, s.state), A); !Y.eol();) { if (Y.pos > t.options.maxHighlightLength ? (T = !1, w && Na(t, e, s, Y.pos), Y.pos = e.length, j = null) : j = po(Ya(u, Y, s.state, ot), A), ot) { var nt = ot[0].name; nt && (j = "m-" + (j ? nt + " " + j : nt)) } if (!T || M != j) { for (; B < Y.start;)B = Math.min(Y.start, B + 5e3), g(B, M); M = j } Y.start = Y.pos } for (; B < Y.pos;) { var Ct = Math.min(Y.pos, B + 5e3); g(Ct, M), B = Ct } } function Ef(t, e, u) { for (var s, g, A = t.doc, w = u ? -1 : e - (t.doc.mode.innerMode ? 1e3 : 100), T = e; T > w; --T) { if (T <= A.first) return A.first; var B = Wt(A, T - 1), M = B.stateAfter; if (M && (!u || T + (M instanceof Fn ? M.lookAhead : 0) <= A.modeFrontier)) return T; var Y = J(B.text, null, t.options.tabSize); (g == null || s > Y) && (g = T - 1, s = Y) } return g } function If(t, e) { if (t.modeFrontier = Math.min(t.modeFrontier, e), !(t.highlightFrontier < e - 10)) { for (var u = t.first, s = e - 1; s > u; s--) { var g = Wt(t, s).stateAfter; if (g && (!(g instanceof Fn) || s + g.lookAhead < e)) { u = s + 1; break } } t.highlightFrontier = Math.min(t.highlightFrontier, u) } } var mo = !1, Ti = !1; function Bf() { mo = !0 } function kf() { Ti = !0 } function Pn(t, e, u) { this.marker = t, this.from = e, this.to = u } function zr(t, e) { if (t) for (var u = 0; u < t.length; ++u) { var s = t[u]; if (s.marker == e) return s } } function Mf(t, e) { for (var u, s = 0; s < t.length; ++s)t[s] != e && (u || (u = [])).push(t[s]); return u } function Of(t, e, u) { var s = u && window.WeakSet && (u.markedSpans || (u.markedSpans = new WeakSet)); s && t.markedSpans && s.has(t.markedSpans) ? t.markedSpans.push(e) : (t.markedSpans = t.markedSpans ? t.markedSpans.concat([e]) : [e], s && s.add(t.markedSpans)), e.marker.attachLine(t) } function Df(t, e, u) { var s; if (t) for (var g = 0; g < t.length; ++g) { var A = t[g], w = A.marker, T = A.from == null || (w.inclusiveLeft ? A.from <= e : A.from < e); if (T || A.from == e && w.type == "bookmark" && (!u || !A.marker.insertLeft)) { var B = A.to == null || (w.inclusiveRight ? A.to >= e : A.to > e); (s || (s = [])).push(new Pn(w, A.from, B ? null : A.to)) } } return s } function Lf(t, e, u) { var s; if (t) for (var g = 0; g < t.length; ++g) { var A = t[g], w = A.marker, T = A.to == null || (w.inclusiveRight ? A.to >= e : A.to > e); if (T || A.from == e && w.type == "bookmark" && (!u || A.marker.insertLeft)) { var B = A.from == null || (w.inclusiveLeft ? A.from <= e : A.from < e); (s || (s = [])).push(new Pn(w, B ? null : A.from - e, A.to == null ? null : A.to - e)) } } return s } function Va(t, e) { if (e.full) return null; var u = F(t, e.from.line) && Wt(t, e.from.line).markedSpans, s = F(t, e.to.line) && Wt(t, e.to.line).markedSpans; if (!u && !s) return null; var g = e.from.ch, A = e.to.ch, w = At(e.from, e.to) == 0, T = Df(u, g, w), B = Lf(s, A, w), M = e.text.length == 1, Y = vt(e.text).length + (M ? g : 0); if (T) for (var j = 0; j < T.length; ++j) { var ot = T[j]; if (ot.to == null) { var nt = zr(B, ot.marker); nt ? M && (ot.to = nt.to == null ? null : nt.to + Y) : ot.to = g } } if (B) for (var Ct = 0; Ct < B.length; ++Ct) { var Tt = B[Ct]; if (Tt.to != null && (Tt.to += Y), Tt.from == null) { var Bt = zr(T, Tt.marker); Bt || (Tt.from = Y, M && (T || (T = [])).push(Tt)) } else Tt.from += Y, M && (T || (T = [])).push(Tt) } T && (T = yo(T)), B && B != T && (B = yo(B)); var Mt = [T]; if (!M) { var Pt = e.text.length - 2, Ot; if (Pt > 0 && T) for (var Rt = 0; Rt < T.length; ++Rt)T[Rt].to == null && (Ot || (Ot = [])).push(new Pn(T[Rt].marker, null, null)); for (var Yt = 0; Yt < Pt; ++Yt)Mt.push(Ot); Mt.push(B) } return Mt } function yo(t) { for (var e = 0; e < t.length; ++e) { var u = t[e]; u.from != null && u.from == u.to && u.marker.clearWhenEmpty !== !1 && t.splice(e--, 1) } return t.length ? t : null } function Ff(t, e, u) { var s = null; if (t.iter(e.line, u.line + 1, function (nt) { if (nt.markedSpans) for (var Ct = 0; Ct < nt.markedSpans.length; ++Ct) { var Tt = nt.markedSpans[Ct].marker; Tt.readOnly && (!s || ut(s, Tt) == -1) && (s || (s = [])).push(Tt) } }), !s) return null; for (var g = [{ from: e, to: u }], A = 0; A < s.length; ++A)for (var w = s[A], T = w.find(0), B = 0; B < g.length; ++B) { var M = g[B]; if (!(At(M.to, T.from) < 0 || At(M.from, T.to) > 0)) { var Y = [B, 1], j = At(M.from, T.from), ot = At(M.to, T.to); (j < 0 || !w.inclusiveLeft && !j) && Y.push({ from: M.from, to: T.from }), (ot > 0 || !w.inclusiveRight && !ot) && Y.push({ from: T.to, to: M.to }), g.splice.apply(g, Y), B += Y.length - 3 } } return g } function Ao(t) { var e = t.markedSpans; if (e) { for (var u = 0; u < e.length; ++u)e[u].marker.detachLine(t); t.markedSpans = null } } function Co(t, e) { if (e) { for (var u = 0; u < e.length; ++u)e[u].marker.attachLine(t); t.markedSpans = e } } function Rn(t) { return t.inclusiveLeft ? -1 : 0 } function Qn(t) { return t.inclusiveRight ? 1 : 0 } function za(t, e) { var u = t.lines.length - e.lines.length; if (u != 0) return u; var s = t.find(), g = e.find(), A = At(s.from, g.from) || Rn(t) - Rn(e); if (A) return -A; var w = At(s.to, g.to) || Qn(t) - Qn(e); return w || e.id - t.id } function bo(t, e) { var u = Ti && t.markedSpans, s; if (u) for (var g = void 0, A = 0; A < u.length; ++A)g = u[A], g.marker.collapsed && (e ? g.from : g.to) == null && (!s || za(s, g.marker) < 0) && (s = g.marker); return s } function wo(t) { return bo(t, !0) } function Wn(t) { return bo(t, !1) } function Pf(t, e) { var u = Ti && t.markedSpans, s; if (u) for (var g = 0; g < u.length; ++g) { var A = u[g]; A.marker.collapsed && (A.from == null || A.from < e) && (A.to == null || A.to > e) && (!s || za(s, A.marker) < 0) && (s = A.marker) } return s } function xo(t, e, u, s, g) { var A = Wt(t, e), w = Ti && A.markedSpans; if (w) for (var T = 0; T < w.length; ++T) { var B = w[T]; if (B.marker.collapsed) { var M = B.marker.find(0), Y = At(M.from, u) || Rn(B.marker) - Rn(g), j = At(M.to, s) || Qn(B.marker) - Qn(g); if (!(Y >= 0 && j <= 0 || Y <= 0 && j >= 0) && (Y <= 0 && (B.marker.inclusiveRight && g.inclusiveLeft ? At(M.to, u) >= 0 : At(M.to, u) > 0) || Y >= 0 && (B.marker.inclusiveRight && g.inclusiveLeft ? At(M.from, s) <= 0 : At(M.from, s) < 0))) return !0 } } } function ii(t) { for (var e; e = wo(t);)t = e.find(-1, !0).line; return t } function Rf(t) { for (var e; e = Wn(t);)t = e.find(1, !0).line; return t } function Qf(t) { for (var e, u; e = Wn(t);)t = e.find(1, !0).line, (u || (u = [])).push(t); return u } function Ua(t, e) { var u = Wt(t, e), s = ii(u); return u == s ? e : $t(s) } function _o(t, e) { if (e > t.lastLine()) return e; var u = Wt(t, e), s; if (!Wi(t, u)) return e; for (; s = Wn(u);)u = s.find(1, !0).line; return $t(u) + 1 } function Wi(t, e) { var u = Ti && e.markedSpans; if (u) { for (var s = void 0, g = 0; g < u.length; ++g)if (s = u[g], !!s.marker.collapsed) { if (s.from == null) return !0; if (!s.marker.widgetNode && s.from == 0 && s.marker.inclusiveLeft && Ha(t, e, s)) return !0 } } } function Ha(t, e, u) { if (u.to == null) { var s = u.marker.find(1, !0); return Ha(t, s.line, zr(s.line.markedSpans, u.marker)) } if (u.marker.inclusiveRight && u.to == e.text.length) return !0; for (var g = void 0, A = 0; A < e.markedSpans.length; ++A)if (g = e.markedSpans[A], g.marker.collapsed && !g.marker.widgetNode && g.from == u.to && (g.to == null || g.to != u.from) && (g.marker.inclusiveLeft || u.marker.inclusiveRight) && Ha(t, e, g)) return !0 } function Ei(t) { t = ii(t); for (var e = 0, u = t.parent, s = 0; s < u.lines.length; ++s) { var g = u.lines[s]; if (g == t) break; e += g.height } for (var A = u.parent; A; u = A, A = u.parent)for (var w = 0; w < A.children.length; ++w) { var T = A.children[w]; if (T == u) break; e += T.height } return e } function Nn(t) { if (t.height == 0) return 0; for (var e = t.text.length, u, s = t; u = wo(s);) { var g = u.find(0, !0); s = g.from.line, e += g.from.ch - g.to.ch } for (s = t; u = Wn(s);) { var A = u.find(0, !0); e -= s.text.length - A.from.ch, s = A.to.line, e += s.text.length - A.to.ch } return e } function Ga(t) { var e = t.display, u = t.doc; e.maxLine = Wt(u, u.first), e.maxLineLength = Nn(e.maxLine), e.maxLineChanged = !0, u.iter(function (s) { var g = Nn(s); g > e.maxLineLength && (e.maxLineLength = g, e.maxLine = s) }) } var gr = function (t, e, u) { this.text = t, Co(this, e), this.height = u ? u(this) : 1 }; gr.prototype.lineNo = function () { return $t(this) }, ve(gr); function Wf(t, e, u, s) { t.text = e, t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null), t.order != null && (t.order = null), Ao(t), Co(t, u); var g = s ? s(t) : 1; g != t.height && $e(t, g) } function Nf(t) { t.parent = null, Ao(t) } var Yf = {}, Vf = {}; function So(t, e) { if (!t || /^\s*$/.test(t)) return null; var u = e.addModeClass ? Vf : Yf; return u[t] || (u[t] = t.replace(/\S+/g, "cm-$&")) } function To(t, e) { var u = Dt("span", null, null, c ? "padding-right: .1px" : null), s = { pre: Dt("pre", [u], "CodeMirror-line"), content: u, col: 0, pos: 0, cm: t, trailingSpace: !1, splitSpaces: t.getOption("lineWrapping") }; e.measure = {}; for (var g = 0; g <= (e.rest ? e.rest.length : 0); g++) { var A = g ? e.rest[g - 1] : e.line, w = void 0; s.pos = 0, s.addToken = Uf, Mn(t.display.measure) && (w = ee(A, t.doc.direction)) && (s.addToken = Gf(s.addToken, w)), s.map = []; var T = e != t.display.externalMeasured && $t(A); jf(A, s, fo(t, A, T)), A.styleClasses && (A.styleClasses.bgClass && (s.bgClass = G(A.styleClasses.bgClass, s.bgClass || "")), A.styleClasses.textClass && (s.textClass = G(A.styleClasses.textClass, s.textClass || ""))), s.map.length == 0 && s.map.push(0, 0, s.content.appendChild(Wa(t.display.measure))), g == 0 ? (e.measure.map = s.map, e.measure.cache = {}) : ((e.measure.maps || (e.measure.maps = [])).push(s.map), (e.measure.caches || (e.measure.caches = [])).push({})) } if (c) { var B = s.content.lastChild; (/\bcm-tab\b/.test(B.className) || B.querySelector && B.querySelector(".cm-tab")) && (s.content.className = "cm-tab-wrap-hack") } return ie(t, "renderLine", t, e.line, s.pre), s.pre.className && (s.textClass = G(s.pre.className, s.textClass || "")), s } function zf(t) { var e = W("span", "•", "cm-invalidchar"); return e.title = "\\u" + t.charCodeAt(0).toString(16), e.setAttribute("aria-label", e.title), e } function Uf(t, e, u, s, g, A, w) {
        if (e) {
          var T = t.splitSpaces ? Hf(e, t.trailingSpace) : e, B = t.cm.state.specialChars, M = !1, Y; if (!B.test(e)) t.col += e.length, Y = document.createTextNode(T), t.map.push(t.pos, t.pos + e.length, Y), a && l < 9 && (M = !0), t.pos += e.length; else {
            Y = document.createDocumentFragment(); for (var j = 0; ;) {
              B.lastIndex = j; var ot = B.exec(e), nt = ot ? ot.index - j : e.length - j; if (nt) { var Ct = document.createTextNode(T.slice(j, j + nt)); a && l < 9 ? Y.appendChild(W("span", [Ct])) : Y.appendChild(Ct), t.map.push(t.pos, t.pos + nt, Ct), t.col += nt, t.pos += nt } if (!ot) break; j += nt + 1; var Tt = void 0; if (ot[0] == "	") { var Bt = t.cm.options.tabSize, Mt = Bt - t.col % Bt; Tt = Y.appendChild(W("span", pt(Mt), "cm-tab")), Tt.setAttribute("role", "presentation"), Tt.setAttribute("cm-text", "	"), t.col += Mt } else ot[0] == "\r" || ot[0] == `
`? (Tt = Y.appendChild(W("span", ot[0] == "\r" ? "␍" : "␤", "cm-invalidchar")), Tt.setAttribute("cm-text", ot[0]), t.col += 1) : (Tt = t.cm.options.specialCharPlaceholder(ot[0]), Tt.setAttribute("cm-text", ot[0]), a && l < 9 ? Y.appendChild(W("span", [Tt])) : Y.appendChild(Tt), t.col += 1); t.map.push(t.pos, t.pos + 1, Tt), t.pos++
            }
          } if (t.trailingSpace = T.charCodeAt(e.length - 1) == 32, u || s || g || M || A || w) { var Pt = u || ""; s && (Pt += s), g && (Pt += g); var Ot = W("span", [Y], Pt, A); if (w) for (var Rt in w) w.hasOwnProperty(Rt) && Rt != "style" && Rt != "class" && Ot.setAttribute(Rt, w[Rt]); return t.content.appendChild(Ot) } t.content.appendChild(Y)
        }
      } function Hf(t, e) { if (t.length > 1 && !/  /.test(t)) return t; for (var u = e, s = "", g = 0; g < t.length; g++) { var A = t.charAt(g); A == " " && u && (g == t.length - 1 || t.charCodeAt(g + 1) == 32) && (A = " "), s += A, u = A == " " } return s } function Gf(t, e) { return function (u, s, g, A, w, T, B) { g = g ? g + " cm-force-border" : "cm-force-border"; for (var M = u.pos, Y = M + s.length; ;) { for (var j = void 0, ot = 0; ot < e.length && (j = e[ot], !(j.to > M && j.from <= M)); ot++); if (j.to >= Y) return t(u, s, g, A, w, T, B); t(u, s.slice(0, j.to - M), g, A, null, T, B), A = null, s = s.slice(j.to - M), M = j.to } } } function Eo(t, e, u, s) { var g = !s && u.widgetNode; g && t.map.push(t.pos, t.pos + e, g), !s && t.cm.display.input.needsContentAttribute && (g || (g = t.content.appendChild(document.createElement("span"))), g.setAttribute("cm-marker", u.id)), g && (t.cm.display.input.setUneditable(g), t.content.appendChild(g)), t.pos += e, t.trailingSpace = !1 } function jf(t, e, u) { var s = t.markedSpans, g = t.text, A = 0; if (!s) { for (var w = 1; w < u.length; w += 2)e.addToken(e, g.slice(A, A = u[w]), So(u[w + 1], e.cm.options)); return } for (var T = g.length, B = 0, M = 1, Y = "", j, ot, nt = 0, Ct, Tt, Bt, Mt, Pt; ;) { if (nt == B) { Ct = Tt = Bt = ot = "", Pt = null, Mt = null, nt = 1 / 0; for (var Ot = [], Rt = void 0, Yt = 0; Yt < s.length; ++Yt) { var Nt = s[Yt], Xt = Nt.marker; if (Xt.type == "bookmark" && Nt.from == B && Xt.widgetNode) Ot.push(Xt); else if (Nt.from <= B && (Nt.to == null || Nt.to > B || Xt.collapsed && Nt.to == B && Nt.from == B)) { if (Nt.to != null && Nt.to != B && nt > Nt.to && (nt = Nt.to, Tt = ""), Xt.className && (Ct += " " + Xt.className), Xt.css && (ot = (ot ? ot + ";" : "") + Xt.css), Xt.startStyle && Nt.from == B && (Bt += " " + Xt.startStyle), Xt.endStyle && Nt.to == nt && (Rt || (Rt = [])).push(Xt.endStyle, Nt.to), Xt.title && ((Pt || (Pt = {})).title = Xt.title), Xt.attributes) for (var se in Xt.attributes) (Pt || (Pt = {}))[se] = Xt.attributes[se]; Xt.collapsed && (!Mt || za(Mt.marker, Xt) < 0) && (Mt = Nt) } else Nt.from > B && nt > Nt.from && (nt = Nt.from) } if (Rt) for (var Ie = 0; Ie < Rt.length; Ie += 2)Rt[Ie + 1] == nt && (Tt += " " + Rt[Ie]); if (!Mt || Mt.from == B) for (var he = 0; he < Ot.length; ++he)Eo(e, 0, Ot[he]); if (Mt && (Mt.from || 0) == B) { if (Eo(e, (Mt.to == null ? T + 1 : Mt.to) - B, Mt.marker, Mt.from == null), Mt.to == null) return; Mt.to == B && (Mt = !1) } } if (B >= T) break; for (var Ge = Math.min(T, nt); ;) { if (Y) { var Ye = B + Y.length; if (!Mt) { var Ae = Ye > Ge ? Y.slice(0, Ge - B) : Y; e.addToken(e, Ae, j ? j + Ct : Ct, Bt, B + Ae.length == nt ? Tt : "", ot, Pt) } if (Ye >= Ge) { Y = Y.slice(Ge - B), B = Ge; break } B = Ye, Bt = "" } Y = g.slice(A, A = u[M++]), j = So(u[M++], e.cm.options) } } } function Io(t, e, u) { this.line = e, this.rest = Qf(e), this.size = this.rest ? $t(vt(this.rest)) - u + 1 : 1, this.node = this.text = null, this.hidden = Wi(t, e) } function Yn(t, e, u) { for (var s = [], g, A = e; A < u; A = g) { var w = new Io(t.doc, Wt(t.doc, A), A); g = A + w.size, s.push(w) } return s } var pr = null; function Xf(t) { pr ? pr.ops.push(t) : t.ownsGroup = pr = { ops: [t], delayedCallbacks: [] } } function Kf(t) { var e = t.delayedCallbacks, u = 0; do { for (; u < e.length; u++)e[u].call(null); for (var s = 0; s < t.ops.length; s++) { var g = t.ops[s]; if (g.cursorActivityHandlers) for (; g.cursorActivityCalled < g.cursorActivityHandlers.length;)g.cursorActivityHandlers[g.cursorActivityCalled++].call(null, g.cm) } } while (u < e.length) } function qf(t, e) { var u = t.ownsGroup; if (u) try { Kf(u) } finally { pr = null, e(u) } } var Ur = null; function Se(t, e) { var u = Li(t, e); if (u.length) { var s = Array.prototype.slice.call(arguments, 2), g; pr ? g = pr.delayedCallbacks : Ur ? g = Ur : (g = Ur = [], setTimeout(Jf, 0)); for (var A = function (T) { g.push(function () { return u[T].apply(null, s) }) }, w = 0; w < u.length; ++w)A(w) } } function Jf() { var t = Ur; Ur = null; for (var e = 0; e < t.length; ++e)t[e]() } function Bo(t, e, u, s) { for (var g = 0; g < e.changes.length; g++) { var A = e.changes[g]; A == "text" ? $f(t, e) : A == "gutter" ? Mo(t, e, u, s) : A == "class" ? ja(t, e) : A == "widget" && th(t, e, s) } e.changes = null } function Hr(t) { return t.node == t.text && (t.node = W("div", null, null, "position: relative"), t.text.parentNode && t.text.parentNode.replaceChild(t.node, t.text), t.node.appendChild(t.text), a && l < 8 && (t.node.style.zIndex = 2)), t.node } function Zf(t, e) { var u = e.bgClass ? e.bgClass + " " + (e.line.bgClass || "") : e.line.bgClass; if (u && (u += " CodeMirror-linebackground"), e.background) u ? e.background.className = u : (e.background.parentNode.removeChild(e.background), e.background = null); else if (u) { var s = Hr(e); e.background = s.insertBefore(W("div", null, u), s.firstChild), t.display.input.setUneditable(e.background) } } function ko(t, e) { var u = t.display.externalMeasured; return u && u.line == e.line ? (t.display.externalMeasured = null, e.measure = u.measure, u.built) : To(t, e) } function $f(t, e) { var u = e.text.className, s = ko(t, e); e.text == e.node && (e.node = s.pre), e.text.parentNode.replaceChild(s.pre, e.text), e.text = s.pre, s.bgClass != e.bgClass || s.textClass != e.textClass ? (e.bgClass = s.bgClass, e.textClass = s.textClass, ja(t, e)) : u && (e.text.className = u) } function ja(t, e) { Zf(t, e), e.line.wrapClass ? Hr(e).className = e.line.wrapClass : e.node != e.text && (e.node.className = ""); var u = e.textClass ? e.textClass + " " + (e.line.textClass || "") : e.line.textClass; e.text.className = u || "" } function Mo(t, e, u, s) { if (e.gutter && (e.node.removeChild(e.gutter), e.gutter = null), e.gutterBackground && (e.node.removeChild(e.gutterBackground), e.gutterBackground = null), e.line.gutterClass) { var g = Hr(e); e.gutterBackground = W("div", null, "CodeMirror-gutter-background " + e.line.gutterClass, "left: " + (t.options.fixedGutter ? s.fixedPos : -s.gutterTotalWidth) + "px; width: " + s.gutterTotalWidth + "px"), t.display.input.setUneditable(e.gutterBackground), g.insertBefore(e.gutterBackground, e.text) } var A = e.line.gutterMarkers; if (t.options.lineNumbers || A) { var w = Hr(e), T = e.gutter = W("div", null, "CodeMirror-gutter-wrapper", "left: " + (t.options.fixedGutter ? s.fixedPos : -s.gutterTotalWidth) + "px"); if (T.setAttribute("aria-hidden", "true"), t.display.input.setUneditable(T), w.insertBefore(T, e.text), e.line.gutterClass && (T.className += " " + e.line.gutterClass), t.options.lineNumbers && (!A || !A["CodeMirror-linenumbers"]) && (e.lineNumber = T.appendChild(W("div", X(t.options, u), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + s.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + t.display.lineNumInnerWidth + "px"))), A) for (var B = 0; B < t.display.gutterSpecs.length; ++B) { var M = t.display.gutterSpecs[B].className, Y = A.hasOwnProperty(M) && A[M]; Y && T.appendChild(W("div", [Y], "CodeMirror-gutter-elt", "left: " + s.gutterLeft[M] + "px; width: " + s.gutterWidth[M] + "px")) } } } function th(t, e, u) { e.alignable && (e.alignable = null); for (var s = st("CodeMirror-linewidget"), g = e.node.firstChild, A = void 0; g; g = A)A = g.nextSibling, s.test(g.className) && e.node.removeChild(g); Oo(t, e, u) } function eh(t, e, u, s) { var g = ko(t, e); return e.text = e.node = g.pre, g.bgClass && (e.bgClass = g.bgClass), g.textClass && (e.textClass = g.textClass), ja(t, e), Mo(t, e, u, s), Oo(t, e, s), e.node } function Oo(t, e, u) { if (Do(t, e.line, e, u, !0), e.rest) for (var s = 0; s < e.rest.length; s++)Do(t, e.rest[s], e, u, !1) } function Do(t, e, u, s, g) { if (e.widgets) for (var A = Hr(u), w = 0, T = e.widgets; w < T.length; ++w) { var B = T[w], M = W("div", [B.node], "CodeMirror-linewidget" + (B.className ? " " + B.className : "")); B.handleMouseEvents || M.setAttribute("cm-ignore-events", "true"), ih(B, M, u, s), t.display.input.setUneditable(M), g && B.above ? A.insertBefore(M, u.gutter || u.text) : A.appendChild(M), Se(B, "redraw") } } function ih(t, e, u, s) { if (t.noHScroll) { (u.alignable || (u.alignable = [])).push(e); var g = s.wrapperWidth; e.style.left = s.fixedPos + "px", t.coverGutter || (g -= s.gutterTotalWidth, e.style.paddingLeft = s.gutterTotalWidth + "px"), e.style.width = g + "px" } t.coverGutter && (e.style.zIndex = 5, e.style.position = "relative", t.noHScroll || (e.style.marginLeft = -s.gutterTotalWidth + "px")) } function Gr(t) { if (t.height != null) return t.height; var e = t.doc.cm; if (!e) return 0; if (!it(document.body, t.node)) { var u = "position: relative;"; t.coverGutter && (u += "margin-left: -" + e.display.gutters.offsetWidth + "px;"), t.noHScroll && (u += "width: " + e.display.wrapper.clientWidth + "px;"), ct(e.display.measure, W("div", [t.node], null, u)) } return t.height = t.node.parentNode.offsetHeight } function Ii(t, e) { for (var u = Qe(e); u != t.wrapper; u = u.parentNode)if (!u || u.nodeType == 1 && u.getAttribute("cm-ignore-events") == "true" || u.parentNode == t.sizer && u != t.mover) return !0 } function Vn(t) { return t.lineSpace.offsetTop } function Xa(t) { return t.mover.offsetHeight - t.lineSpace.offsetHeight } function Lo(t) { if (t.cachedPaddingH) return t.cachedPaddingH; var e = ct(t.measure, W("pre", "x", "CodeMirror-line-like")), u = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, s = { left: parseInt(u.paddingLeft), right: parseInt(u.paddingRight) }; return !isNaN(s.left) && !isNaN(s.right) && (t.cachedPaddingH = s), s } function pi(t) { return _t - t.display.nativeBarWidth } function Ji(t) { return t.display.scroller.clientWidth - pi(t) - t.display.barWidth } function Ka(t) { return t.display.scroller.clientHeight - pi(t) - t.display.barHeight } function rh(t, e, u) { var s = t.options.lineWrapping, g = s && Ji(t); if (!e.measure.heights || s && e.measure.width != g) { var A = e.measure.heights = []; if (s) { e.measure.width = g; for (var w = e.text.firstChild.getClientRects(), T = 0; T < w.length - 1; T++) { var B = w[T], M = w[T + 1]; Math.abs(B.bottom - M.bottom) > 2 && A.push((B.bottom + M.top) / 2 - u.top) } } A.push(u.bottom - u.top) } } function Fo(t, e, u) { if (t.line == e) return { map: t.measure.map, cache: t.measure.cache }; if (t.rest) { for (var s = 0; s < t.rest.length; s++)if (t.rest[s] == e) return { map: t.measure.maps[s], cache: t.measure.caches[s] }; for (var g = 0; g < t.rest.length; g++)if ($t(t.rest[g]) > u) return { map: t.measure.maps[g], cache: t.measure.caches[g], before: !0 } } } function nh(t, e) { e = ii(e); var u = $t(e), s = t.display.externalMeasured = new Io(t.doc, e, u); s.lineN = u; var g = s.built = To(t, s); return s.text = g.pre, ct(t.display.lineMeasure, g.pre), s } function Po(t, e, u, s) { return vi(t, vr(t, e), u, s) } function qa(t, e) { if (e >= t.display.viewFrom && e < t.display.viewTo) return t.display.view[tr(t, e)]; var u = t.display.externalMeasured; if (u && e >= u.lineN && e < u.lineN + u.size) return u } function vr(t, e) { var u = $t(e), s = qa(t, u); s && !s.text ? s = null : s && s.changes && (Bo(t, s, u, es(t)), t.curOp.forceUpdate = !0), s || (s = nh(t, e)); var g = Fo(s, e, u); return { line: e, view: s, rect: null, map: g.map, cache: g.cache, before: g.before, hasHeights: !1 } } function vi(t, e, u, s, g) { e.before && (u = -1); var A = u + (s || ""), w; return e.cache.hasOwnProperty(A) ? w = e.cache[A] : (e.rect || (e.rect = e.view.text.getBoundingClientRect()), e.hasHeights || (rh(t, e.view, e.rect), e.hasHeights = !0), w = sh(t, e, u, s), w.bogus || (e.cache[A] = w)), { left: w.left, right: w.right, top: g ? w.rtop : w.top, bottom: g ? w.rbottom : w.bottom } } var Ro = { left: 0, right: 0, top: 0, bottom: 0 }; function Qo(t, e, u) { for (var s, g, A, w, T, B, M = 0; M < t.length; M += 3)if (T = t[M], B = t[M + 1], e < T ? (g = 0, A = 1, w = "left") : e < B ? (g = e - T, A = g + 1) : (M == t.length - 3 || e == B && t[M + 3] > e) && (A = B - T, g = A - 1, e >= B && (w = "right")), g != null) { if (s = t[M + 2], T == B && u == (s.insertLeft ? "left" : "right") && (w = u), u == "left" && g == 0) for (; M && t[M - 2] == t[M - 3] && t[M - 1].insertLeft;)s = t[(M -= 3) + 2], w = "left"; if (u == "right" && g == B - T) for (; M < t.length - 3 && t[M + 3] == t[M + 4] && !t[M + 5].insertLeft;)s = t[(M += 3) + 2], w = "right"; break } return { node: s, start: g, end: A, collapse: w, coverStart: T, coverEnd: B } } function ah(t, e) { var u = Ro; if (e == "left") for (var s = 0; s < t.length && (u = t[s]).left == u.right; s++); else for (var g = t.length - 1; g >= 0 && (u = t[g]).left == u.right; g--); return u } function sh(t, e, u, s) { var g = Qo(e.map, u, s), A = g.node, w = g.start, T = g.end, B = g.collapse, M; if (A.nodeType == 3) { for (var Y = 0; Y < 4; Y++) { for (; w && Et(e.line.text.charAt(g.coverStart + w));)--w; for (; g.coverStart + T < g.coverEnd && Et(e.line.text.charAt(g.coverStart + T));)++T; if (a && l < 9 && w == 0 && T == g.coverEnd - g.coverStart ? M = A.parentNode.getBoundingClientRect() : M = ah(Lt(A, w, T).getClientRects(), s), M.left || M.right || w == 0) break; T = w, w = w - 1, B = "right" } a && l < 11 && (M = oh(t.display.measure, M)) } else { w > 0 && (B = s = "right"); var j; t.options.lineWrapping && (j = A.getClientRects()).length > 1 ? M = j[s == "right" ? j.length - 1 : 0] : M = A.getBoundingClientRect() } if (a && l < 9 && !w && (!M || !M.left && !M.right)) { var ot = A.parentNode.getClientRects()[0]; ot ? M = { left: ot.left, right: ot.left + yr(t.display), top: ot.top, bottom: ot.bottom } : M = Ro } for (var nt = M.top - e.rect.top, Ct = M.bottom - e.rect.top, Tt = (nt + Ct) / 2, Bt = e.view.measure.heights, Mt = 0; Mt < Bt.length - 1 && !(Tt < Bt[Mt]); Mt++); var Pt = Mt ? Bt[Mt - 1] : 0, Ot = Bt[Mt], Rt = { left: (B == "right" ? M.right : M.left) - e.rect.left, right: (B == "left" ? M.left : M.right) - e.rect.left, top: Pt, bottom: Ot }; return !M.left && !M.right && (Rt.bogus = !0), t.options.singleCursorHeightPerLine || (Rt.rtop = nt, Rt.rbottom = Ct), Rt } function oh(t, e) { if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !On(t)) return e; var u = screen.logicalXDPI / screen.deviceXDPI, s = screen.logicalYDPI / screen.deviceYDPI; return { left: e.left * u, right: e.right * u, top: e.top * s, bottom: e.bottom * s } } function Wo(t) { if (t.measure && (t.measure.cache = {}, t.measure.heights = null, t.rest)) for (var e = 0; e < t.rest.length; e++)t.measure.caches[e] = {} } function No(t) { t.display.externalMeasure = null, q(t.display.lineMeasure); for (var e = 0; e < t.display.view.length; e++)Wo(t.display.view[e]) } function jr(t) { No(t), t.display.cachedCharWidth = t.display.cachedTextHeight = t.display.cachedPaddingH = null, t.options.lineWrapping || (t.display.maxLineChanged = !0), t.display.lineNumChars = null } function Yo(t) { return i && C ? -(t.body.getBoundingClientRect().left - parseInt(getComputedStyle(t.body).marginLeft)) : t.defaultView.pageXOffset || (t.documentElement || t.body).scrollLeft } function Vo(t) { return i && C ? -(t.body.getBoundingClientRect().top - parseInt(getComputedStyle(t.body).marginTop)) : t.defaultView.pageYOffset || (t.documentElement || t.body).scrollTop } function Ja(t) { var e = ii(t), u = e.widgets, s = 0; if (u) for (var g = 0; g < u.length; ++g)u[g].above && (s += Gr(u[g])); return s } function zn(t, e, u, s, g) { if (!g) { var A = Ja(e); u.top += A, u.bottom += A } if (s == "line") return u; s || (s = "local"); var w = Ei(e); if (s == "local" ? w += Vn(t.display) : w -= t.display.viewOffset, s == "page" || s == "window") { var T = t.display.lineSpace.getBoundingClientRect(); w += T.top + (s == "window" ? 0 : Vo(lt(t))); var B = T.left + (s == "window" ? 0 : Yo(lt(t))); u.left += B, u.right += B } return u.top += w, u.bottom += w, u } function zo(t, e, u) { if (u == "div") return e; var s = e.left, g = e.top; if (u == "page") s -= Yo(lt(t)), g -= Vo(lt(t)); else if (u == "local" || !u) { var A = t.display.sizer.getBoundingClientRect(); s += A.left, g += A.top } var w = t.display.lineSpace.getBoundingClientRect(); return { left: s - w.left, top: g - w.top } } function Un(t, e, u, s, g) { return s || (s = Wt(t.doc, e.line)), zn(t, s, Po(t, s, e.ch, g), u) } function ri(t, e, u, s, g, A) { s = s || Wt(t.doc, e.line), g || (g = vr(t, s)); function w(Ct, Tt) { var Bt = vi(t, g, Ct, Tt ? "right" : "left", A); return Tt ? Bt.left = Bt.right : Bt.right = Bt.left, zn(t, s, Bt, u) } var T = ee(s, t.doc.direction), B = e.ch, M = e.sticky; if (B >= s.text.length ? (B = s.text.length, M = "before") : B <= 0 && (B = 0, M = "after"), !T) return w(M == "before" ? B - 1 : B, M == "before"); function Y(Ct, Tt, Bt) { var Mt = T[Tt], Pt = Mt.level == 1; return w(Bt ? Ct - 1 : Ct, Pt != Bt) } var j = Kt(T, B, M), ot = Gt, nt = Y(B, j, M == "before"); return ot != null && (nt.other = Y(B, ot, M != "before")), nt } function Uo(t, e) { var u = 0; e = Ht(t.doc, e), t.options.lineWrapping || (u = yr(t.display) * e.ch); var s = Wt(t.doc, e.line), g = Ei(s) + Vn(t.display); return { left: u, right: u, top: g, bottom: g + s.height } } function Za(t, e, u, s, g) { var A = Z(t, e, u); return A.xRel = g, s && (A.outside = s), A } function $a(t, e, u) { var s = t.doc; if (u += t.display.viewOffset, u < 0) return Za(s.first, 0, null, -1, -1); var g = di(s, u), A = s.first + s.size - 1; if (g > A) return Za(s.first + s.size - 1, Wt(s, A).text.length, null, 1, 1); e < 0 && (e = 0); for (var w = Wt(s, g); ;) { var T = lh(t, w, g, e, u), B = Pf(w, T.ch + (T.xRel > 0 || T.outside > 0 ? 1 : 0)); if (!B) return T; var M = B.find(1); if (M.line == g) return M; w = Wt(s, g = M.line) } } function Ho(t, e, u, s) { s -= Ja(e); var g = e.text.length, A = Qt(function (w) { return vi(t, u, w - 1).bottom <= s }, g, 0); return g = Qt(function (w) { return vi(t, u, w).top > s }, A, g), { begin: A, end: g } } function Go(t, e, u, s) { u || (u = vr(t, e)); var g = zn(t, e, vi(t, u, s), "line").top; return Ho(t, e, u, g) } function ts(t, e, u, s) { return t.bottom <= u ? !1 : t.top > u ? !0 : (s ? t.left : t.right) > e } function lh(t, e, u, s, g) { g -= Ei(e); var A = vr(t, e), w = Ja(e), T = 0, B = e.text.length, M = !0, Y = ee(e, t.doc.direction); if (Y) { var j = (t.options.lineWrapping ? fh : uh)(t, e, u, A, Y, s, g); M = j.level != 1, T = M ? j.from : j.to - 1, B = M ? j.to : j.from - 1 } var ot = null, nt = null, Ct = Qt(function (Yt) { var Nt = vi(t, A, Yt); return Nt.top += w, Nt.bottom += w, ts(Nt, s, g, !1) ? (Nt.top <= g && Nt.left <= s && (ot = Yt, nt = Nt), !0) : !1 }, T, B), Tt, Bt, Mt = !1; if (nt) { var Pt = s - nt.left < nt.right - s, Ot = Pt == M; Ct = ot + (Ot ? 0 : 1), Bt = Ot ? "after" : "before", Tt = Pt ? nt.left : nt.right } else { !M && (Ct == B || Ct == T) && Ct++, Bt = Ct == 0 ? "after" : Ct == e.text.length ? "before" : vi(t, A, Ct - (M ? 1 : 0)).bottom + w <= g == M ? "after" : "before"; var Rt = ri(t, Z(u, Ct, Bt), "line", e, A); Tt = Rt.left, Mt = g < Rt.top ? -1 : g >= Rt.bottom ? 1 : 0 } return Ct = Ft(e.text, Ct, 1), Za(u, Ct, Bt, Mt, s - Tt) } function uh(t, e, u, s, g, A, w) { var T = Qt(function (j) { var ot = g[j], nt = ot.level != 1; return ts(ri(t, Z(u, nt ? ot.to : ot.from, nt ? "before" : "after"), "line", e, s), A, w, !0) }, 0, g.length - 1), B = g[T]; if (T > 0) { var M = B.level != 1, Y = ri(t, Z(u, M ? B.from : B.to, M ? "after" : "before"), "line", e, s); ts(Y, A, w, !0) && Y.top > w && (B = g[T - 1]) } return B } function fh(t, e, u, s, g, A, w) { var T = Ho(t, e, s, w), B = T.begin, M = T.end; /\s/.test(e.text.charAt(M - 1)) && M--; for (var Y = null, j = null, ot = 0; ot < g.length; ot++) { var nt = g[ot]; if (!(nt.from >= M || nt.to <= B)) { var Ct = nt.level != 1, Tt = vi(t, s, Ct ? Math.min(M, nt.to) - 1 : Math.max(B, nt.from)).right, Bt = Tt < A ? A - Tt + 1e9 : Tt - A; (!Y || j > Bt) && (Y = nt, j = Bt) } } return Y || (Y = g[g.length - 1]), Y.from < B && (Y = { from: B, to: Y.to, level: Y.level }), Y.to > M && (Y = { from: Y.from, to: M, level: Y.level }), Y } var Zi; function mr(t) { if (t.cachedTextHeight != null) return t.cachedTextHeight; if (Zi == null) { Zi = W("pre", null, "CodeMirror-line-like"); for (var e = 0; e < 49; ++e)Zi.appendChild(document.createTextNode("x")), Zi.appendChild(W("br")); Zi.appendChild(document.createTextNode("x")) } ct(t.measure, Zi); var u = Zi.offsetHeight / 50; return u > 3 && (t.cachedTextHeight = u), q(t.measure), u || 1 } function yr(t) { if (t.cachedCharWidth != null) return t.cachedCharWidth; var e = W("span", "xxxxxxxxxx"), u = W("pre", [e], "CodeMirror-line-like"); ct(t.measure, u); var s = e.getBoundingClientRect(), g = (s.right - s.left) / 10; return g > 2 && (t.cachedCharWidth = g), g || 10 } function es(t) { for (var e = t.display, u = {}, s = {}, g = e.gutters.clientLeft, A = e.gutters.firstChild, w = 0; A; A = A.nextSibling, ++w) { var T = t.display.gutterSpecs[w].className; u[T] = A.offsetLeft + A.clientLeft + g, s[T] = A.clientWidth } return { fixedPos: is(e), gutterTotalWidth: e.gutters.offsetWidth, gutterLeft: u, gutterWidth: s, wrapperWidth: e.wrapper.clientWidth } } function is(t) { return t.scroller.getBoundingClientRect().left - t.sizer.getBoundingClientRect().left } function jo(t) { var e = mr(t.display), u = t.options.lineWrapping, s = u && Math.max(5, t.display.scroller.clientWidth / yr(t.display) - 3); return function (g) { if (Wi(t.doc, g)) return 0; var A = 0; if (g.widgets) for (var w = 0; w < g.widgets.length; w++)g.widgets[w].height && (A += g.widgets[w].height); return u ? A + (Math.ceil(g.text.length / s) || 1) * e : A + e } } function rs(t) { var e = t.doc, u = jo(t); e.iter(function (s) { var g = u(s); g != s.height && $e(s, g) }) } function $i(t, e, u, s) { var g = t.display; if (!u && Qe(e).getAttribute("cm-not-content") == "true") return null; var A, w, T = g.lineSpace.getBoundingClientRect(); try { A = e.clientX - T.left, w = e.clientY - T.top } catch { return null } var B = $a(t, A, w), M; if (s && B.xRel > 0 && (M = Wt(t.doc, B.line).text).length == B.ch) { var Y = J(M, M.length, t.options.tabSize) - M.length; B = Z(B.line, Math.max(0, Math.round((A - Lo(t.display).left) / yr(t.display)) - Y)) } return B } function tr(t, e) { if (e >= t.display.viewTo || (e -= t.display.viewFrom, e < 0)) return null; for (var u = t.display.view, s = 0; s < u.length; s++)if (e -= u[s].size, e < 0) return s } function We(t, e, u, s) { e == null && (e = t.doc.first), u == null && (u = t.doc.first + t.doc.size), s || (s = 0); var g = t.display; if (s && u < g.viewTo && (g.updateLineNumbers == null || g.updateLineNumbers > e) && (g.updateLineNumbers = e), t.curOp.viewChanged = !0, e >= g.viewTo) Ti && Ua(t.doc, e) < g.viewTo && Yi(t); else if (u <= g.viewFrom) Ti && _o(t.doc, u + s) > g.viewFrom ? Yi(t) : (g.viewFrom += s, g.viewTo += s); else if (e <= g.viewFrom && u >= g.viewTo) Yi(t); else if (e <= g.viewFrom) { var A = Hn(t, u, u + s, 1); A ? (g.view = g.view.slice(A.index), g.viewFrom = A.lineN, g.viewTo += s) : Yi(t) } else if (u >= g.viewTo) { var w = Hn(t, e, e, -1); w ? (g.view = g.view.slice(0, w.index), g.viewTo = w.lineN) : Yi(t) } else { var T = Hn(t, e, e, -1), B = Hn(t, u, u + s, 1); T && B ? (g.view = g.view.slice(0, T.index).concat(Yn(t, T.lineN, B.lineN)).concat(g.view.slice(B.index)), g.viewTo += s) : Yi(t) } var M = g.externalMeasured; M && (u < M.lineN ? M.lineN += s : e < M.lineN + M.size && (g.externalMeasured = null)) } function Ni(t, e, u) { t.curOp.viewChanged = !0; var s = t.display, g = t.display.externalMeasured; if (g && e >= g.lineN && e < g.lineN + g.size && (s.externalMeasured = null), !(e < s.viewFrom || e >= s.viewTo)) { var A = s.view[tr(t, e)]; if (A.node != null) { var w = A.changes || (A.changes = []); ut(w, u) == -1 && w.push(u) } } } function Yi(t) { t.display.viewFrom = t.display.viewTo = t.doc.first, t.display.view = [], t.display.viewOffset = 0 } function Hn(t, e, u, s) { var g = tr(t, e), A, w = t.display.view; if (!Ti || u == t.doc.first + t.doc.size) return { index: g, lineN: u }; for (var T = t.display.viewFrom, B = 0; B < g; B++)T += w[B].size; if (T != e) { if (s > 0) { if (g == w.length - 1) return null; A = T + w[g].size - e, g++ } else A = T - e; e += A, u += A } for (; Ua(t.doc, u) != u;) { if (g == (s < 0 ? 0 : w.length - 1)) return null; u += s * w[g - (s < 0 ? 1 : 0)].size, g += s } return { index: g, lineN: u } } function hh(t, e, u) { var s = t.display, g = s.view; g.length == 0 || e >= s.viewTo || u <= s.viewFrom ? (s.view = Yn(t, e, u), s.viewFrom = e) : (s.viewFrom > e ? s.view = Yn(t, e, s.viewFrom).concat(s.view) : s.viewFrom < e && (s.view = s.view.slice(tr(t, e))), s.viewFrom = e, s.viewTo < u ? s.view = s.view.concat(Yn(t, s.viewTo, u)) : s.viewTo > u && (s.view = s.view.slice(0, tr(t, u)))), s.viewTo = u } function Xo(t) { for (var e = t.display.view, u = 0, s = 0; s < e.length; s++) { var g = e[s]; !g.hidden && (!g.node || g.changes) && ++u } return u } function Xr(t) { t.display.input.showSelection(t.display.input.prepareSelection()) } function Ko(t, e) { e === void 0 && (e = !0); var u = t.doc, s = {}, g = s.cursors = document.createDocumentFragment(), A = s.selection = document.createDocumentFragment(), w = t.options.$customCursor; w && (e = !0); for (var T = 0; T < u.sel.ranges.length; T++)if (!(!e && T == u.sel.primIndex)) { var B = u.sel.ranges[T]; if (!(B.from().line >= t.display.viewTo || B.to().line < t.display.viewFrom)) { var M = B.empty(); if (w) { var Y = w(t, B); Y && ns(t, Y, g) } else (M || t.options.showCursorWhenSelecting) && ns(t, B.head, g); M || ch(t, B, A) } } return s } function ns(t, e, u) { var s = ri(t, e, "div", null, null, !t.options.singleCursorHeightPerLine), g = u.appendChild(W("div", " ", "CodeMirror-cursor")); if (g.style.left = s.left + "px", g.style.top = s.top + "px", g.style.height = Math.max(0, s.bottom - s.top) * t.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(t.getWrapperElement().className)) { var A = Un(t, e, "div", null, null), w = A.right - A.left; g.style.width = (w > 0 ? w : t.defaultCharWidth()) + "px" } if (s.other) { var T = u.appendChild(W("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor")); T.style.display = "", T.style.left = s.other.left + "px", T.style.top = s.other.top + "px", T.style.height = (s.other.bottom - s.other.top) * .85 + "px" } } function Gn(t, e) { return t.top - e.top || t.left - e.left } function ch(t, e, u) {
        var s = t.display, g = t.doc, A = document.createDocumentFragment(), w = Lo(t.display), T = w.left, B = Math.max(s.sizerWidth, Ji(t) - s.sizer.offsetLeft) - w.right, M = g.direction == "ltr"; function Y(Ot, Rt, Yt, Nt) {
          Rt < 0 && (Rt = 0), Rt = Math.round(Rt), Nt = Math.round(Nt), A.appendChild(W("div", null, "CodeMirror-selected", "position: absolute; left: " + Ot + `px;
                             top: `+ Rt + "px; width: " + (Yt ?? B - Ot) + `px;
                             height: `+ (Nt - Rt) + "px"))
        } function j(Ot, Rt, Yt) { var Nt = Wt(g, Ot), Xt = Nt.text.length, se, Ie; function he(Ae, Ve) { return Un(t, Z(Ot, Ae), "div", Nt, Ve) } function Ge(Ae, Ve, Me) { var _e = Go(t, Nt, null, Ae), Ce = Ve == "ltr" == (Me == "after") ? "left" : "right", pe = Me == "after" ? _e.begin : _e.end - (/\s/.test(Nt.text.charAt(_e.end - 1)) ? 2 : 1); return he(pe, Ce)[Ce] } var Ye = ee(Nt, g.direction); return jt(Ye, Rt || 0, Yt ?? Xt, function (Ae, Ve, Me, _e) { var Ce = Me == "ltr", pe = he(Ae, Ce ? "left" : "right"), ze = he(Ve - 1, Ce ? "right" : "left"), Mr = Rt == null && Ae == 0, ji = Yt == null && Ve == Xt, Le = _e == 0, mi = !Ye || _e == Ye.length - 1; if (ze.top - pe.top <= 3) { var Be = (M ? Mr : ji) && Le, Ms = (M ? ji : Mr) && mi, Mi = Be ? T : (Ce ? pe : ze).left, ar = Ms ? B : (Ce ? ze : pe).right; Y(Mi, pe.top, ar - Mi, pe.bottom) } else { var sr, Pe, Or, Os; Ce ? (sr = M && Mr && Le ? T : pe.left, Pe = M ? B : Ge(Ae, Me, "before"), Or = M ? T : Ge(Ve, Me, "after"), Os = M && ji && mi ? B : ze.right) : (sr = M ? Ge(Ae, Me, "before") : T, Pe = !M && Mr && Le ? B : pe.right, Or = !M && ji && mi ? T : ze.left, Os = M ? Ge(Ve, Me, "after") : B), Y(sr, pe.top, Pe - sr, pe.bottom), pe.bottom < ze.top && Y(T, pe.bottom, null, ze.top), Y(Or, ze.top, Os - Or, ze.bottom) } (!se || Gn(pe, se) < 0) && (se = pe), Gn(ze, se) < 0 && (se = ze), (!Ie || Gn(pe, Ie) < 0) && (Ie = pe), Gn(ze, Ie) < 0 && (Ie = ze) }), { start: se, end: Ie } } var ot = e.from(), nt = e.to(); if (ot.line == nt.line) j(ot.line, ot.ch, nt.ch); else { var Ct = Wt(g, ot.line), Tt = Wt(g, nt.line), Bt = ii(Ct) == ii(Tt), Mt = j(ot.line, ot.ch, Bt ? Ct.text.length + 1 : null).end, Pt = j(nt.line, Bt ? 0 : null, nt.ch).start; Bt && (Mt.top < Pt.top - 2 ? (Y(Mt.right, Mt.top, null, Mt.bottom), Y(T, Pt.top, Pt.left, Pt.bottom)) : Y(Mt.right, Mt.top, Pt.left - Mt.right, Mt.bottom)), Mt.bottom < Pt.top && Y(T, Mt.bottom, null, Pt.top) } u.appendChild(A)
      } function as(t) { if (t.state.focused) { var e = t.display; clearInterval(e.blinker); var u = !0; e.cursorDiv.style.visibility = "", t.options.cursorBlinkRate > 0 ? e.blinker = setInterval(function () { t.hasFocus() || Ar(t), e.cursorDiv.style.visibility = (u = !u) ? "" : "hidden" }, t.options.cursorBlinkRate) : t.options.cursorBlinkRate < 0 && (e.cursorDiv.style.visibility = "hidden") } } function qo(t) { t.hasFocus() || (t.display.input.focus(), t.state.focused || os(t)) } function ss(t) { t.state.delayingBlurEvent = !0, setTimeout(function () { t.state.delayingBlurEvent && (t.state.delayingBlurEvent = !1, t.state.focused && Ar(t)) }, 100) } function os(t, e) { t.state.delayingBlurEvent && !t.state.draggingText && (t.state.delayingBlurEvent = !1), t.options.readOnly != "nocursor" && (t.state.focused || (ie(t, "focus", t, e), t.state.focused = !0, V(t.display.wrapper, "CodeMirror-focused"), !t.curOp && t.display.selForContextMenu != t.doc.sel && (t.display.input.reset(), c && setTimeout(function () { return t.display.input.reset(!0) }, 20)), t.display.input.receivedFocus()), as(t)) } function Ar(t, e) { t.state.delayingBlurEvent || (t.state.focused && (ie(t, "blur", t, e), t.state.focused = !1, dt(t.display.wrapper, "CodeMirror-focused")), clearInterval(t.display.blinker), setTimeout(function () { t.state.focused || (t.display.shift = !1) }, 150)) } function jn(t) { for (var e = t.display, u = e.lineDiv.offsetTop, s = Math.max(0, e.scroller.getBoundingClientRect().top), g = e.lineDiv.getBoundingClientRect().top, A = 0, w = 0; w < e.view.length; w++) { var T = e.view[w], B = t.options.lineWrapping, M = void 0, Y = 0; if (!T.hidden) { if (g += T.line.height, a && l < 8) { var j = T.node.offsetTop + T.node.offsetHeight; M = j - u, u = j } else { var ot = T.node.getBoundingClientRect(); M = ot.bottom - ot.top, !B && T.text.firstChild && (Y = T.text.firstChild.getBoundingClientRect().right - ot.left - 1) } var nt = T.line.height - M; if ((nt > .005 || nt < -.005) && (g < s && (A -= nt), $e(T.line, M), Jo(T.line), T.rest)) for (var Ct = 0; Ct < T.rest.length; Ct++)Jo(T.rest[Ct]); if (Y > t.display.sizerWidth) { var Tt = Math.ceil(Y / yr(t.display)); Tt > t.display.maxLineLength && (t.display.maxLineLength = Tt, t.display.maxLine = T.line, t.display.maxLineChanged = !0) } } } Math.abs(A) > 2 && (e.scroller.scrollTop += A) } function Jo(t) { if (t.widgets) for (var e = 0; e < t.widgets.length; ++e) { var u = t.widgets[e], s = u.node.parentNode; s && (u.height = s.offsetHeight) } } function Xn(t, e, u) { var s = u && u.top != null ? Math.max(0, u.top) : t.scroller.scrollTop; s = Math.floor(s - Vn(t)); var g = u && u.bottom != null ? u.bottom : s + t.wrapper.clientHeight, A = di(e, s), w = di(e, g); if (u && u.ensure) { var T = u.ensure.from.line, B = u.ensure.to.line; T < A ? (A = T, w = di(e, Ei(Wt(e, T)) + t.wrapper.clientHeight)) : Math.min(B, e.lastLine()) >= w && (A = di(e, Ei(Wt(e, B)) - t.wrapper.clientHeight), w = B) } return { from: A, to: Math.max(w, A + 1) } } function dh(t, e) {
        if (!oe(t, "scrollCursorIntoView")) {
          var u = t.display, s = u.sizer.getBoundingClientRect(), g = null, A = u.wrapper.ownerDocument; if (e.top + s.top < 0 ? g = !0 : e.bottom + s.top > (A.defaultView.innerHeight || A.documentElement.clientHeight) && (g = !1), g != null && !m) {
            var w = W("div", "​", null, `position: absolute;
                         top: `+ (e.top - u.viewOffset - Vn(t.display)) + `px;
                         height: `+ (e.bottom - e.top + pi(t) + u.barHeight) + `px;
                         left: `+ e.left + "px; width: " + Math.max(2, e.right - e.left) + "px;"); t.display.lineSpace.appendChild(w), w.scrollIntoView(g), t.display.lineSpace.removeChild(w)
          }
        }
      } function gh(t, e, u, s) { s == null && (s = 0); var g; !t.options.lineWrapping && e == u && (u = e.sticky == "before" ? Z(e.line, e.ch + 1, "before") : e, e = e.ch ? Z(e.line, e.sticky == "before" ? e.ch - 1 : e.ch, "after") : e); for (var A = 0; A < 5; A++) { var w = !1, T = ri(t, e), B = !u || u == e ? T : ri(t, u); g = { left: Math.min(T.left, B.left), top: Math.min(T.top, B.top) - s, right: Math.max(T.left, B.left), bottom: Math.max(T.bottom, B.bottom) + s }; var M = ls(t, g), Y = t.doc.scrollTop, j = t.doc.scrollLeft; if (M.scrollTop != null && (qr(t, M.scrollTop), Math.abs(t.doc.scrollTop - Y) > 1 && (w = !0)), M.scrollLeft != null && (er(t, M.scrollLeft), Math.abs(t.doc.scrollLeft - j) > 1 && (w = !0)), !w) break } return g } function ph(t, e) { var u = ls(t, e); u.scrollTop != null && qr(t, u.scrollTop), u.scrollLeft != null && er(t, u.scrollLeft) } function ls(t, e) { var u = t.display, s = mr(t.display); e.top < 0 && (e.top = 0); var g = t.curOp && t.curOp.scrollTop != null ? t.curOp.scrollTop : u.scroller.scrollTop, A = Ka(t), w = {}; e.bottom - e.top > A && (e.bottom = e.top + A); var T = t.doc.height + Xa(u), B = e.top < s, M = e.bottom > T - s; if (e.top < g) w.scrollTop = B ? 0 : e.top; else if (e.bottom > g + A) { var Y = Math.min(e.top, (M ? T : e.bottom) - A); Y != g && (w.scrollTop = Y) } var j = t.options.fixedGutter ? 0 : u.gutters.offsetWidth, ot = t.curOp && t.curOp.scrollLeft != null ? t.curOp.scrollLeft : u.scroller.scrollLeft - j, nt = Ji(t) - u.gutters.offsetWidth, Ct = e.right - e.left > nt; return Ct && (e.right = e.left + nt), e.left < 10 ? w.scrollLeft = 0 : e.left < ot ? w.scrollLeft = Math.max(0, e.left + j - (Ct ? 0 : 10)) : e.right > nt + ot - 3 && (w.scrollLeft = e.right + (Ct ? 0 : 10) - nt), w } function us(t, e) { e != null && (Kn(t), t.curOp.scrollTop = (t.curOp.scrollTop == null ? t.doc.scrollTop : t.curOp.scrollTop) + e) } function Cr(t) { Kn(t); var e = t.getCursor(); t.curOp.scrollToPos = { from: e, to: e, margin: t.options.cursorScrollMargin } } function Kr(t, e, u) { (e != null || u != null) && Kn(t), e != null && (t.curOp.scrollLeft = e), u != null && (t.curOp.scrollTop = u) } function vh(t, e) { Kn(t), t.curOp.scrollToPos = e } function Kn(t) { var e = t.curOp.scrollToPos; if (e) { t.curOp.scrollToPos = null; var u = Uo(t, e.from), s = Uo(t, e.to); Zo(t, u, s, e.margin) } } function Zo(t, e, u, s) { var g = ls(t, { left: Math.min(e.left, u.left), top: Math.min(e.top, u.top) - s, right: Math.max(e.right, u.right), bottom: Math.max(e.bottom, u.bottom) + s }); Kr(t, g.scrollLeft, g.scrollTop) } function qr(t, e) { Math.abs(t.doc.scrollTop - e) < 2 || (k || hs(t, { top: e }), $o(t, e, !0), k && hs(t), $r(t, 100)) } function $o(t, e, u) { e = Math.max(0, Math.min(t.display.scroller.scrollHeight - t.display.scroller.clientHeight, e)), !(t.display.scroller.scrollTop == e && !u) && (t.doc.scrollTop = e, t.display.scrollbars.setScrollTop(e), t.display.scroller.scrollTop != e && (t.display.scroller.scrollTop = e)) } function er(t, e, u, s) { e = Math.max(0, Math.min(e, t.display.scroller.scrollWidth - t.display.scroller.clientWidth)), !((u ? e == t.doc.scrollLeft : Math.abs(t.doc.scrollLeft - e) < 2) && !s) && (t.doc.scrollLeft = e, nl(t), t.display.scroller.scrollLeft != e && (t.display.scroller.scrollLeft = e), t.display.scrollbars.setScrollLeft(e)) } function Jr(t) { var e = t.display, u = e.gutters.offsetWidth, s = Math.round(t.doc.height + Xa(t.display)); return { clientHeight: e.scroller.clientHeight, viewHeight: e.wrapper.clientHeight, scrollWidth: e.scroller.scrollWidth, clientWidth: e.scroller.clientWidth, viewWidth: e.wrapper.clientWidth, barLeft: t.options.fixedGutter ? u : 0, docHeight: s, scrollHeight: s + pi(t) + e.barHeight, nativeBarWidth: e.nativeBarWidth, gutterWidth: u } } var ir = function (t, e, u) { this.cm = u; var s = this.vert = W("div", [W("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), g = this.horiz = W("div", [W("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"); s.tabIndex = g.tabIndex = -1, t(s), t(g), It(s, "scroll", function () { s.clientHeight && e(s.scrollTop, "vertical") }), It(g, "scroll", function () { g.clientWidth && e(g.scrollLeft, "horizontal") }), this.checkedZeroWidth = !1, a && l < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px") }; ir.prototype.update = function (t) { var e = t.scrollWidth > t.clientWidth + 1, u = t.scrollHeight > t.clientHeight + 1, s = t.nativeBarWidth; if (u) { this.vert.style.display = "block", this.vert.style.bottom = e ? s + "px" : "0"; var g = t.viewHeight - (e ? s : 0); this.vert.firstChild.style.height = Math.max(0, t.scrollHeight - t.clientHeight + g) + "px" } else this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0"; if (e) { this.horiz.style.display = "block", this.horiz.style.right = u ? s + "px" : "0", this.horiz.style.left = t.barLeft + "px"; var A = t.viewWidth - t.barLeft - (u ? s : 0); this.horiz.firstChild.style.width = Math.max(0, t.scrollWidth - t.clientWidth + A) + "px" } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0"; return !this.checkedZeroWidth && t.clientHeight > 0 && (s == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: u ? s : 0, bottom: e ? s : 0 } }, ir.prototype.setScrollLeft = function (t) { this.horiz.scrollLeft != t && (this.horiz.scrollLeft = t), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz") }, ir.prototype.setScrollTop = function (t) { this.vert.scrollTop != t && (this.vert.scrollTop = t), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert") }, ir.prototype.zeroWidthHack = function () { var t = I && !f ? "12px" : "18px"; this.horiz.style.height = this.vert.style.width = t, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new ht, this.disableVert = new ht }, ir.prototype.enableZeroWidthBar = function (t, e, u) { t.style.visibility = ""; function s() { var g = t.getBoundingClientRect(), A = u == "vert" ? document.elementFromPoint(g.right - 1, (g.top + g.bottom) / 2) : document.elementFromPoint((g.right + g.left) / 2, g.bottom - 1); A != t ? t.style.visibility = "hidden" : e.set(1e3, s) } e.set(1e3, s) }, ir.prototype.clear = function () { var t = this.horiz.parentNode; t.removeChild(this.horiz), t.removeChild(this.vert) }; var Zr = function () { }; Zr.prototype.update = function () { return { bottom: 0, right: 0 } }, Zr.prototype.setScrollLeft = function () { }, Zr.prototype.setScrollTop = function () { }, Zr.prototype.clear = function () { }; function br(t, e) { e || (e = Jr(t)); var u = t.display.barWidth, s = t.display.barHeight; tl(t, e); for (var g = 0; g < 4 && u != t.display.barWidth || s != t.display.barHeight; g++)u != t.display.barWidth && t.options.lineWrapping && jn(t), tl(t, Jr(t)), u = t.display.barWidth, s = t.display.barHeight } function tl(t, e) { var u = t.display, s = u.scrollbars.update(e); u.sizer.style.paddingRight = (u.barWidth = s.right) + "px", u.sizer.style.paddingBottom = (u.barHeight = s.bottom) + "px", u.heightForcer.style.borderBottom = s.bottom + "px solid transparent", s.right && s.bottom ? (u.scrollbarFiller.style.display = "block", u.scrollbarFiller.style.height = s.bottom + "px", u.scrollbarFiller.style.width = s.right + "px") : u.scrollbarFiller.style.display = "", s.bottom && t.options.coverGutterNextToScrollbar && t.options.fixedGutter ? (u.gutterFiller.style.display = "block", u.gutterFiller.style.height = s.bottom + "px", u.gutterFiller.style.width = e.gutterWidth + "px") : u.gutterFiller.style.display = "" } var el = { native: ir, null: Zr }; function il(t) { t.display.scrollbars && (t.display.scrollbars.clear(), t.display.scrollbars.addClass && dt(t.display.wrapper, t.display.scrollbars.addClass)), t.display.scrollbars = new el[t.options.scrollbarStyle](function (e) { t.display.wrapper.insertBefore(e, t.display.scrollbarFiller), It(e, "mousedown", function () { t.state.focused && setTimeout(function () { return t.display.input.focus() }, 0) }), e.setAttribute("cm-not-content", "true") }, function (e, u) { u == "horizontal" ? er(t, e) : qr(t, e) }, t), t.display.scrollbars.addClass && V(t.display.wrapper, t.display.scrollbars.addClass) } var mh = 0; function rr(t) { t.curOp = { cm: t, viewChanged: !1, startHeight: t.doc.height, forceUpdate: !1, updateInput: 0, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++mh, markArrays: null }, Xf(t.curOp) } function nr(t) { var e = t.curOp; e && qf(e, function (u) { for (var s = 0; s < u.ops.length; s++)u.ops[s].cm.curOp = null; yh(u) }) } function yh(t) { for (var e = t.ops, u = 0; u < e.length; u++)Ah(e[u]); for (var s = 0; s < e.length; s++)Ch(e[s]); for (var g = 0; g < e.length; g++)bh(e[g]); for (var A = 0; A < e.length; A++)wh(e[A]); for (var w = 0; w < e.length; w++)xh(e[w]) } function Ah(t) { var e = t.cm, u = e.display; Sh(e), t.updateMaxLine && Ga(e), t.mustUpdate = t.viewChanged || t.forceUpdate || t.scrollTop != null || t.scrollToPos && (t.scrollToPos.from.line < u.viewFrom || t.scrollToPos.to.line >= u.viewTo) || u.maxLineChanged && e.options.lineWrapping, t.update = t.mustUpdate && new qn(e, t.mustUpdate && { top: t.scrollTop, ensure: t.scrollToPos }, t.forceUpdate) } function Ch(t) { t.updatedDisplay = t.mustUpdate && fs(t.cm, t.update) } function bh(t) { var e = t.cm, u = e.display; t.updatedDisplay && jn(e), t.barMeasure = Jr(e), u.maxLineChanged && !e.options.lineWrapping && (t.adjustWidthTo = Po(e, u.maxLine, u.maxLine.text.length).left + 3, e.display.sizerWidth = t.adjustWidthTo, t.barMeasure.scrollWidth = Math.max(u.scroller.clientWidth, u.sizer.offsetLeft + t.adjustWidthTo + pi(e) + e.display.barWidth), t.maxScrollLeft = Math.max(0, u.sizer.offsetLeft + t.adjustWidthTo - Ji(e))), (t.updatedDisplay || t.selectionChanged) && (t.preparedSelection = u.input.prepareSelection()) } function wh(t) { var e = t.cm; t.adjustWidthTo != null && (e.display.sizer.style.minWidth = t.adjustWidthTo + "px", t.maxScrollLeft < e.doc.scrollLeft && er(e, Math.min(e.display.scroller.scrollLeft, t.maxScrollLeft), !0), e.display.maxLineChanged = !1); var u = t.focus && t.focus == O(lt(e)); t.preparedSelection && e.display.input.showSelection(t.preparedSelection, u), (t.updatedDisplay || t.startHeight != e.doc.height) && br(e, t.barMeasure), t.updatedDisplay && ds(e, t.barMeasure), t.selectionChanged && as(e), e.state.focused && t.updateInput && e.display.input.reset(t.typing), u && qo(t.cm) } function xh(t) { var e = t.cm, u = e.display, s = e.doc; if (t.updatedDisplay && rl(e, t.update), u.wheelStartX != null && (t.scrollTop != null || t.scrollLeft != null || t.scrollToPos) && (u.wheelStartX = u.wheelStartY = null), t.scrollTop != null && $o(e, t.scrollTop, t.forceScroll), t.scrollLeft != null && er(e, t.scrollLeft, !0, !0), t.scrollToPos) { var g = gh(e, Ht(s, t.scrollToPos.from), Ht(s, t.scrollToPos.to), t.scrollToPos.margin); dh(e, g) } var A = t.maybeHiddenMarkers, w = t.maybeUnhiddenMarkers; if (A) for (var T = 0; T < A.length; ++T)A[T].lines.length || ie(A[T], "hide"); if (w) for (var B = 0; B < w.length; ++B)w[B].lines.length && ie(w[B], "unhide"); u.wrapper.offsetHeight && (s.scrollTop = e.display.scroller.scrollTop), t.changeObjs && ie(e, "changes", e, t.changeObjs), t.update && t.update.finish() } function He(t, e) { if (t.curOp) return e(); rr(t); try { return e() } finally { nr(t) } } function Te(t, e) { return function () { if (t.curOp) return e.apply(t, arguments); rr(t); try { return e.apply(t, arguments) } finally { nr(t) } } } function Fe(t) { return function () { if (this.curOp) return t.apply(this, arguments); rr(this); try { return t.apply(this, arguments) } finally { nr(this) } } } function Ee(t) { return function () { var e = this.cm; if (!e || e.curOp) return t.apply(this, arguments); rr(e); try { return t.apply(this, arguments) } finally { nr(e) } } } function $r(t, e) { t.doc.highlightFrontier < t.display.viewTo && t.state.highlight.set(e, R(_h, t)) } function _h(t) { var e = t.doc; if (!(e.highlightFrontier >= t.display.viewTo)) { var u = +new Date + t.options.workTime, s = Vr(t, e.highlightFrontier), g = []; e.iter(s.line, Math.min(e.first + e.size, t.display.viewTo + 500), function (A) { if (s.line >= t.display.viewFrom) { var w = A.styles, T = A.text.length > t.options.maxHighlightLength ? _i(e.mode, s.state) : null, B = uo(t, A, s, !0); T && (s.state = T), A.styles = B.styles; var M = A.styleClasses, Y = B.classes; Y ? A.styleClasses = Y : M && (A.styleClasses = null); for (var j = !w || w.length != A.styles.length || M != Y && (!M || !Y || M.bgClass != Y.bgClass || M.textClass != Y.textClass), ot = 0; !j && ot < w.length; ++ot)j = w[ot] != A.styles[ot]; j && g.push(s.line), A.stateAfter = s.save(), s.nextLine() } else A.text.length <= t.options.maxHighlightLength && Na(t, A.text, s), A.stateAfter = s.line % 5 == 0 ? s.save() : null, s.nextLine(); if (+new Date > u) return $r(t, t.options.workDelay), !0 }), e.highlightFrontier = s.line, e.modeFrontier = Math.max(e.modeFrontier, s.line), g.length && He(t, function () { for (var A = 0; A < g.length; A++)Ni(t, g[A], "text") }) } } var qn = function (t, e, u) { var s = t.display; this.viewport = e, this.visible = Xn(s, t.doc, e), this.editorIsHidden = !s.wrapper.offsetWidth, this.wrapperHeight = s.wrapper.clientHeight, this.wrapperWidth = s.wrapper.clientWidth, this.oldDisplayWidth = Ji(t), this.force = u, this.dims = es(t), this.events = [] }; qn.prototype.signal = function (t, e) { we(t, e) && this.events.push(arguments) }, qn.prototype.finish = function () { for (var t = 0; t < this.events.length; t++)ie.apply(null, this.events[t]) }; function Sh(t) { var e = t.display; !e.scrollbarsClipped && e.scroller.offsetWidth && (e.nativeBarWidth = e.scroller.offsetWidth - e.scroller.clientWidth, e.heightForcer.style.height = pi(t) + "px", e.sizer.style.marginBottom = -e.nativeBarWidth + "px", e.sizer.style.borderRightWidth = pi(t) + "px", e.scrollbarsClipped = !0) } function Th(t) { if (t.hasFocus()) return null; var e = O(lt(t)); if (!e || !it(t.display.lineDiv, e)) return null; var u = { activeElt: e }; if (window.getSelection) { var s = H(t).getSelection(); s.anchorNode && s.extend && it(t.display.lineDiv, s.anchorNode) && (u.anchorNode = s.anchorNode, u.anchorOffset = s.anchorOffset, u.focusNode = s.focusNode, u.focusOffset = s.focusOffset) } return u } function Eh(t) { if (!(!t || !t.activeElt || t.activeElt == O(t.activeElt.ownerDocument)) && (t.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(t.activeElt.nodeName) && t.anchorNode && it(document.body, t.anchorNode) && it(document.body, t.focusNode))) { var e = t.activeElt.ownerDocument, u = e.defaultView.getSelection(), s = e.createRange(); s.setEnd(t.anchorNode, t.anchorOffset), s.collapse(!1), u.removeAllRanges(), u.addRange(s), u.extend(t.focusNode, t.focusOffset) } } function fs(t, e) { var u = t.display, s = t.doc; if (e.editorIsHidden) return Yi(t), !1; if (!e.force && e.visible.from >= u.viewFrom && e.visible.to <= u.viewTo && (u.updateLineNumbers == null || u.updateLineNumbers >= u.viewTo) && u.renderedView == u.view && Xo(t) == 0) return !1; al(t) && (Yi(t), e.dims = es(t)); var g = s.first + s.size, A = Math.max(e.visible.from - t.options.viewportMargin, s.first), w = Math.min(g, e.visible.to + t.options.viewportMargin); u.viewFrom < A && A - u.viewFrom < 20 && (A = Math.max(s.first, u.viewFrom)), u.viewTo > w && u.viewTo - w < 20 && (w = Math.min(g, u.viewTo)), Ti && (A = Ua(t.doc, A), w = _o(t.doc, w)); var T = A != u.viewFrom || w != u.viewTo || u.lastWrapHeight != e.wrapperHeight || u.lastWrapWidth != e.wrapperWidth; hh(t, A, w), u.viewOffset = Ei(Wt(t.doc, u.viewFrom)), t.display.mover.style.top = u.viewOffset + "px"; var B = Xo(t); if (!T && B == 0 && !e.force && u.renderedView == u.view && (u.updateLineNumbers == null || u.updateLineNumbers >= u.viewTo)) return !1; var M = Th(t); return B > 4 && (u.lineDiv.style.display = "none"), Ih(t, u.updateLineNumbers, e.dims), B > 4 && (u.lineDiv.style.display = ""), u.renderedView = u.view, Eh(M), q(u.cursorDiv), q(u.selectionDiv), u.gutters.style.height = u.sizer.style.minHeight = 0, T && (u.lastWrapHeight = e.wrapperHeight, u.lastWrapWidth = e.wrapperWidth, $r(t, 400)), u.updateLineNumbers = null, !0 } function rl(t, e) { for (var u = e.viewport, s = !0; ; s = !1) { if (!s || !t.options.lineWrapping || e.oldDisplayWidth == Ji(t)) { if (u && u.top != null && (u = { top: Math.min(t.doc.height + Xa(t.display) - Ka(t), u.top) }), e.visible = Xn(t.display, t.doc, u), e.visible.from >= t.display.viewFrom && e.visible.to <= t.display.viewTo) break } else s && (e.visible = Xn(t.display, t.doc, u)); if (!fs(t, e)) break; jn(t); var g = Jr(t); Xr(t), br(t, g), ds(t, g), e.force = !1 } e.signal(t, "update", t), (t.display.viewFrom != t.display.reportedViewFrom || t.display.viewTo != t.display.reportedViewTo) && (e.signal(t, "viewportChange", t, t.display.viewFrom, t.display.viewTo), t.display.reportedViewFrom = t.display.viewFrom, t.display.reportedViewTo = t.display.viewTo) } function hs(t, e) { var u = new qn(t, e); if (fs(t, u)) { jn(t), rl(t, u); var s = Jr(t); Xr(t), br(t, s), ds(t, s), u.finish() } } function Ih(t, e, u) { var s = t.display, g = t.options.lineNumbers, A = s.lineDiv, w = A.firstChild; function T(Ct) { var Tt = Ct.nextSibling; return c && I && t.display.currentWheelTarget == Ct ? Ct.style.display = "none" : Ct.parentNode.removeChild(Ct), Tt } for (var B = s.view, M = s.viewFrom, Y = 0; Y < B.length; Y++) { var j = B[Y]; if (!j.hidden) if (!j.node || j.node.parentNode != A) { var ot = eh(t, j, M, u); A.insertBefore(ot, w) } else { for (; w != j.node;)w = T(w); var nt = g && e != null && e <= M && j.lineNumber; j.changes && (ut(j.changes, "gutter") > -1 && (nt = !1), Bo(t, j, M, u)), nt && (q(j.lineNumber), j.lineNumber.appendChild(document.createTextNode(X(t.options, M)))), w = j.node.nextSibling } M += j.size } for (; w;)w = T(w) } function cs(t) { var e = t.gutters.offsetWidth; t.sizer.style.marginLeft = e + "px", Se(t, "gutterChanged", t) } function ds(t, e) { t.display.sizer.style.minHeight = e.docHeight + "px", t.display.heightForcer.style.top = e.docHeight + "px", t.display.gutters.style.height = e.docHeight + t.display.barHeight + pi(t) + "px" } function nl(t) { var e = t.display, u = e.view; if (!(!e.alignWidgets && (!e.gutters.firstChild || !t.options.fixedGutter))) { for (var s = is(e) - e.scroller.scrollLeft + t.doc.scrollLeft, g = e.gutters.offsetWidth, A = s + "px", w = 0; w < u.length; w++)if (!u[w].hidden) { t.options.fixedGutter && (u[w].gutter && (u[w].gutter.style.left = A), u[w].gutterBackground && (u[w].gutterBackground.style.left = A)); var T = u[w].alignable; if (T) for (var B = 0; B < T.length; B++)T[B].style.left = A } t.options.fixedGutter && (e.gutters.style.left = s + g + "px") } } function al(t) { if (!t.options.lineNumbers) return !1; var e = t.doc, u = X(t.options, e.first + e.size - 1), s = t.display; if (u.length != s.lineNumChars) { var g = s.measure.appendChild(W("div", [W("div", u)], "CodeMirror-linenumber CodeMirror-gutter-elt")), A = g.firstChild.offsetWidth, w = g.offsetWidth - A; return s.lineGutter.style.width = "", s.lineNumInnerWidth = Math.max(A, s.lineGutter.offsetWidth - w) + 1, s.lineNumWidth = s.lineNumInnerWidth + w, s.lineNumChars = s.lineNumInnerWidth ? u.length : -1, s.lineGutter.style.width = s.lineNumWidth + "px", cs(t.display), !0 } return !1 } function gs(t, e) { for (var u = [], s = !1, g = 0; g < t.length; g++) { var A = t[g], w = null; if (typeof A != "string" && (w = A.style, A = A.className), A == "CodeMirror-linenumbers") if (e) s = !0; else continue; u.push({ className: A, style: w }) } return e && !s && u.push({ className: "CodeMirror-linenumbers", style: null }), u } function sl(t) { var e = t.gutters, u = t.gutterSpecs; q(e), t.lineGutter = null; for (var s = 0; s < u.length; ++s) { var g = u[s], A = g.className, w = g.style, T = e.appendChild(W("div", null, "CodeMirror-gutter " + A)); w && (T.style.cssText = w), A == "CodeMirror-linenumbers" && (t.lineGutter = T, T.style.width = (t.lineNumWidth || 1) + "px") } e.style.display = u.length ? "" : "none", cs(t) } function tn(t) { sl(t.display), We(t), nl(t) } function Bh(t, e, u, s) { var g = this; this.input = u, g.scrollbarFiller = W("div", null, "CodeMirror-scrollbar-filler"), g.scrollbarFiller.setAttribute("cm-not-content", "true"), g.gutterFiller = W("div", null, "CodeMirror-gutter-filler"), g.gutterFiller.setAttribute("cm-not-content", "true"), g.lineDiv = Dt("div", null, "CodeMirror-code"), g.selectionDiv = W("div", null, null, "position: relative; z-index: 1"), g.cursorDiv = W("div", null, "CodeMirror-cursors"), g.measure = W("div", null, "CodeMirror-measure"), g.lineMeasure = W("div", null, "CodeMirror-measure"), g.lineSpace = Dt("div", [g.measure, g.lineMeasure, g.selectionDiv, g.cursorDiv, g.lineDiv], null, "position: relative; outline: none"); var A = Dt("div", [g.lineSpace], "CodeMirror-lines"); g.mover = W("div", [A], null, "position: relative"), g.sizer = W("div", [g.mover], "CodeMirror-sizer"), g.sizerWidth = null, g.heightForcer = W("div", null, null, "position: absolute; height: " + _t + "px; width: 1px;"), g.gutters = W("div", null, "CodeMirror-gutters"), g.lineGutter = null, g.scroller = W("div", [g.sizer, g.heightForcer, g.gutters], "CodeMirror-scroll"), g.scroller.setAttribute("tabIndex", "-1"), g.wrapper = W("div", [g.scrollbarFiller, g.gutterFiller, g.scroller], "CodeMirror"), i && n >= 105 && (g.wrapper.style.clipPath = "inset(0px)"), g.wrapper.setAttribute("translate", "no"), a && l < 8 && (g.gutters.style.zIndex = -1, g.scroller.style.paddingRight = 0), !c && !(k && x) && (g.scroller.draggable = !0), t && (t.appendChild ? t.appendChild(g.wrapper) : t(g.wrapper)), g.viewFrom = g.viewTo = e.first, g.reportedViewFrom = g.reportedViewTo = e.first, g.view = [], g.renderedView = null, g.externalMeasured = null, g.viewOffset = 0, g.lastWrapHeight = g.lastWrapWidth = 0, g.updateLineNumbers = null, g.nativeBarWidth = g.barHeight = g.barWidth = 0, g.scrollbarsClipped = !1, g.lineNumWidth = g.lineNumInnerWidth = g.lineNumChars = null, g.alignWidgets = !1, g.cachedCharWidth = g.cachedTextHeight = g.cachedPaddingH = null, g.maxLine = null, g.maxLineLength = 0, g.maxLineChanged = !1, g.wheelDX = g.wheelDY = g.wheelStartX = g.wheelStartY = null, g.shift = !1, g.selForContextMenu = null, g.activeTouch = null, g.gutterSpecs = gs(s.gutters, s.lineNumbers), sl(g), u.init(g) } var Jn = 0, Bi = null; a ? Bi = -.53 : k ? Bi = 15 : i ? Bi = -.7 : p && (Bi = -1 / 3); function ol(t) { var e = t.wheelDeltaX, u = t.wheelDeltaY; return e == null && t.detail && t.axis == t.HORIZONTAL_AXIS && (e = t.detail), u == null && t.detail && t.axis == t.VERTICAL_AXIS ? u = t.detail : u == null && (u = t.wheelDelta), { x: e, y: u } } function kh(t) { var e = ol(t); return e.x *= Bi, e.y *= Bi, e } function ll(t, e) { i && n == 102 && (t.display.chromeScrollHack == null ? t.display.sizer.style.pointerEvents = "none" : clearTimeout(t.display.chromeScrollHack), t.display.chromeScrollHack = setTimeout(function () { t.display.chromeScrollHack = null, t.display.sizer.style.pointerEvents = "" }, 100)); var u = ol(e), s = u.x, g = u.y, A = Bi; e.deltaMode === 0 && (s = e.deltaX, g = e.deltaY, A = 1); var w = t.display, T = w.scroller, B = T.scrollWidth > T.clientWidth, M = T.scrollHeight > T.clientHeight; if (s && B || g && M) { if (g && I && c) { t: for (var Y = e.target, j = w.view; Y != T; Y = Y.parentNode)for (var ot = 0; ot < j.length; ot++)if (j[ot].node == Y) { t.display.currentWheelTarget = Y; break t } } if (s && !k && !o && A != null) { g && M && qr(t, Math.max(0, T.scrollTop + g * A)), er(t, Math.max(0, T.scrollLeft + s * A)), (!g || g && M) && de(e), w.wheelStartX = null; return } if (g && A != null) { var nt = g * A, Ct = t.doc.scrollTop, Tt = Ct + w.wrapper.clientHeight; nt < 0 ? Ct = Math.max(0, Ct + nt - 50) : Tt = Math.min(t.doc.height, Tt + nt + 50), hs(t, { top: Ct, bottom: Tt }) } Jn < 20 && e.deltaMode !== 0 && (w.wheelStartX == null ? (w.wheelStartX = T.scrollLeft, w.wheelStartY = T.scrollTop, w.wheelDX = s, w.wheelDY = g, setTimeout(function () { if (w.wheelStartX != null) { var Bt = T.scrollLeft - w.wheelStartX, Mt = T.scrollTop - w.wheelStartY, Pt = Mt && w.wheelDY && Mt / w.wheelDY || Bt && w.wheelDX && Bt / w.wheelDX; w.wheelStartX = w.wheelStartY = null, Pt && (Bi = (Bi * Jn + Pt) / (Jn + 1), ++Jn) } }, 200)) : (w.wheelDX += s, w.wheelDY += g)) } } var Ke = function (t, e) { this.ranges = t, this.primIndex = e }; Ke.prototype.primary = function () { return this.ranges[this.primIndex] }, Ke.prototype.equals = function (t) { if (t == this) return !0; if (t.primIndex != this.primIndex || t.ranges.length != this.ranges.length) return !1; for (var e = 0; e < this.ranges.length; e++) { var u = this.ranges[e], s = t.ranges[e]; if (!Ut(u.anchor, s.anchor) || !Ut(u.head, s.head)) return !1 } return !0 }, Ke.prototype.deepCopy = function () { for (var t = [], e = 0; e < this.ranges.length; e++)t[e] = new te(qt(this.ranges[e].anchor), qt(this.ranges[e].head)); return new Ke(t, this.primIndex) }, Ke.prototype.somethingSelected = function () { for (var t = 0; t < this.ranges.length; t++)if (!this.ranges[t].empty()) return !0; return !1 }, Ke.prototype.contains = function (t, e) { e || (e = t); for (var u = 0; u < this.ranges.length; u++) { var s = this.ranges[u]; if (At(e, s.from()) >= 0 && At(t, s.to()) <= 0) return u } return -1 }; var te = function (t, e) { this.anchor = t, this.head = e }; te.prototype.from = function () { return xe(this.anchor, this.head) }, te.prototype.to = function () { return Zt(this.anchor, this.head) }, te.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch }; function ni(t, e, u) { var s = t && t.options.selectionsMayTouch, g = e[u]; e.sort(function (ot, nt) { return At(ot.from(), nt.from()) }), u = ut(e, g); for (var A = 1; A < e.length; A++) { var w = e[A], T = e[A - 1], B = At(T.to(), w.from()); if (s && !w.empty() ? B > 0 : B >= 0) { var M = xe(T.from(), w.from()), Y = Zt(T.to(), w.to()), j = T.empty() ? w.from() == w.head : T.from() == T.head; A <= u && --u, e.splice(--A, 2, new te(j ? Y : M, j ? M : Y)) } } return new Ke(e, u) } function Vi(t, e) { return new Ke([new te(t, e || t)], 0) } function zi(t) { return t.text ? Z(t.from.line + t.text.length - 1, vt(t.text).length + (t.text.length == 1 ? t.from.ch : 0)) : t.to } function ul(t, e) { if (At(t, e.from) < 0) return t; if (At(t, e.to) <= 0) return zi(e); var u = t.line + e.text.length - (e.to.line - e.from.line) - 1, s = t.ch; return t.line == e.to.line && (s += zi(e).ch - e.to.ch), Z(u, s) } function ps(t, e) { for (var u = [], s = 0; s < t.sel.ranges.length; s++) { var g = t.sel.ranges[s]; u.push(new te(ul(g.anchor, e), ul(g.head, e))) } return ni(t.cm, u, t.sel.primIndex) } function fl(t, e, u) { return t.line == e.line ? Z(u.line, t.ch - e.ch + u.ch) : Z(u.line + (t.line - e.line), t.ch) } function Mh(t, e, u) { for (var s = [], g = Z(t.first, 0), A = g, w = 0; w < e.length; w++) { var T = e[w], B = fl(T.from, g, A), M = fl(zi(T), g, A); if (g = T.to, A = M, u == "around") { var Y = t.sel.ranges[w], j = At(Y.head, Y.anchor) < 0; s[w] = new te(j ? M : B, j ? B : M) } else s[w] = new te(B, B) } return new Ke(s, t.sel.primIndex) } function vs(t) { t.doc.mode = xi(t.options, t.doc.modeOption), en(t) } function en(t) { t.doc.iter(function (e) { e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null) }), t.doc.modeFrontier = t.doc.highlightFrontier = t.doc.first, $r(t, 100), t.state.modeGen++, t.curOp && We(t) } function hl(t, e) { return e.from.ch == 0 && e.to.ch == 0 && vt(e.text) == "" && (!t.cm || t.cm.options.wholeLineUpdateBefore) } function ms(t, e, u, s) { function g(Pt) { return u ? u[Pt] : null } function A(Pt, Ot, Rt) { Wf(Pt, Ot, Rt, s), Se(Pt, "change", Pt, e) } function w(Pt, Ot) { for (var Rt = [], Yt = Pt; Yt < Ot; ++Yt)Rt.push(new gr(M[Yt], g(Yt), s)); return Rt } var T = e.from, B = e.to, M = e.text, Y = Wt(t, T.line), j = Wt(t, B.line), ot = vt(M), nt = g(M.length - 1), Ct = B.line - T.line; if (e.full) t.insert(0, w(0, M.length)), t.remove(M.length, t.size - M.length); else if (hl(t, e)) { var Tt = w(0, M.length - 1); A(j, j.text, nt), Ct && t.remove(T.line, Ct), Tt.length && t.insert(T.line, Tt) } else if (Y == j) if (M.length == 1) A(Y, Y.text.slice(0, T.ch) + ot + Y.text.slice(B.ch), nt); else { var Bt = w(1, M.length - 1); Bt.push(new gr(ot + Y.text.slice(B.ch), nt, s)), A(Y, Y.text.slice(0, T.ch) + M[0], g(0)), t.insert(T.line + 1, Bt) } else if (M.length == 1) A(Y, Y.text.slice(0, T.ch) + M[0] + j.text.slice(B.ch), g(0)), t.remove(T.line + 1, Ct); else { A(Y, Y.text.slice(0, T.ch) + M[0], g(0)), A(j, ot + j.text.slice(B.ch), nt); var Mt = w(1, M.length - 1); Ct > 1 && t.remove(T.line + 1, Ct - 1), t.insert(T.line + 1, Mt) } Se(t, "change", t, e) } function Ui(t, e, u) { function s(g, A, w) { if (g.linked) for (var T = 0; T < g.linked.length; ++T) { var B = g.linked[T]; if (B.doc != A) { var M = w && B.sharedHist; u && !M || (e(B.doc, M), s(B.doc, g, M)) } } } s(t, null, !0) } function cl(t, e) { if (e.cm) throw new Error("This document is already in use."); t.doc = e, e.cm = t, rs(t), vs(t), dl(t), t.options.direction = e.direction, t.options.lineWrapping || Ga(t), t.options.mode = e.modeOption, We(t) } function dl(t) { (t.doc.direction == "rtl" ? V : dt)(t.display.lineDiv, "CodeMirror-rtl") } function Oh(t) { He(t, function () { dl(t), We(t) }) } function Zn(t) { this.done = [], this.undone = [], this.undoDepth = t ? t.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = t ? t.maxGeneration : 1 } function ys(t, e) { var u = { from: qt(e.from), to: zi(e), text: Si(t, e.from, e.to) }; return vl(t, u, e.from.line, e.to.line + 1), Ui(t, function (s) { return vl(s, u, e.from.line, e.to.line + 1) }, !0), u } function gl(t) { for (; t.length;) { var e = vt(t); if (e.ranges) t.pop(); else break } } function Dh(t, e) { if (e) return gl(t.done), vt(t.done); if (t.done.length && !vt(t.done).ranges) return vt(t.done); if (t.done.length > 1 && !t.done[t.done.length - 2].ranges) return t.done.pop(), vt(t.done) } function pl(t, e, u, s) { var g = t.history; g.undone.length = 0; var A = +new Date, w, T; if ((g.lastOp == s || g.lastOrigin == e.origin && e.origin && (e.origin.charAt(0) == "+" && g.lastModTime > A - (t.cm ? t.cm.options.historyEventDelay : 500) || e.origin.charAt(0) == "*")) && (w = Dh(g, g.lastOp == s))) T = vt(w.changes), At(e.from, e.to) == 0 && At(e.from, T.to) == 0 ? T.to = zi(e) : w.changes.push(ys(t, e)); else { var B = vt(g.done); for ((!B || !B.ranges) && $n(t.sel, g.done), w = { changes: [ys(t, e)], generation: g.generation }, g.done.push(w); g.done.length > g.undoDepth;)g.done.shift(), g.done[0].ranges || g.done.shift() } g.done.push(u), g.generation = ++g.maxGeneration, g.lastModTime = g.lastSelTime = A, g.lastOp = g.lastSelOp = s, g.lastOrigin = g.lastSelOrigin = e.origin, T || ie(t, "historyAdded") } function Lh(t, e, u, s) { var g = e.charAt(0); return g == "*" || g == "+" && u.ranges.length == s.ranges.length && u.somethingSelected() == s.somethingSelected() && new Date - t.history.lastSelTime <= (t.cm ? t.cm.options.historyEventDelay : 500) } function Fh(t, e, u, s) { var g = t.history, A = s && s.origin; u == g.lastSelOp || A && g.lastSelOrigin == A && (g.lastModTime == g.lastSelTime && g.lastOrigin == A || Lh(t, A, vt(g.done), e)) ? g.done[g.done.length - 1] = e : $n(e, g.done), g.lastSelTime = +new Date, g.lastSelOrigin = A, g.lastSelOp = u, s && s.clearRedo !== !1 && gl(g.undone) } function $n(t, e) { var u = vt(e); u && u.ranges && u.equals(t) || e.push(t) } function vl(t, e, u, s) { var g = e["spans_" + t.id], A = 0; t.iter(Math.max(t.first, u), Math.min(t.first + t.size, s), function (w) { w.markedSpans && ((g || (g = e["spans_" + t.id] = {}))[A] = w.markedSpans), ++A }) } function Ph(t) { if (!t) return null; for (var e, u = 0; u < t.length; ++u)t[u].marker.explicitlyCleared ? e || (e = t.slice(0, u)) : e && e.push(t[u]); return e ? e.length ? e : null : t } function Rh(t, e) { var u = e["spans_" + t.id]; if (!u) return null; for (var s = [], g = 0; g < e.text.length; ++g)s.push(Ph(u[g])); return s } function ml(t, e) { var u = Rh(t, e), s = Va(t, e); if (!u) return s; if (!s) return u; for (var g = 0; g < u.length; ++g) { var A = u[g], w = s[g]; if (A && w) t: for (var T = 0; T < w.length; ++T) { for (var B = w[T], M = 0; M < A.length; ++M)if (A[M].marker == B.marker) continue t; A.push(B) } else w && (u[g] = w) } return u } function wr(t, e, u) { for (var s = [], g = 0; g < t.length; ++g) { var A = t[g]; if (A.ranges) { s.push(u ? Ke.prototype.deepCopy.call(A) : A); continue } var w = A.changes, T = []; s.push({ changes: T }); for (var B = 0; B < w.length; ++B) { var M = w[B], Y = void 0; if (T.push({ from: M.from, to: M.to, text: M.text }), e) for (var j in M) (Y = j.match(/^spans_(\d+)$/)) && ut(e, Number(Y[1])) > -1 && (vt(T)[j] = M[j], delete M[j]) } } return s } function As(t, e, u, s) { if (s) { var g = t.anchor; if (u) { var A = At(e, g) < 0; A != At(u, g) < 0 ? (g = e, e = u) : A != At(e, u) < 0 && (e = u) } return new te(g, e) } else return new te(u || e, e) } function ta(t, e, u, s, g) { g == null && (g = t.cm && (t.cm.display.shift || t.extend)), De(t, new Ke([As(t.sel.primary(), e, u, g)], 0), s) } function yl(t, e, u) { for (var s = [], g = t.cm && (t.cm.display.shift || t.extend), A = 0; A < t.sel.ranges.length; A++)s[A] = As(t.sel.ranges[A], e[A], null, g); var w = ni(t.cm, s, t.sel.primIndex); De(t, w, u) } function Cs(t, e, u, s) { var g = t.sel.ranges.slice(0); g[e] = u, De(t, ni(t.cm, g, t.sel.primIndex), s) } function Al(t, e, u, s) { De(t, Vi(e, u), s) } function Qh(t, e, u) { var s = { ranges: e.ranges, update: function (g) { this.ranges = []; for (var A = 0; A < g.length; A++)this.ranges[A] = new te(Ht(t, g[A].anchor), Ht(t, g[A].head)) }, origin: u && u.origin }; return ie(t, "beforeSelectionChange", t, s), t.cm && ie(t.cm, "beforeSelectionChange", t.cm, s), s.ranges != e.ranges ? ni(t.cm, s.ranges, s.ranges.length - 1) : e } function Cl(t, e, u) { var s = t.history.done, g = vt(s); g && g.ranges ? (s[s.length - 1] = e, ea(t, e, u)) : De(t, e, u) } function De(t, e, u) { ea(t, e, u), Fh(t, t.sel, t.cm ? t.cm.curOp.id : NaN, u) } function ea(t, e, u) { (we(t, "beforeSelectionChange") || t.cm && we(t.cm, "beforeSelectionChange")) && (e = Qh(t, e, u)); var s = u && u.bias || (At(e.primary().head, t.sel.primary().head) < 0 ? -1 : 1); bl(t, xl(t, e, s, !0)), !(u && u.scroll === !1) && t.cm && t.cm.getOption("readOnly") != "nocursor" && Cr(t.cm) } function bl(t, e) { e.equals(t.sel) || (t.sel = e, t.cm && (t.cm.curOp.updateInput = 1, t.cm.curOp.selectionChanged = !0, qi(t.cm)), Se(t, "cursorActivity", t)) } function wl(t) { bl(t, xl(t, t.sel, null, !1)) } function xl(t, e, u, s) { for (var g, A = 0; A < e.ranges.length; A++) { var w = e.ranges[A], T = e.ranges.length == t.sel.ranges.length && t.sel.ranges[A], B = ia(t, w.anchor, T && T.anchor, u, s), M = w.head == w.anchor ? B : ia(t, w.head, T && T.head, u, s); (g || B != w.anchor || M != w.head) && (g || (g = e.ranges.slice(0, A)), g[A] = new te(B, M)) } return g ? ni(t.cm, g, e.primIndex) : e } function xr(t, e, u, s, g) { var A = Wt(t, e.line); if (A.markedSpans) for (var w = 0; w < A.markedSpans.length; ++w) { var T = A.markedSpans[w], B = T.marker, M = "selectLeft" in B ? !B.selectLeft : B.inclusiveLeft, Y = "selectRight" in B ? !B.selectRight : B.inclusiveRight; if ((T.from == null || (M ? T.from <= e.ch : T.from < e.ch)) && (T.to == null || (Y ? T.to >= e.ch : T.to > e.ch))) { if (g && (ie(B, "beforeCursorEnter"), B.explicitlyCleared)) if (A.markedSpans) { --w; continue } else break; if (!B.atomic) continue; if (u) { var j = B.find(s < 0 ? 1 : -1), ot = void 0; if ((s < 0 ? Y : M) && (j = _l(t, j, -s, j && j.line == e.line ? A : null)), j && j.line == e.line && (ot = At(j, u)) && (s < 0 ? ot < 0 : ot > 0)) return xr(t, j, e, s, g) } var nt = B.find(s < 0 ? -1 : 1); return (s < 0 ? M : Y) && (nt = _l(t, nt, s, nt.line == e.line ? A : null)), nt ? xr(t, nt, e, s, g) : null } } return e } function ia(t, e, u, s, g) { var A = s || 1, w = xr(t, e, u, A, g) || !g && xr(t, e, u, A, !0) || xr(t, e, u, -A, g) || !g && xr(t, e, u, -A, !0); return w || (t.cantEdit = !0, Z(t.first, 0)) } function _l(t, e, u, s) { return u < 0 && e.ch == 0 ? e.line > t.first ? Ht(t, Z(e.line - 1)) : null : u > 0 && e.ch == (s || Wt(t, e.line)).text.length ? e.line < t.first + t.size - 1 ? Z(e.line + 1, 0) : null : new Z(e.line, e.ch + u) } function Sl(t) { t.setSelection(Z(t.firstLine(), 0), Z(t.lastLine()), St) } function Tl(t, e, u) { var s = { canceled: !1, from: e.from, to: e.to, text: e.text, origin: e.origin, cancel: function () { return s.canceled = !0 } }; return u && (s.update = function (g, A, w, T) { g && (s.from = Ht(t, g)), A && (s.to = Ht(t, A)), w && (s.text = w), T !== void 0 && (s.origin = T) }), ie(t, "beforeChange", t, s), t.cm && ie(t.cm, "beforeChange", t.cm, s), s.canceled ? (t.cm && (t.cm.curOp.updateInput = 2), null) : { from: s.from, to: s.to, text: s.text, origin: s.origin } } function _r(t, e, u) { if (t.cm) { if (!t.cm.curOp) return Te(t.cm, _r)(t, e, u); if (t.cm.state.suppressEdits) return } if (!((we(t, "beforeChange") || t.cm && we(t.cm, "beforeChange")) && (e = Tl(t, e, !0), !e))) { var s = mo && !u && Ff(t, e.from, e.to); if (s) for (var g = s.length - 1; g >= 0; --g)El(t, { from: s[g].from, to: s[g].to, text: g ? [""] : e.text, origin: e.origin }); else El(t, e) } } function El(t, e) { if (!(e.text.length == 1 && e.text[0] == "" && At(e.from, e.to) == 0)) { var u = ps(t, e); pl(t, e, u, t.cm ? t.cm.curOp.id : NaN), rn(t, e, u, Va(t, e)); var s = []; Ui(t, function (g, A) { !A && ut(s, g.history) == -1 && (Ml(g.history, e), s.push(g.history)), rn(g, e, null, Va(g, e)) }) } } function ra(t, e, u) { var s = t.cm && t.cm.state.suppressEdits; if (!(s && !u)) { for (var g = t.history, A, w = t.sel, T = e == "undo" ? g.done : g.undone, B = e == "undo" ? g.undone : g.done, M = 0; M < T.length && (A = T[M], !(u ? A.ranges && !A.equals(t.sel) : !A.ranges)); M++); if (M != T.length) { for (g.lastOrigin = g.lastSelOrigin = null; ;)if (A = T.pop(), A.ranges) { if ($n(A, B), u && !A.equals(t.sel)) { De(t, A, { clearRedo: !1 }); return } w = A } else if (s) { T.push(A); return } else break; var Y = []; $n(w, B), B.push({ changes: Y, generation: g.generation }), g.generation = A.generation || ++g.maxGeneration; for (var j = we(t, "beforeChange") || t.cm && we(t.cm, "beforeChange"), ot = function (Tt) { var Bt = A.changes[Tt]; if (Bt.origin = e, j && !Tl(t, Bt, !1)) return T.length = 0, {}; Y.push(ys(t, Bt)); var Mt = Tt ? ps(t, Bt) : vt(T); rn(t, Bt, Mt, ml(t, Bt)), !Tt && t.cm && t.cm.scrollIntoView({ from: Bt.from, to: zi(Bt) }); var Pt = []; Ui(t, function (Ot, Rt) { !Rt && ut(Pt, Ot.history) == -1 && (Ml(Ot.history, Bt), Pt.push(Ot.history)), rn(Ot, Bt, null, ml(Ot, Bt)) }) }, nt = A.changes.length - 1; nt >= 0; --nt) { var Ct = ot(nt); if (Ct) return Ct.v } } } } function Il(t, e) { if (e != 0 && (t.first += e, t.sel = new Ke(kt(t.sel.ranges, function (g) { return new te(Z(g.anchor.line + e, g.anchor.ch), Z(g.head.line + e, g.head.ch)) }), t.sel.primIndex), t.cm)) { We(t.cm, t.first, t.first - e, e); for (var u = t.cm.display, s = u.viewFrom; s < u.viewTo; s++)Ni(t.cm, s, "gutter") } } function rn(t, e, u, s) { if (t.cm && !t.cm.curOp) return Te(t.cm, rn)(t, e, u, s); if (e.to.line < t.first) { Il(t, e.text.length - 1 - (e.to.line - e.from.line)); return } if (!(e.from.line > t.lastLine())) { if (e.from.line < t.first) { var g = e.text.length - 1 - (t.first - e.from.line); Il(t, g), e = { from: Z(t.first, 0), to: Z(e.to.line + g, e.to.ch), text: [vt(e.text)], origin: e.origin } } var A = t.lastLine(); e.to.line > A && (e = { from: e.from, to: Z(A, Wt(t, A).text.length), text: [e.text[0]], origin: e.origin }), e.removed = Si(t, e.from, e.to), u || (u = ps(t, e)), t.cm ? Wh(t.cm, e, s) : ms(t, e, s), ea(t, u, St), t.cantEdit && ia(t, Z(t.firstLine(), 0)) && (t.cantEdit = !1) } } function Wh(t, e, u) { var s = t.doc, g = t.display, A = e.from, w = e.to, T = !1, B = A.line; t.options.lineWrapping || (B = $t(ii(Wt(s, A.line))), s.iter(B, w.line + 1, function (nt) { if (nt == g.maxLine) return T = !0, !0 })), s.sel.contains(e.from, e.to) > -1 && qi(t), ms(s, e, u, jo(t)), t.options.lineWrapping || (s.iter(B, A.line + e.text.length, function (nt) { var Ct = Nn(nt); Ct > g.maxLineLength && (g.maxLine = nt, g.maxLineLength = Ct, g.maxLineChanged = !0, T = !1) }), T && (t.curOp.updateMaxLine = !0)), If(s, A.line), $r(t, 400); var M = e.text.length - (w.line - A.line) - 1; e.full ? We(t) : A.line == w.line && e.text.length == 1 && !hl(t.doc, e) ? Ni(t, A.line, "text") : We(t, A.line, w.line + 1, M); var Y = we(t, "changes"), j = we(t, "change"); if (j || Y) { var ot = { from: A, to: w, text: e.text, removed: e.removed, origin: e.origin }; j && Se(t, "change", t, ot), Y && (t.curOp.changeObjs || (t.curOp.changeObjs = [])).push(ot) } t.display.selForContextMenu = null } function Sr(t, e, u, s, g) { var A; s || (s = u), At(s, u) < 0 && (A = [s, u], u = A[0], s = A[1]), typeof e == "string" && (e = t.splitLines(e)), _r(t, { from: u, to: s, text: e, origin: g }) } function Bl(t, e, u, s) { u < t.line ? t.line += s : e < t.line && (t.line = e, t.ch = 0) } function kl(t, e, u, s) { for (var g = 0; g < t.length; ++g) { var A = t[g], w = !0; if (A.ranges) { A.copied || (A = t[g] = A.deepCopy(), A.copied = !0); for (var T = 0; T < A.ranges.length; T++)Bl(A.ranges[T].anchor, e, u, s), Bl(A.ranges[T].head, e, u, s); continue } for (var B = 0; B < A.changes.length; ++B) { var M = A.changes[B]; if (u < M.from.line) M.from = Z(M.from.line + s, M.from.ch), M.to = Z(M.to.line + s, M.to.ch); else if (e <= M.to.line) { w = !1; break } } w || (t.splice(0, g + 1), g = 0) } } function Ml(t, e) { var u = e.from.line, s = e.to.line, g = e.text.length - (s - u) - 1; kl(t.done, u, s, g), kl(t.undone, u, s, g) } function nn(t, e, u, s) { var g = e, A = e; return typeof e == "number" ? A = Wt(t, Xe(t, e)) : g = $t(e), g == null ? null : (s(A, g) && t.cm && Ni(t.cm, g, u), A) } function an(t) { this.lines = t, this.parent = null; for (var e = 0, u = 0; u < t.length; ++u)t[u].parent = this, e += t[u].height; this.height = e } an.prototype = { chunkSize: function () { return this.lines.length }, removeInner: function (t, e) { for (var u = t, s = t + e; u < s; ++u) { var g = this.lines[u]; this.height -= g.height, Nf(g), Se(g, "delete") } this.lines.splice(t, e) }, collapse: function (t) { t.push.apply(t, this.lines) }, insertInner: function (t, e, u) { this.height += u, this.lines = this.lines.slice(0, t).concat(e).concat(this.lines.slice(t)); for (var s = 0; s < e.length; ++s)e[s].parent = this }, iterN: function (t, e, u) { for (var s = t + e; t < s; ++t)if (u(this.lines[t])) return !0 } }; function sn(t) { this.children = t; for (var e = 0, u = 0, s = 0; s < t.length; ++s) { var g = t[s]; e += g.chunkSize(), u += g.height, g.parent = this } this.size = e, this.height = u, this.parent = null } sn.prototype = { chunkSize: function () { return this.size }, removeInner: function (t, e) { this.size -= e; for (var u = 0; u < this.children.length; ++u) { var s = this.children[u], g = s.chunkSize(); if (t < g) { var A = Math.min(e, g - t), w = s.height; if (s.removeInner(t, A), this.height -= w - s.height, g == A && (this.children.splice(u--, 1), s.parent = null), (e -= A) == 0) break; t = 0 } else t -= g } if (this.size - e < 25 && (this.children.length > 1 || !(this.children[0] instanceof an))) { var T = []; this.collapse(T), this.children = [new an(T)], this.children[0].parent = this } }, collapse: function (t) { for (var e = 0; e < this.children.length; ++e)this.children[e].collapse(t) }, insertInner: function (t, e, u) { this.size += e.length, this.height += u; for (var s = 0; s < this.children.length; ++s) { var g = this.children[s], A = g.chunkSize(); if (t <= A) { if (g.insertInner(t, e, u), g.lines && g.lines.length > 50) { for (var w = g.lines.length % 25 + 25, T = w; T < g.lines.length;) { var B = new an(g.lines.slice(T, T += 25)); g.height -= B.height, this.children.splice(++s, 0, B), B.parent = this } g.lines = g.lines.slice(0, w), this.maybeSpill() } break } t -= A } }, maybeSpill: function () { if (!(this.children.length <= 10)) { var t = this; do { var e = t.children.splice(t.children.length - 5, 5), u = new sn(e); if (t.parent) { t.size -= u.size, t.height -= u.height; var g = ut(t.parent.children, t); t.parent.children.splice(g + 1, 0, u) } else { var s = new sn(t.children); s.parent = t, t.children = [s, u], t = s } u.parent = t.parent } while (t.children.length > 10); t.parent.maybeSpill() } }, iterN: function (t, e, u) { for (var s = 0; s < this.children.length; ++s) { var g = this.children[s], A = g.chunkSize(); if (t < A) { var w = Math.min(e, A - t); if (g.iterN(t, w, u)) return !0; if ((e -= w) == 0) break; t = 0 } else t -= A } } }; var on = function (t, e, u) { if (u) for (var s in u) u.hasOwnProperty(s) && (this[s] = u[s]); this.doc = t, this.node = e }; on.prototype.clear = function () { var t = this.doc.cm, e = this.line.widgets, u = this.line, s = $t(u); if (!(s == null || !e)) { for (var g = 0; g < e.length; ++g)e[g] == this && e.splice(g--, 1); e.length || (u.widgets = null); var A = Gr(this); $e(u, Math.max(0, u.height - A)), t && (He(t, function () { Ol(t, u, -A), Ni(t, s, "widget") }), Se(t, "lineWidgetCleared", t, this, s)) } }, on.prototype.changed = function () { var t = this, e = this.height, u = this.doc.cm, s = this.line; this.height = null; var g = Gr(this) - e; g && (Wi(this.doc, s) || $e(s, s.height + g), u && He(u, function () { u.curOp.forceUpdate = !0, Ol(u, s, g), Se(u, "lineWidgetChanged", u, t, $t(s)) })) }, ve(on); function Ol(t, e, u) { Ei(e) < (t.curOp && t.curOp.scrollTop || t.doc.scrollTop) && us(t, u) } function Nh(t, e, u, s) { var g = new on(t, u, s), A = t.cm; return A && g.noHScroll && (A.display.alignWidgets = !0), nn(t, e, "widget", function (w) { var T = w.widgets || (w.widgets = []); if (g.insertAt == null ? T.push(g) : T.splice(Math.min(T.length, Math.max(0, g.insertAt)), 0, g), g.line = w, A && !Wi(t, w)) { var B = Ei(w) < t.scrollTop; $e(w, w.height + Gr(g)), B && us(A, g.height), A.curOp.forceUpdate = !0 } return !0 }), A && Se(A, "lineWidgetAdded", A, g, typeof e == "number" ? e : $t(e)), g } var Dl = 0, Hi = function (t, e) { this.lines = [], this.type = e, this.doc = t, this.id = ++Dl }; Hi.prototype.clear = function () { if (!this.explicitlyCleared) { var t = this.doc.cm, e = t && !t.curOp; if (e && rr(t), we(this, "clear")) { var u = this.find(); u && Se(this, "clear", u.from, u.to) } for (var s = null, g = null, A = 0; A < this.lines.length; ++A) { var w = this.lines[A], T = zr(w.markedSpans, this); t && !this.collapsed ? Ni(t, $t(w), "text") : t && (T.to != null && (g = $t(w)), T.from != null && (s = $t(w))), w.markedSpans = Mf(w.markedSpans, T), T.from == null && this.collapsed && !Wi(this.doc, w) && t && $e(w, mr(t.display)) } if (t && this.collapsed && !t.options.lineWrapping) for (var B = 0; B < this.lines.length; ++B) { var M = ii(this.lines[B]), Y = Nn(M); Y > t.display.maxLineLength && (t.display.maxLine = M, t.display.maxLineLength = Y, t.display.maxLineChanged = !0) } s != null && t && this.collapsed && We(t, s, g + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, t && wl(t.doc)), t && Se(t, "markerCleared", t, this, s, g), e && nr(t), this.parent && this.parent.clear() } }, Hi.prototype.find = function (t, e) { t == null && this.type == "bookmark" && (t = 1); for (var u, s, g = 0; g < this.lines.length; ++g) { var A = this.lines[g], w = zr(A.markedSpans, this); if (w.from != null && (u = Z(e ? A : $t(A), w.from), t == -1)) return u; if (w.to != null && (s = Z(e ? A : $t(A), w.to), t == 1)) return s } return u && { from: u, to: s } }, Hi.prototype.changed = function () { var t = this, e = this.find(-1, !0), u = this, s = this.doc.cm; !e || !s || He(s, function () { var g = e.line, A = $t(e.line), w = qa(s, A); if (w && (Wo(w), s.curOp.selectionChanged = s.curOp.forceUpdate = !0), s.curOp.updateMaxLine = !0, !Wi(u.doc, g) && u.height != null) { var T = u.height; u.height = null; var B = Gr(u) - T; B && $e(g, g.height + B) } Se(s, "markerChanged", s, t) }) }, Hi.prototype.attachLine = function (t) { if (!this.lines.length && this.doc.cm) { var e = this.doc.cm.curOp; (!e.maybeHiddenMarkers || ut(e.maybeHiddenMarkers, this) == -1) && (e.maybeUnhiddenMarkers || (e.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(t) }, Hi.prototype.detachLine = function (t) { if (this.lines.splice(ut(this.lines, t), 1), !this.lines.length && this.doc.cm) { var e = this.doc.cm.curOp; (e.maybeHiddenMarkers || (e.maybeHiddenMarkers = [])).push(this) } }, ve(Hi); function Tr(t, e, u, s, g) { if (s && s.shared) return Yh(t, e, u, s, g); if (t.cm && !t.cm.curOp) return Te(t.cm, Tr)(t, e, u, s, g); var A = new Hi(t, g), w = At(e, u); if (s && K(s, A, !1), w > 0 || w == 0 && A.clearWhenEmpty !== !1) return A; if (A.replacedWith && (A.collapsed = !0, A.widgetNode = Dt("span", [A.replacedWith], "CodeMirror-widget"), s.handleMouseEvents || A.widgetNode.setAttribute("cm-ignore-events", "true"), s.insertLeft && (A.widgetNode.insertLeft = !0)), A.collapsed) { if (xo(t, e.line, e, u, A) || e.line != u.line && xo(t, u.line, e, u, A)) throw new Error("Inserting collapsed marker partially overlapping an existing one"); kf() } A.addToHistory && pl(t, { from: e, to: u, origin: "markText" }, t.sel, NaN); var T = e.line, B = t.cm, M; if (t.iter(T, u.line + 1, function (j) { B && A.collapsed && !B.options.lineWrapping && ii(j) == B.display.maxLine && (M = !0), A.collapsed && T != e.line && $e(j, 0), Of(j, new Pn(A, T == e.line ? e.ch : null, T == u.line ? u.ch : null), t.cm && t.cm.curOp), ++T }), A.collapsed && t.iter(e.line, u.line + 1, function (j) { Wi(t, j) && $e(j, 0) }), A.clearOnEnter && It(A, "beforeCursorEnter", function () { return A.clear() }), A.readOnly && (Bf(), (t.history.done.length || t.history.undone.length) && t.clearHistory()), A.collapsed && (A.id = ++Dl, A.atomic = !0), B) { if (M && (B.curOp.updateMaxLine = !0), A.collapsed) We(B, e.line, u.line + 1); else if (A.className || A.startStyle || A.endStyle || A.css || A.attributes || A.title) for (var Y = e.line; Y <= u.line; Y++)Ni(B, Y, "text"); A.atomic && wl(B.doc), Se(B, "markerAdded", B, A) } return A } var ln = function (t, e) { this.markers = t, this.primary = e; for (var u = 0; u < t.length; ++u)t[u].parent = this }; ln.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (var t = 0; t < this.markers.length; ++t)this.markers[t].clear(); Se(this, "clear") } }, ln.prototype.find = function (t, e) { return this.primary.find(t, e) }, ve(ln); function Yh(t, e, u, s, g) { s = K(s), s.shared = !1; var A = [Tr(t, e, u, s, g)], w = A[0], T = s.widgetNode; return Ui(t, function (B) { T && (s.widgetNode = T.cloneNode(!0)), A.push(Tr(B, Ht(B, e), Ht(B, u), s, g)); for (var M = 0; M < B.linked.length; ++M)if (B.linked[M].isParent) return; w = vt(A) }), new ln(A, w) } function Ll(t) { return t.findMarks(Z(t.first, 0), t.clipPos(Z(t.lastLine())), function (e) { return e.parent }) } function Vh(t, e) { for (var u = 0; u < e.length; u++) { var s = e[u], g = s.find(), A = t.clipPos(g.from), w = t.clipPos(g.to); if (At(A, w)) { var T = Tr(t, A, w, s.primary, s.primary.type); s.markers.push(T), T.parent = s } } } function zh(t) { for (var e = function (s) { var g = t[s], A = [g.primary.doc]; Ui(g.primary.doc, function (B) { return A.push(B) }); for (var w = 0; w < g.markers.length; w++) { var T = g.markers[w]; ut(A, T.doc) == -1 && (T.parent = null, g.markers.splice(w--, 1)) } }, u = 0; u < t.length; u++)e(u) } var Uh = 0, Ne = function (t, e, u, s, g) { if (!(this instanceof Ne)) return new Ne(t, e, u, s, g); u == null && (u = 0), sn.call(this, [new an([new gr("", null)])]), this.first = u, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = u; var A = Z(u, 0); this.sel = Vi(A), this.history = new Zn(null), this.id = ++Uh, this.modeOption = e, this.lineSep = s, this.direction = g == "rtl" ? "rtl" : "ltr", this.extend = !1, typeof t == "string" && (t = this.splitLines(t)), ms(this, { from: A, to: A, text: t }), De(this, Vi(A), St) }; Ne.prototype = Q(sn.prototype, {
        constructor: Ne, iter: function (t, e, u) { u ? this.iterN(t - this.first, e - t, u) : this.iterN(this.first, this.first + this.size, t) }, insert: function (t, e) { for (var u = 0, s = 0; s < e.length; ++s)u += e[s].height; this.insertInner(t - this.first, e, u) }, remove: function (t, e) { this.removeInner(t - this.first, e) }, getValue: function (t) { var e = dr(this, this.first, this.first + this.size); return t === !1 ? e : e.join(t || this.lineSeparator()) }, setValue: Ee(function (t) { var e = Z(this.first, 0), u = this.first + this.size - 1; _r(this, { from: e, to: Z(u, Wt(this, u).text.length), text: this.splitLines(t), origin: "setValue", full: !0 }, !0), this.cm && Kr(this.cm, 0, 0), De(this, Vi(e), St) }), replaceRange: function (t, e, u, s) { e = Ht(this, e), u = u ? Ht(this, u) : e, Sr(this, t, e, u, s) }, getRange: function (t, e, u) { var s = Si(this, Ht(this, t), Ht(this, e)); return u === !1 ? s : u === "" ? s.join("") : s.join(u || this.lineSeparator()) }, getLine: function (t) { var e = this.getLineHandle(t); return e && e.text }, getLineHandle: function (t) { if (F(this, t)) return Wt(this, t) }, getLineNumber: function (t) { return $t(t) }, getLineHandleVisualStart: function (t) { return typeof t == "number" && (t = Wt(this, t)), ii(t) }, lineCount: function () { return this.size }, firstLine: function () { return this.first }, lastLine: function () { return this.first + this.size - 1 }, clipPos: function (t) { return Ht(this, t) }, getCursor: function (t) { var e = this.sel.primary(), u; return t == null || t == "head" ? u = e.head : t == "anchor" ? u = e.anchor : t == "end" || t == "to" || t === !1 ? u = e.to() : u = e.from(), u }, listSelections: function () { return this.sel.ranges }, somethingSelected: function () { return this.sel.somethingSelected() }, setCursor: Ee(function (t, e, u) { Al(this, Ht(this, typeof t == "number" ? Z(t, e || 0) : t), null, u) }), setSelection: Ee(function (t, e, u) { Al(this, Ht(this, t), Ht(this, e || t), u) }), extendSelection: Ee(function (t, e, u) { ta(this, Ht(this, t), e && Ht(this, e), u) }), extendSelections: Ee(function (t, e) { yl(this, lo(this, t), e) }), extendSelectionsBy: Ee(function (t, e) { var u = kt(this.sel.ranges, t); yl(this, lo(this, u), e) }), setSelections: Ee(function (t, e, u) { if (t.length) { for (var s = [], g = 0; g < t.length; g++)s[g] = new te(Ht(this, t[g].anchor), Ht(this, t[g].head || t[g].anchor)); e == null && (e = Math.min(t.length - 1, this.sel.primIndex)), De(this, ni(this.cm, s, e), u) } }), addSelection: Ee(function (t, e, u) { var s = this.sel.ranges.slice(0); s.push(new te(Ht(this, t), Ht(this, e || t))), De(this, ni(this.cm, s, s.length - 1), u) }), getSelection: function (t) { for (var e = this.sel.ranges, u, s = 0; s < e.length; s++) { var g = Si(this, e[s].from(), e[s].to()); u = u ? u.concat(g) : g } return t === !1 ? u : u.join(t || this.lineSeparator()) }, getSelections: function (t) { for (var e = [], u = this.sel.ranges, s = 0; s < u.length; s++) { var g = Si(this, u[s].from(), u[s].to()); t !== !1 && (g = g.join(t || this.lineSeparator())), e[s] = g } return e }, replaceSelection: function (t, e, u) { for (var s = [], g = 0; g < this.sel.ranges.length; g++)s[g] = t; this.replaceSelections(s, e, u || "+input") }, replaceSelections: Ee(function (t, e, u) { for (var s = [], g = this.sel, A = 0; A < g.ranges.length; A++) { var w = g.ranges[A]; s[A] = { from: w.from(), to: w.to(), text: this.splitLines(t[A]), origin: u } } for (var T = e && e != "end" && Mh(this, s, e), B = s.length - 1; B >= 0; B--)_r(this, s[B]); T ? Cl(this, T) : this.cm && Cr(this.cm) }), undo: Ee(function () { ra(this, "undo") }), redo: Ee(function () { ra(this, "redo") }), undoSelection: Ee(function () { ra(this, "undo", !0) }), redoSelection: Ee(function () { ra(this, "redo", !0) }), setExtending: function (t) { this.extend = t }, getExtending: function () { return this.extend }, historySize: function () { for (var t = this.history, e = 0, u = 0, s = 0; s < t.done.length; s++)t.done[s].ranges || ++e; for (var g = 0; g < t.undone.length; g++)t.undone[g].ranges || ++u; return { undo: e, redo: u } }, clearHistory: function () { var t = this; this.history = new Zn(this.history), Ui(this, function (e) { return e.history = t.history }, !0) }, markClean: function () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration: function (t) { return t && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean: function (t) { return this.history.generation == (t || this.cleanGeneration) }, getHistory: function () { return { done: wr(this.history.done), undone: wr(this.history.undone) } }, setHistory: function (t) { var e = this.history = new Zn(this.history); e.done = wr(t.done.slice(0), null, !0), e.undone = wr(t.undone.slice(0), null, !0) }, setGutterMarker: Ee(function (t, e, u) { return nn(this, t, "gutter", function (s) { var g = s.gutterMarkers || (s.gutterMarkers = {}); return g[e] = u, !u && yt(g) && (s.gutterMarkers = null), !0 }) }), clearGutter: Ee(function (t) { var e = this; this.iter(function (u) { u.gutterMarkers && u.gutterMarkers[t] && nn(e, u, "gutter", function () { return u.gutterMarkers[t] = null, yt(u.gutterMarkers) && (u.gutterMarkers = null), !0 }) }) }), lineInfo: function (t) { var e; if (typeof t == "number") { if (!F(this, t) || (e = t, t = Wt(this, t), !t)) return null } else if (e = $t(t), e == null) return null; return { line: e, handle: t, text: t.text, gutterMarkers: t.gutterMarkers, textClass: t.textClass, bgClass: t.bgClass, wrapClass: t.wrapClass, widgets: t.widgets } }, addLineClass: Ee(function (t, e, u) { return nn(this, t, e == "gutter" ? "gutter" : "class", function (s) { var g = e == "text" ? "textClass" : e == "background" ? "bgClass" : e == "gutter" ? "gutterClass" : "wrapClass"; if (!s[g]) s[g] = u; else { if (st(u).test(s[g])) return !1; s[g] += " " + u } return !0 }) }), removeLineClass: Ee(function (t, e, u) { return nn(this, t, e == "gutter" ? "gutter" : "class", function (s) { var g = e == "text" ? "textClass" : e == "background" ? "bgClass" : e == "gutter" ? "gutterClass" : "wrapClass", A = s[g]; if (A) if (u == null) s[g] = null; else { var w = A.match(st(u)); if (!w) return !1; var T = w.index + w[0].length; s[g] = A.slice(0, w.index) + (!w.index || T == A.length ? "" : " ") + A.slice(T) || null } else return !1; return !0 }) }), addLineWidget: Ee(function (t, e, u) { return Nh(this, t, e, u) }), removeLineWidget: function (t) { t.clear() }, markText: function (t, e, u) { return Tr(this, Ht(this, t), Ht(this, e), u, u && u.type || "range") }, setBookmark: function (t, e) { var u = { replacedWith: e && (e.nodeType == null ? e.widget : e), insertLeft: e && e.insertLeft, clearWhenEmpty: !1, shared: e && e.shared, handleMouseEvents: e && e.handleMouseEvents }; return t = Ht(this, t), Tr(this, t, t, u, "bookmark") }, findMarksAt: function (t) { t = Ht(this, t); var e = [], u = Wt(this, t.line).markedSpans; if (u) for (var s = 0; s < u.length; ++s) { var g = u[s]; (g.from == null || g.from <= t.ch) && (g.to == null || g.to >= t.ch) && e.push(g.marker.parent || g.marker) } return e }, findMarks: function (t, e, u) { t = Ht(this, t), e = Ht(this, e); var s = [], g = t.line; return this.iter(t.line, e.line + 1, function (A) { var w = A.markedSpans; if (w) for (var T = 0; T < w.length; T++) { var B = w[T]; !(B.to != null && g == t.line && t.ch >= B.to || B.from == null && g != t.line || B.from != null && g == e.line && B.from >= e.ch) && (!u || u(B.marker)) && s.push(B.marker.parent || B.marker) } ++g }), s }, getAllMarks: function () { var t = []; return this.iter(function (e) { var u = e.markedSpans; if (u) for (var s = 0; s < u.length; ++s)u[s].from != null && t.push(u[s].marker) }), t }, posFromIndex: function (t) { var e, u = this.first, s = this.lineSeparator().length; return this.iter(function (g) { var A = g.text.length + s; if (A > t) return e = t, !0; t -= A, ++u }), Ht(this, Z(u, e)) }, indexFromPos: function (t) { t = Ht(this, t); var e = t.ch; if (t.line < this.first || t.ch < 0) return 0; var u = this.lineSeparator().length; return this.iter(this.first, t.line, function (s) { e += s.text.length + u }), e }, copy: function (t) { var e = new Ne(dr(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return e.scrollTop = this.scrollTop, e.scrollLeft = this.scrollLeft, e.sel = this.sel, e.extend = !1, t && (e.history.undoDepth = this.history.undoDepth, e.setHistory(this.getHistory())), e }, linkedDoc: function (t) { t || (t = {}); var e = this.first, u = this.first + this.size; t.from != null && t.from > e && (e = t.from), t.to != null && t.to < u && (u = t.to); var s = new Ne(dr(this, e, u), t.mode || this.modeOption, e, this.lineSep, this.direction); return t.sharedHist && (s.history = this.history), (this.linked || (this.linked = [])).push({ doc: s, sharedHist: t.sharedHist }), s.linked = [{ doc: this, isParent: !0, sharedHist: t.sharedHist }], Vh(s, Ll(this)), s }, unlinkDoc: function (t) { if (t instanceof ue && (t = t.doc), this.linked) for (var e = 0; e < this.linked.length; ++e) { var u = this.linked[e]; if (u.doc == t) { this.linked.splice(e, 1), t.unlinkDoc(this), zh(Ll(this)); break } } if (t.history == this.history) { var s = [t.id]; Ui(t, function (g) { return s.push(g.id) }, !0), t.history = new Zn(null), t.history.done = wr(this.history.done, s), t.history.undone = wr(this.history.undone, s) } }, iterLinkedDocs: function (t) { Ui(this, t) }, getMode: function () { return this.mode }, getEditor: function () { return this.cm }, splitLines: function (t) { return this.lineSep ? t.split(this.lineSep) : Nr(t) }, lineSeparator: function () {
          return this.lineSep || `
`}, setDirection: Ee(function (t) { t != "rtl" && (t = "ltr"), t != this.direction && (this.direction = t, this.iter(function (e) { return e.order = null }), this.cm && Oh(this.cm)) })
      }), Ne.prototype.eachLine = Ne.prototype.iter; var Fl = 0; function Hh(t) { var e = this; if (Pl(e), !(oe(e, t) || Ii(e.display, t))) { de(t), a && (Fl = +new Date); var u = $i(e, t, !0), s = t.dataTransfer.files; if (!(!u || e.isReadOnly())) if (s && s.length && window.FileReader && window.File) for (var g = s.length, A = Array(g), w = 0, T = function () { ++w == g && Te(e, function () { u = Ht(e.doc, u); var nt = { from: u, to: u, text: e.doc.splitLines(A.filter(function (Ct) { return Ct != null }).join(e.doc.lineSeparator())), origin: "paste" }; _r(e.doc, nt), Cl(e.doc, Vi(Ht(e.doc, u), Ht(e.doc, zi(nt)))) })() }, B = function (nt, Ct) { if (e.options.allowDropFileTypes && ut(e.options.allowDropFileTypes, nt.type) == -1) { T(); return } var Tt = new FileReader; Tt.onerror = function () { return T() }, Tt.onload = function () { var Bt = Tt.result; if (/[\x00-\x08\x0e-\x1f]{2}/.test(Bt)) { T(); return } A[Ct] = Bt, T() }, Tt.readAsText(nt) }, M = 0; M < s.length; M++)B(s[M], M); else { if (e.state.draggingText && e.doc.sel.contains(u) > -1) { e.state.draggingText(t), setTimeout(function () { return e.display.input.focus() }, 20); return } try { var Y = t.dataTransfer.getData("Text"); if (Y) { var j; if (e.state.draggingText && !e.state.draggingText.copy && (j = e.listSelections()), ea(e.doc, Vi(u, u)), j) for (var ot = 0; ot < j.length; ++ot)Sr(e.doc, "", j[ot].anchor, j[ot].head, "drag"); e.replaceSelection(Y, "around", "paste"), e.display.input.focus() } } catch { } } } } function Gh(t, e) { if (a && (!t.state.draggingText || +new Date - Fl < 100)) { wi(e); return } if (!(oe(t, e) || Ii(t.display, e)) && (e.dataTransfer.setData("Text", t.getSelection()), e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !p)) { var u = W("img", null, null, "position: fixed; left: 0; top: 0;"); u.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", o && (u.width = u.height = 1, t.display.wrapper.appendChild(u), u._top = u.offsetTop), e.dataTransfer.setDragImage(u, 0, 0), o && u.parentNode.removeChild(u) } } function jh(t, e) { var u = $i(t, e); if (u) { var s = document.createDocumentFragment(); ns(t, u, s), t.display.dragCursor || (t.display.dragCursor = W("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), t.display.lineSpace.insertBefore(t.display.dragCursor, t.display.cursorDiv)), ct(t.display.dragCursor, s) } } function Pl(t) { t.display.dragCursor && (t.display.lineSpace.removeChild(t.display.dragCursor), t.display.dragCursor = null) } function Rl(t) { if (document.getElementsByClassName) { for (var e = document.getElementsByClassName("CodeMirror"), u = [], s = 0; s < e.length; s++) { var g = e[s].CodeMirror; g && u.push(g) } u.length && u[0].operation(function () { for (var A = 0; A < u.length; A++)t(u[A]) }) } } var Ql = !1; function Xh() { Ql || (Kh(), Ql = !0) } function Kh() { var t; It(window, "resize", function () { t == null && (t = setTimeout(function () { t = null, Rl(qh) }, 100)) }), It(window, "blur", function () { return Rl(Ar) }) } function qh(t) { var e = t.display; e.cachedCharWidth = e.cachedTextHeight = e.cachedPaddingH = null, e.scrollbarsClipped = !1, t.setSize() } for (var Gi = { 3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert" }, un = 0; un < 10; un++)Gi[un + 48] = Gi[un + 96] = String(un); for (var na = 65; na <= 90; na++)Gi[na] = String.fromCharCode(na); for (var fn = 1; fn <= 12; fn++)Gi[fn + 111] = Gi[fn + 63235] = "F" + fn; var ki = {}; ki.basic = { Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection" }, ki.pcDefault = { "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic" }, ki.emacsy = { "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars", "Ctrl-O": "openLine" }, ki.macDefault = { "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd", fallthrough: ["basic", "emacsy"] }, ki.default = I ? ki.macDefault : ki.pcDefault; function Jh(t) { var e = t.split(/-(?!$)/); t = e[e.length - 1]; for (var u, s, g, A, w = 0; w < e.length - 1; w++) { var T = e[w]; if (/^(cmd|meta|m)$/i.test(T)) A = !0; else if (/^a(lt)?$/i.test(T)) u = !0; else if (/^(c|ctrl|control)$/i.test(T)) s = !0; else if (/^s(hift)?$/i.test(T)) g = !0; else throw new Error("Unrecognized modifier name: " + T) } return u && (t = "Alt-" + t), s && (t = "Ctrl-" + t), A && (t = "Cmd-" + t), g && (t = "Shift-" + t), t } function Zh(t) { var e = {}; for (var u in t) if (t.hasOwnProperty(u)) { var s = t[u]; if (/^(name|fallthrough|(de|at)tach)$/.test(u)) continue; if (s == "...") { delete t[u]; continue } for (var g = kt(u.split(" "), Jh), A = 0; A < g.length; A++) { var w = void 0, T = void 0; A == g.length - 1 ? (T = g.join(" "), w = s) : (T = g.slice(0, A + 1).join(" "), w = "..."); var B = e[T]; if (!B) e[T] = w; else if (B != w) throw new Error("Inconsistent bindings for " + T) } delete t[u] } for (var M in e) t[M] = e[M]; return t } function Er(t, e, u, s) { e = aa(e); var g = e.call ? e.call(t, s) : e[t]; if (g === !1) return "nothing"; if (g === "...") return "multi"; if (g != null && u(g)) return "handled"; if (e.fallthrough) { if (Object.prototype.toString.call(e.fallthrough) != "[object Array]") return Er(t, e.fallthrough, u, s); for (var A = 0; A < e.fallthrough.length; A++) { var w = Er(t, e.fallthrough[A], u, s); if (w) return w } } } function Wl(t) { var e = typeof t == "string" ? t : Gi[t.keyCode]; return e == "Ctrl" || e == "Alt" || e == "Shift" || e == "Mod" } function Nl(t, e, u) { var s = t; return e.altKey && s != "Alt" && (t = "Alt-" + t), (et ? e.metaKey : e.ctrlKey) && s != "Ctrl" && (t = "Ctrl-" + t), (et ? e.ctrlKey : e.metaKey) && s != "Mod" && (t = "Cmd-" + t), !u && e.shiftKey && s != "Shift" && (t = "Shift-" + t), t } function Yl(t, e) { if (o && t.keyCode == 34 && t.char) return !1; var u = Gi[t.keyCode]; return u == null || t.altGraphKey ? !1 : (t.keyCode == 3 && t.code && (u = t.code), Nl(u, t, e)) } function aa(t) { return typeof t == "string" ? ki[t] : t } function Ir(t, e) { for (var u = t.doc.sel.ranges, s = [], g = 0; g < u.length; g++) { for (var A = e(u[g]); s.length && At(A.from, vt(s).to) <= 0;) { var w = s.pop(); if (At(w.from, A.from) < 0) { A.from = w.from; break } } s.push(A) } He(t, function () { for (var T = s.length - 1; T >= 0; T--)Sr(t.doc, "", s[T].from, s[T].to, "+delete"); Cr(t) }) } function bs(t, e, u) { var s = Ft(t.text, e + u, u); return s < 0 || s > t.text.length ? null : s } function ws(t, e, u) { var s = bs(t, e.ch, u); return s == null ? null : new Z(e.line, s, u < 0 ? "after" : "before") } function xs(t, e, u, s, g) { if (t) { e.doc.direction == "rtl" && (g = -g); var A = ee(u, e.doc.direction); if (A) { var w = g < 0 ? vt(A) : A[0], T = g < 0 == (w.level == 1), B = T ? "after" : "before", M; if (w.level > 0 || e.doc.direction == "rtl") { var Y = vr(e, u); M = g < 0 ? u.text.length - 1 : 0; var j = vi(e, Y, M).top; M = Qt(function (ot) { return vi(e, Y, ot).top == j }, g < 0 == (w.level == 1) ? w.from : w.to - 1, M), B == "before" && (M = bs(u, M, 1)) } else M = g < 0 ? w.to : w.from; return new Z(s, M, B) } } return new Z(s, g < 0 ? u.text.length : 0, g < 0 ? "before" : "after") } function $h(t, e, u, s) { var g = ee(e, t.doc.direction); if (!g) return ws(e, u, s); u.ch >= e.text.length ? (u.ch = e.text.length, u.sticky = "before") : u.ch <= 0 && (u.ch = 0, u.sticky = "after"); var A = Kt(g, u.ch, u.sticky), w = g[A]; if (t.doc.direction == "ltr" && w.level % 2 == 0 && (s > 0 ? w.to > u.ch : w.from < u.ch)) return ws(e, u, s); var T = function (Mt, Pt) { return bs(e, Mt instanceof Z ? Mt.ch : Mt, Pt) }, B, M = function (Mt) { return t.options.lineWrapping ? (B = B || vr(t, e), Go(t, e, B, Mt)) : { begin: 0, end: e.text.length } }, Y = M(u.sticky == "before" ? T(u, -1) : u.ch); if (t.doc.direction == "rtl" || w.level == 1) { var j = w.level == 1 == s < 0, ot = T(u, j ? 1 : -1); if (ot != null && (j ? ot <= w.to && ot <= Y.end : ot >= w.from && ot >= Y.begin)) { var nt = j ? "before" : "after"; return new Z(u.line, ot, nt) } } var Ct = function (Mt, Pt, Ot) { for (var Rt = function (se, Ie) { return Ie ? new Z(u.line, T(se, 1), "before") : new Z(u.line, se, "after") }; Mt >= 0 && Mt < g.length; Mt += Pt) { var Yt = g[Mt], Nt = Pt > 0 == (Yt.level != 1), Xt = Nt ? Ot.begin : T(Ot.end, -1); if (Yt.from <= Xt && Xt < Yt.to || (Xt = Nt ? Yt.from : T(Yt.to, -1), Ot.begin <= Xt && Xt < Ot.end)) return Rt(Xt, Nt) } }, Tt = Ct(A + s, s, Y); if (Tt) return Tt; var Bt = s > 0 ? Y.end : T(Y.begin, -1); return Bt != null && !(s > 0 && Bt == e.text.length) && (Tt = Ct(s > 0 ? 0 : g.length - 1, s, M(Bt)), Tt) ? Tt : null } var hn = {
        selectAll: Sl, singleSelection: function (t) { return t.setSelection(t.getCursor("anchor"), t.getCursor("head"), St) }, killLine: function (t) { return Ir(t, function (e) { if (e.empty()) { var u = Wt(t.doc, e.head.line).text.length; return e.head.ch == u && e.head.line < t.lastLine() ? { from: e.head, to: Z(e.head.line + 1, 0) } : { from: e.head, to: Z(e.head.line, u) } } else return { from: e.from(), to: e.to() } }) }, deleteLine: function (t) { return Ir(t, function (e) { return { from: Z(e.from().line, 0), to: Ht(t.doc, Z(e.to().line + 1, 0)) } }) }, delLineLeft: function (t) { return Ir(t, function (e) { return { from: Z(e.from().line, 0), to: e.from() } }) }, delWrappedLineLeft: function (t) { return Ir(t, function (e) { var u = t.charCoords(e.head, "div").top + 5, s = t.coordsChar({ left: 0, top: u }, "div"); return { from: s, to: e.from() } }) }, delWrappedLineRight: function (t) { return Ir(t, function (e) { var u = t.charCoords(e.head, "div").top + 5, s = t.coordsChar({ left: t.display.lineDiv.offsetWidth + 100, top: u }, "div"); return { from: e.from(), to: s } }) }, undo: function (t) { return t.undo() }, redo: function (t) { return t.redo() }, undoSelection: function (t) { return t.undoSelection() }, redoSelection: function (t) { return t.redoSelection() }, goDocStart: function (t) { return t.extendSelection(Z(t.firstLine(), 0)) }, goDocEnd: function (t) { return t.extendSelection(Z(t.lastLine())) }, goLineStart: function (t) { return t.extendSelectionsBy(function (e) { return Vl(t, e.head.line) }, { origin: "+move", bias: 1 }) }, goLineStartSmart: function (t) { return t.extendSelectionsBy(function (e) { return zl(t, e.head) }, { origin: "+move", bias: 1 }) }, goLineEnd: function (t) { return t.extendSelectionsBy(function (e) { return tc(t, e.head.line) }, { origin: "+move", bias: -1 }) }, goLineRight: function (t) { return t.extendSelectionsBy(function (e) { var u = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: t.display.lineDiv.offsetWidth + 100, top: u }, "div") }, ft) }, goLineLeft: function (t) { return t.extendSelectionsBy(function (e) { var u = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: 0, top: u }, "div") }, ft) }, goLineLeftSmart: function (t) { return t.extendSelectionsBy(function (e) { var u = t.cursorCoords(e.head, "div").top + 5, s = t.coordsChar({ left: 0, top: u }, "div"); return s.ch < t.getLine(s.line).search(/\S/) ? zl(t, e.head) : s }, ft) }, goLineUp: function (t) { return t.moveV(-1, "line") }, goLineDown: function (t) { return t.moveV(1, "line") }, goPageUp: function (t) { return t.moveV(-1, "page") }, goPageDown: function (t) { return t.moveV(1, "page") }, goCharLeft: function (t) { return t.moveH(-1, "char") }, goCharRight: function (t) { return t.moveH(1, "char") }, goColumnLeft: function (t) { return t.moveH(-1, "column") }, goColumnRight: function (t) { return t.moveH(1, "column") }, goWordLeft: function (t) { return t.moveH(-1, "word") }, goGroupRight: function (t) { return t.moveH(1, "group") }, goGroupLeft: function (t) { return t.moveH(-1, "group") }, goWordRight: function (t) { return t.moveH(1, "word") }, delCharBefore: function (t) { return t.deleteH(-1, "codepoint") }, delCharAfter: function (t) { return t.deleteH(1, "char") }, delWordBefore: function (t) { return t.deleteH(-1, "word") }, delWordAfter: function (t) { return t.deleteH(1, "word") }, delGroupBefore: function (t) { return t.deleteH(-1, "group") }, delGroupAfter: function (t) { return t.deleteH(1, "group") }, indentAuto: function (t) { return t.indentSelection("smart") }, indentMore: function (t) { return t.indentSelection("add") }, indentLess: function (t) { return t.indentSelection("subtract") }, insertTab: function (t) { return t.replaceSelection("	") }, insertSoftTab: function (t) { for (var e = [], u = t.listSelections(), s = t.options.tabSize, g = 0; g < u.length; g++) { var A = u[g].from(), w = J(t.getLine(A.line), A.ch, s); e.push(pt(s - w % s)) } t.replaceSelections(e) }, defaultTab: function (t) { t.somethingSelected() ? t.indentSelection("add") : t.execCommand("insertTab") }, transposeChars: function (t) { return He(t, function () { for (var e = t.listSelections(), u = [], s = 0; s < e.length; s++)if (e[s].empty()) { var g = e[s].head, A = Wt(t.doc, g.line).text; if (A) { if (g.ch == A.length && (g = new Z(g.line, g.ch - 1)), g.ch > 0) g = new Z(g.line, g.ch + 1), t.replaceRange(A.charAt(g.ch - 1) + A.charAt(g.ch - 2), Z(g.line, g.ch - 2), g, "+transpose"); else if (g.line > t.doc.first) { var w = Wt(t.doc, g.line - 1).text; w && (g = new Z(g.line, 1), t.replaceRange(A.charAt(0) + t.doc.lineSeparator() + w.charAt(w.length - 1), Z(g.line - 1, w.length - 1), g, "+transpose")) } } u.push(new te(g, g)) } t.setSelections(u) }) }, newlineAndIndent: function (t) { return He(t, function () { for (var e = t.listSelections(), u = e.length - 1; u >= 0; u--)t.replaceRange(t.doc.lineSeparator(), e[u].anchor, e[u].head, "+input"); e = t.listSelections(); for (var s = 0; s < e.length; s++)t.indentLine(e[s].from().line, null, !0); Cr(t) }) }, openLine: function (t) {
          return t.replaceSelection(`
`, "start")
        }, toggleOverwrite: function (t) { return t.toggleOverwrite() }
      }; function Vl(t, e) { var u = Wt(t.doc, e), s = ii(u); return s != u && (e = $t(s)), xs(!0, t, s, e, 1) } function tc(t, e) { var u = Wt(t.doc, e), s = Rf(u); return s != u && (e = $t(s)), xs(!0, t, u, e, -1) } function zl(t, e) { var u = Vl(t, e.line), s = Wt(t.doc, u.line), g = ee(s, t.doc.direction); if (!g || g[0].level == 0) { var A = Math.max(u.ch, s.text.search(/\S/)), w = e.line == u.line && e.ch <= A && e.ch; return Z(u.line, w ? 0 : A, u.sticky) } return u } function sa(t, e, u) { if (typeof e == "string" && (e = hn[e], !e)) return !1; t.display.input.ensurePolled(); var s = t.display.shift, g = !1; try { t.isReadOnly() && (t.state.suppressEdits = !0), u && (t.display.shift = !1), g = e(t) != mt } finally { t.display.shift = s, t.state.suppressEdits = !1 } return g } function ec(t, e, u) { for (var s = 0; s < t.state.keyMaps.length; s++) { var g = Er(e, t.state.keyMaps[s], u, t); if (g) return g } return t.options.extraKeys && Er(e, t.options.extraKeys, u, t) || Er(e, t.options.keyMap, u, t) } var ic = new ht; function cn(t, e, u, s) { var g = t.state.keySeq; if (g) { if (Wl(e)) return "handled"; if (/\'$/.test(e) ? t.state.keySeq = null : ic.set(50, function () { t.state.keySeq == g && (t.state.keySeq = null, t.display.input.reset()) }), Ul(t, g + " " + e, u, s)) return !0 } return Ul(t, e, u, s) } function Ul(t, e, u, s) { var g = ec(t, e, s); return g == "multi" && (t.state.keySeq = e), g == "handled" && Se(t, "keyHandled", t, e, u), (g == "handled" || g == "multi") && (de(u), as(t)), !!g } function Hl(t, e) { var u = Yl(e, !0); return u ? e.shiftKey && !t.state.keySeq ? cn(t, "Shift-" + u, e, function (s) { return sa(t, s, !0) }) || cn(t, u, e, function (s) { if (typeof s == "string" ? /^go[A-Z]/.test(s) : s.motion) return sa(t, s) }) : cn(t, u, e, function (s) { return sa(t, s) }) : !1 } function rc(t, e, u) { return cn(t, "'" + u + "'", e, function (s) { return sa(t, s, !0) }) } var _s = null; function Gl(t) { var e = this; if (!(t.target && t.target != e.display.input.getField()) && (e.curOp.focus = O(lt(e)), !oe(e, t))) { a && l < 11 && t.keyCode == 27 && (t.returnValue = !1); var u = t.keyCode; e.display.shift = u == 16 || t.shiftKey; var s = Hl(e, t); o && (_s = s ? u : null, !s && u == 88 && !hi && (I ? t.metaKey : t.ctrlKey) && e.replaceSelection("", null, "cut")), k && !I && !s && u == 46 && t.shiftKey && !t.ctrlKey && document.execCommand && document.execCommand("cut"), u == 18 && !/\bCodeMirror-crosshair\b/.test(e.display.lineDiv.className) && nc(e) } } function nc(t) { var e = t.display.lineDiv; V(e, "CodeMirror-crosshair"); function u(s) { (s.keyCode == 18 || !s.altKey) && (dt(e, "CodeMirror-crosshair"), be(document, "keyup", u), be(document, "mouseover", u)) } It(document, "keyup", u), It(document, "mouseover", u) } function jl(t) { t.keyCode == 16 && (this.doc.sel.shift = !1), oe(this, t) } function Xl(t) { var e = this; if (!(t.target && t.target != e.display.input.getField()) && !(Ii(e.display, t) || oe(e, t) || t.ctrlKey && !t.altKey || I && t.metaKey)) { var u = t.keyCode, s = t.charCode; if (o && u == _s) { _s = null, de(t); return } if (!(o && (!t.which || t.which < 10) && Hl(e, t))) { var g = String.fromCharCode(s ?? u); g != "\b" && (rc(e, t, g) || e.display.input.onKeyPress(t)) } } } var ac = 400, Ss = function (t, e, u) { this.time = t, this.pos = e, this.button = u }; Ss.prototype.compare = function (t, e, u) { return this.time + ac > t && At(e, this.pos) == 0 && u == this.button }; var dn, gn; function sc(t, e) { var u = +new Date; return gn && gn.compare(u, t, e) ? (dn = gn = null, "triple") : dn && dn.compare(u, t, e) ? (gn = new Ss(u, t, e), dn = null, "double") : (dn = new Ss(u, t, e), gn = null, "single") } function Kl(t) { var e = this, u = e.display; if (!(oe(e, t) || u.activeTouch && u.input.supportsTouch())) { if (u.input.ensurePolled(), u.shift = t.shiftKey, Ii(u, t)) { c || (u.scroller.draggable = !1, setTimeout(function () { return u.scroller.draggable = !0 }, 100)); return } if (!Ts(e, t)) { var s = $i(e, t), g = Wr(t), A = s ? sc(s, g) : "single"; H(e).focus(), g == 1 && e.state.selectingText && e.state.selectingText(t), !(s && oc(e, g, s, A, t)) && (g == 1 ? s ? uc(e, s, A, t) : Qe(t) == u.scroller && de(t) : g == 2 ? (s && ta(e.doc, s), setTimeout(function () { return u.input.focus() }, 20)) : g == 3 && (tt ? e.display.input.onContextMenu(t) : ss(e))) } } } function oc(t, e, u, s, g) { var A = "Click"; return s == "double" ? A = "Double" + A : s == "triple" && (A = "Triple" + A), A = (e == 1 ? "Left" : e == 2 ? "Middle" : "Right") + A, cn(t, Nl(A, g), g, function (w) { if (typeof w == "string" && (w = hn[w]), !w) return !1; var T = !1; try { t.isReadOnly() && (t.state.suppressEdits = !0), T = w(t, u) != mt } finally { t.state.suppressEdits = !1 } return T }) } function lc(t, e, u) { var s = t.getOption("configureMouse"), g = s ? s(t, e, u) : {}; if (g.unit == null) { var A = D ? u.shiftKey && u.metaKey : u.altKey; g.unit = A ? "rectangle" : e == "single" ? "char" : e == "double" ? "word" : "line" } return (g.extend == null || t.doc.extend) && (g.extend = t.doc.extend || u.shiftKey), g.addNew == null && (g.addNew = I ? u.metaKey : u.ctrlKey), g.moveOnDrag == null && (g.moveOnDrag = !(I ? u.altKey : u.ctrlKey)), g } function uc(t, e, u, s) { a ? setTimeout(R(qo, t), 0) : t.curOp.focus = O(lt(t)); var g = lc(t, u, s), A = t.doc.sel, w; t.options.dragDrop && Qa && !t.isReadOnly() && u == "single" && (w = A.contains(e)) > -1 && (At((w = A.ranges[w]).from(), e) < 0 || e.xRel > 0) && (At(w.to(), e) > 0 || e.xRel < 0) ? fc(t, s, e, g) : hc(t, s, e, g) } function fc(t, e, u, s) { var g = t.display, A = !1, w = Te(t, function (M) { c && (g.scroller.draggable = !1), t.state.draggingText = !1, t.state.delayingBlurEvent && (t.hasFocus() ? t.state.delayingBlurEvent = !1 : ss(t)), be(g.wrapper.ownerDocument, "mouseup", w), be(g.wrapper.ownerDocument, "mousemove", T), be(g.scroller, "dragstart", B), be(g.scroller, "drop", w), A || (de(M), s.addNew || ta(t.doc, u, null, null, s.extend), c && !p || a && l == 9 ? setTimeout(function () { g.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), g.input.focus() }, 20) : g.input.focus()) }), T = function (M) { A = A || Math.abs(e.clientX - M.clientX) + Math.abs(e.clientY - M.clientY) >= 10 }, B = function () { return A = !0 }; c && (g.scroller.draggable = !0), t.state.draggingText = w, w.copy = !s.moveOnDrag, It(g.wrapper.ownerDocument, "mouseup", w), It(g.wrapper.ownerDocument, "mousemove", T), It(g.scroller, "dragstart", B), It(g.scroller, "drop", w), t.state.delayingBlurEvent = !0, setTimeout(function () { return g.input.focus() }, 20), g.scroller.dragDrop && g.scroller.dragDrop() } function ql(t, e, u) { if (u == "char") return new te(e, e); if (u == "word") return t.findWordAt(e); if (u == "line") return new te(Z(e.line, 0), Ht(t.doc, Z(e.line + 1, 0))); var s = u(t, e); return new te(s.from, s.to) } function hc(t, e, u, s) { a && ss(t); var g = t.display, A = t.doc; de(e); var w, T, B = A.sel, M = B.ranges; if (s.addNew && !s.extend ? (T = A.sel.contains(u), T > -1 ? w = M[T] : w = new te(u, u)) : (w = A.sel.primary(), T = A.sel.primIndex), s.unit == "rectangle") s.addNew || (w = new te(u, u)), u = $i(t, e, !0, !0), T = -1; else { var Y = ql(t, u, s.unit); s.extend ? w = As(w, Y.anchor, Y.head, s.extend) : w = Y } s.addNew ? T == -1 ? (T = M.length, De(A, ni(t, M.concat([w]), T), { scroll: !1, origin: "*mouse" })) : M.length > 1 && M[T].empty() && s.unit == "char" && !s.extend ? (De(A, ni(t, M.slice(0, T).concat(M.slice(T + 1)), 0), { scroll: !1, origin: "*mouse" }), B = A.sel) : Cs(A, T, w, gt) : (T = 0, De(A, new Ke([w], 0), gt), B = A.sel); var j = u; function ot(Ot) { if (At(j, Ot) != 0) if (j = Ot, s.unit == "rectangle") { for (var Rt = [], Yt = t.options.tabSize, Nt = J(Wt(A, u.line).text, u.ch, Yt), Xt = J(Wt(A, Ot.line).text, Ot.ch, Yt), se = Math.min(Nt, Xt), Ie = Math.max(Nt, Xt), he = Math.min(u.line, Ot.line), Ge = Math.min(t.lastLine(), Math.max(u.line, Ot.line)); he <= Ge; he++) { var Ye = Wt(A, he).text, Ae = wt(Ye, se, Yt); se == Ie ? Rt.push(new te(Z(he, Ae), Z(he, Ae))) : Ye.length > Ae && Rt.push(new te(Z(he, Ae), Z(he, wt(Ye, Ie, Yt)))) } Rt.length || Rt.push(new te(u, u)), De(A, ni(t, B.ranges.slice(0, T).concat(Rt), T), { origin: "*mouse", scroll: !1 }), t.scrollIntoView(Ot) } else { var Ve = w, Me = ql(t, Ot, s.unit), _e = Ve.anchor, Ce; At(Me.anchor, _e) > 0 ? (Ce = Me.head, _e = xe(Ve.from(), Me.anchor)) : (Ce = Me.anchor, _e = Zt(Ve.to(), Me.head)); var pe = B.ranges.slice(0); pe[T] = cc(t, new te(Ht(A, _e), Ce)), De(A, ni(t, pe, T), gt) } } var nt = g.wrapper.getBoundingClientRect(), Ct = 0; function Tt(Ot) { var Rt = ++Ct, Yt = $i(t, Ot, !0, s.unit == "rectangle"); if (Yt) if (At(Yt, j) != 0) { t.curOp.focus = O(lt(t)), ot(Yt); var Nt = Xn(g, A); (Yt.line >= Nt.to || Yt.line < Nt.from) && setTimeout(Te(t, function () { Ct == Rt && Tt(Ot) }), 150) } else { var Xt = Ot.clientY < nt.top ? -20 : Ot.clientY > nt.bottom ? 20 : 0; Xt && setTimeout(Te(t, function () { Ct == Rt && (g.scroller.scrollTop += Xt, Tt(Ot)) }), 50) } } function Bt(Ot) { t.state.selectingText = !1, Ct = 1 / 0, Ot && (de(Ot), g.input.focus()), be(g.wrapper.ownerDocument, "mousemove", Mt), be(g.wrapper.ownerDocument, "mouseup", Pt), A.history.lastSelOrigin = null } var Mt = Te(t, function (Ot) { Ot.buttons === 0 || !Wr(Ot) ? Bt(Ot) : Tt(Ot) }), Pt = Te(t, Bt); t.state.selectingText = Pt, It(g.wrapper.ownerDocument, "mousemove", Mt), It(g.wrapper.ownerDocument, "mouseup", Pt) } function cc(t, e) { var u = e.anchor, s = e.head, g = Wt(t.doc, u.line); if (At(u, s) == 0 && u.sticky == s.sticky) return e; var A = ee(g); if (!A) return e; var w = Kt(A, u.ch, u.sticky), T = A[w]; if (T.from != u.ch && T.to != u.ch) return e; var B = w + (T.from == u.ch == (T.level != 1) ? 0 : 1); if (B == 0 || B == A.length) return e; var M; if (s.line != u.line) M = (s.line - u.line) * (t.doc.direction == "ltr" ? 1 : -1) > 0; else { var Y = Kt(A, s.ch, s.sticky), j = Y - w || (s.ch - u.ch) * (T.level == 1 ? -1 : 1); Y == B - 1 || Y == B ? M = j < 0 : M = j > 0 } var ot = A[B + (M ? -1 : 0)], nt = M == (ot.level == 1), Ct = nt ? ot.from : ot.to, Tt = nt ? "after" : "before"; return u.ch == Ct && u.sticky == Tt ? e : new te(new Z(u.line, Ct, Tt), s) } function Jl(t, e, u, s) { var g, A; if (e.touches) g = e.touches[0].clientX, A = e.touches[0].clientY; else try { g = e.clientX, A = e.clientY } catch { return !1 } if (g >= Math.floor(t.display.gutters.getBoundingClientRect().right)) return !1; s && de(e); var w = t.display, T = w.lineDiv.getBoundingClientRect(); if (A > T.bottom || !we(t, u)) return ti(e); A -= T.top - w.viewOffset; for (var B = 0; B < t.display.gutterSpecs.length; ++B) { var M = w.gutters.childNodes[B]; if (M && M.getBoundingClientRect().right >= g) { var Y = di(t.doc, A), j = t.display.gutterSpecs[B]; return ie(t, u, t, Y, j.className, e), ti(e) } } } function Ts(t, e) { return Jl(t, e, "gutterClick", !0) } function Zl(t, e) { Ii(t.display, e) || dc(t, e) || oe(t, e, "contextmenu") || tt || t.display.input.onContextMenu(e) } function dc(t, e) { return we(t, "gutterContextMenu") ? Jl(t, e, "gutterContextMenu", !1) : !1 } function $l(t) { t.display.wrapper.className = t.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + t.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), jr(t) } var Br = { toString: function () { return "CodeMirror.Init" } }, tu = {}, oa = {}; function gc(t) { var e = t.optionHandlers; function u(s, g, A, w) { t.defaults[s] = g, A && (e[s] = w ? function (T, B, M) { M != Br && A(T, B, M) } : A) } t.defineOption = u, t.Init = Br, u("value", "", function (s, g) { return s.setValue(g) }, !0), u("mode", null, function (s, g) { s.doc.modeOption = g, vs(s) }, !0), u("indentUnit", 2, vs, !0), u("indentWithTabs", !1), u("smartIndent", !0), u("tabSize", 4, function (s) { en(s), jr(s), We(s) }, !0), u("lineSeparator", null, function (s, g) { if (s.doc.lineSep = g, !!g) { var A = [], w = s.doc.first; s.doc.iter(function (B) { for (var M = 0; ;) { var Y = B.text.indexOf(g, M); if (Y == -1) break; M = Y + g.length, A.push(Z(w, Y)) } w++ }); for (var T = A.length - 1; T >= 0; T--)Sr(s.doc, g, A[T], Z(A[T].line, A[T].ch + g.length)) } }), u("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function (s, g, A) { s.state.specialChars = new RegExp(g.source + (g.test("	") ? "" : "|	"), "g"), A != Br && s.refresh() }), u("specialCharPlaceholder", zf, function (s) { return s.refresh() }, !0), u("electricChars", !0), u("inputStyle", x ? "contenteditable" : "textarea", function () { throw new Error("inputStyle can not (yet) be changed in a running editor") }, !0), u("spellcheck", !1, function (s, g) { return s.getInputField().spellcheck = g }, !0), u("autocorrect", !1, function (s, g) { return s.getInputField().autocorrect = g }, !0), u("autocapitalize", !1, function (s, g) { return s.getInputField().autocapitalize = g }, !0), u("rtlMoveVisually", !P), u("wholeLineUpdateBefore", !0), u("theme", "default", function (s) { $l(s), tn(s) }, !0), u("keyMap", "default", function (s, g, A) { var w = aa(g), T = A != Br && aa(A); T && T.detach && T.detach(s, w), w.attach && w.attach(s, T || null) }), u("extraKeys", null), u("configureMouse", null), u("lineWrapping", !1, vc, !0), u("gutters", [], function (s, g) { s.display.gutterSpecs = gs(g, s.options.lineNumbers), tn(s) }, !0), u("fixedGutter", !0, function (s, g) { s.display.gutters.style.left = g ? is(s.display) + "px" : "0", s.refresh() }, !0), u("coverGutterNextToScrollbar", !1, function (s) { return br(s) }, !0), u("scrollbarStyle", "native", function (s) { il(s), br(s), s.display.scrollbars.setScrollTop(s.doc.scrollTop), s.display.scrollbars.setScrollLeft(s.doc.scrollLeft) }, !0), u("lineNumbers", !1, function (s, g) { s.display.gutterSpecs = gs(s.options.gutters, g), tn(s) }, !0), u("firstLineNumber", 1, tn, !0), u("lineNumberFormatter", function (s) { return s }, tn, !0), u("showCursorWhenSelecting", !1, Xr, !0), u("resetSelectionOnContextMenu", !0), u("lineWiseCopyCut", !0), u("pasteLinesPerSelection", !0), u("selectionsMayTouch", !1), u("readOnly", !1, function (s, g) { g == "nocursor" && (Ar(s), s.display.input.blur()), s.display.input.readOnlyChanged(g) }), u("screenReaderLabel", null, function (s, g) { g = g === "" ? null : g, s.display.input.screenReaderLabelChanged(g) }), u("disableInput", !1, function (s, g) { g || s.display.input.reset() }, !0), u("dragDrop", !0, pc), u("allowDropFileTypes", null), u("cursorBlinkRate", 530), u("cursorScrollMargin", 0), u("cursorHeight", 1, Xr, !0), u("singleCursorHeightPerLine", !0, Xr, !0), u("workTime", 100), u("workDelay", 100), u("flattenSpans", !0, en, !0), u("addModeClass", !1, en, !0), u("pollInterval", 100), u("undoDepth", 200, function (s, g) { return s.doc.history.undoDepth = g }), u("historyEventDelay", 1250), u("viewportMargin", 10, function (s) { return s.refresh() }, !0), u("maxHighlightLength", 1e4, en, !0), u("moveInputWithCursor", !0, function (s, g) { g || s.display.input.resetPosition() }), u("tabindex", null, function (s, g) { return s.display.input.getField().tabIndex = g || "" }), u("autofocus", null), u("direction", "ltr", function (s, g) { return s.doc.setDirection(g) }, !0), u("phrases", null) } function pc(t, e, u) { var s = u && u != Br; if (!e != !s) { var g = t.display.dragFunctions, A = e ? It : be; A(t.display.scroller, "dragstart", g.start), A(t.display.scroller, "dragenter", g.enter), A(t.display.scroller, "dragover", g.over), A(t.display.scroller, "dragleave", g.leave), A(t.display.scroller, "drop", g.drop) } } function vc(t) { t.options.lineWrapping ? (V(t.display.wrapper, "CodeMirror-wrap"), t.display.sizer.style.minWidth = "", t.display.sizerWidth = null) : (dt(t.display.wrapper, "CodeMirror-wrap"), Ga(t)), rs(t), We(t), jr(t), setTimeout(function () { return br(t) }, 100) } function ue(t, e) { var u = this; if (!(this instanceof ue)) return new ue(t, e); this.options = e = e ? K(e) : {}, K(tu, e, !1); var s = e.value; typeof s == "string" ? s = new Ne(s, e.mode, null, e.lineSeparator, e.direction) : e.mode && (s.modeOption = e.mode), this.doc = s; var g = new ue.inputStyles[e.inputStyle](this), A = this.display = new Bh(t, s, g, e); A.wrapper.CodeMirror = this, $l(this), e.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), il(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: -1, cutIncoming: -1, selectingText: !1, draggingText: !1, highlight: new ht, keySeq: null, specialChars: null }, e.autofocus && !x && A.input.focus(), a && l < 11 && setTimeout(function () { return u.display.input.reset(!0) }, 20), mc(this), Xh(), rr(this), this.curOp.forceUpdate = !0, cl(this, s), e.autofocus && !x || this.hasFocus() ? setTimeout(function () { u.hasFocus() && !u.state.focused && os(u) }, 20) : Ar(this); for (var w in oa) oa.hasOwnProperty(w) && oa[w](this, e[w], Br); al(this), e.finishInit && e.finishInit(this); for (var T = 0; T < Es.length; ++T)Es[T](this); nr(this), c && e.lineWrapping && getComputedStyle(A.lineDiv).textRendering == "optimizelegibility" && (A.lineDiv.style.textRendering = "auto") } ue.defaults = tu, ue.optionHandlers = oa; function mc(t) { var e = t.display; It(e.scroller, "mousedown", Te(t, Kl)), a && l < 11 ? It(e.scroller, "dblclick", Te(t, function (B) { if (!oe(t, B)) { var M = $i(t, B); if (!(!M || Ts(t, B) || Ii(t.display, B))) { de(B); var Y = t.findWordAt(M); ta(t.doc, Y.anchor, Y.head) } } })) : It(e.scroller, "dblclick", function (B) { return oe(t, B) || de(B) }), It(e.scroller, "contextmenu", function (B) { return Zl(t, B) }), It(e.input.getField(), "contextmenu", function (B) { e.scroller.contains(B.target) || Zl(t, B) }); var u, s = { end: 0 }; function g() { e.activeTouch && (u = setTimeout(function () { return e.activeTouch = null }, 1e3), s = e.activeTouch, s.end = +new Date) } function A(B) { if (B.touches.length != 1) return !1; var M = B.touches[0]; return M.radiusX <= 1 && M.radiusY <= 1 } function w(B, M) { if (M.left == null) return !0; var Y = M.left - B.left, j = M.top - B.top; return Y * Y + j * j > 20 * 20 } It(e.scroller, "touchstart", function (B) { if (!oe(t, B) && !A(B) && !Ts(t, B)) { e.input.ensurePolled(), clearTimeout(u); var M = +new Date; e.activeTouch = { start: M, moved: !1, prev: M - s.end <= 300 ? s : null }, B.touches.length == 1 && (e.activeTouch.left = B.touches[0].pageX, e.activeTouch.top = B.touches[0].pageY) } }), It(e.scroller, "touchmove", function () { e.activeTouch && (e.activeTouch.moved = !0) }), It(e.scroller, "touchend", function (B) { var M = e.activeTouch; if (M && !Ii(e, B) && M.left != null && !M.moved && new Date - M.start < 300) { var Y = t.coordsChar(e.activeTouch, "page"), j; !M.prev || w(M, M.prev) ? j = new te(Y, Y) : !M.prev.prev || w(M, M.prev.prev) ? j = t.findWordAt(Y) : j = new te(Z(Y.line, 0), Ht(t.doc, Z(Y.line + 1, 0))), t.setSelection(j.anchor, j.head), t.focus(), de(B) } g() }), It(e.scroller, "touchcancel", g), It(e.scroller, "scroll", function () { e.scroller.clientHeight && (qr(t, e.scroller.scrollTop), er(t, e.scroller.scrollLeft, !0), ie(t, "scroll", t)) }), It(e.scroller, "mousewheel", function (B) { return ll(t, B) }), It(e.scroller, "DOMMouseScroll", function (B) { return ll(t, B) }), It(e.wrapper, "scroll", function () { return e.wrapper.scrollTop = e.wrapper.scrollLeft = 0 }), e.dragFunctions = { enter: function (B) { oe(t, B) || wi(B) }, over: function (B) { oe(t, B) || (jh(t, B), wi(B)) }, start: function (B) { return Gh(t, B) }, drop: Te(t, Hh), leave: function (B) { oe(t, B) || Pl(t) } }; var T = e.input.getField(); It(T, "keyup", function (B) { return jl.call(t, B) }), It(T, "keydown", Te(t, Gl)), It(T, "keypress", Te(t, Xl)), It(T, "focus", function (B) { return os(t, B) }), It(T, "blur", function (B) { return Ar(t, B) }) } var Es = []; ue.defineInitHook = function (t) { return Es.push(t) }; function pn(t, e, u, s) { var g = t.doc, A; u == null && (u = "add"), u == "smart" && (g.mode.indent ? A = Vr(t, e).state : u = "prev"); var w = t.options.tabSize, T = Wt(g, e), B = J(T.text, null, w); T.stateAfter && (T.stateAfter = null); var M = T.text.match(/^\s*/)[0], Y; if (!s && !/\S/.test(T.text)) Y = 0, u = "not"; else if (u == "smart" && (Y = g.mode.indent(A, T.text.slice(M.length), T.text), Y == mt || Y > 150)) { if (!s) return; u = "prev" } u == "prev" ? e > g.first ? Y = J(Wt(g, e - 1).text, null, w) : Y = 0 : u == "add" ? Y = B + t.options.indentUnit : u == "subtract" ? Y = B - t.options.indentUnit : typeof u == "number" && (Y = B + u), Y = Math.max(0, Y); var j = "", ot = 0; if (t.options.indentWithTabs) for (var nt = Math.floor(Y / w); nt; --nt)ot += w, j += "	"; if (ot < Y && (j += pt(Y - ot)), j != M) return Sr(g, j, Z(e, 0), Z(e, M.length), "+input"), T.stateAfter = null, !0; for (var Ct = 0; Ct < g.sel.ranges.length; Ct++) { var Tt = g.sel.ranges[Ct]; if (Tt.head.line == e && Tt.head.ch < M.length) { var Bt = Z(e, M.length); Cs(g, Ct, new te(Bt, Bt)); break } } } var ai = null; function la(t) { ai = t } function Is(t, e, u, s, g) {
        var A = t.doc; t.display.shift = !1, s || (s = A.sel); var w = +new Date - 200, T = g == "paste" || t.state.pasteIncoming > w, B = Nr(e), M = null; if (T && s.ranges.length > 1) if (ai && ai.text.join(`
`) == e) { if (s.ranges.length % ai.text.length == 0) { M = []; for (var Y = 0; Y < ai.text.length; Y++)M.push(A.splitLines(ai.text[Y])) } } else B.length == s.ranges.length && t.options.pasteLinesPerSelection && (M = kt(B, function (Mt) { return [Mt] })); for (var j = t.curOp.updateInput, ot = s.ranges.length - 1; ot >= 0; ot--) {
          var nt = s.ranges[ot], Ct = nt.from(), Tt = nt.to(); nt.empty() && (u && u > 0 ? Ct = Z(Ct.line, Ct.ch - u) : t.state.overwrite && !T ? Tt = Z(Tt.line, Math.min(Wt(A, Tt.line).text.length, Tt.ch + vt(B).length)) : T && ai && ai.lineWise && ai.text.join(`
`) == B.join(`
`) && (Ct = Tt = Z(Ct.line, 0))); var Bt = { from: Ct, to: Tt, text: M ? M[ot % M.length] : B, origin: g || (T ? "paste" : t.state.cutIncoming > w ? "cut" : "+input") }; _r(t.doc, Bt), Se(t, "inputRead", t, Bt)
        } e && !T && iu(t, e), Cr(t), t.curOp.updateInput < 2 && (t.curOp.updateInput = j), t.curOp.typing = !0, t.state.pasteIncoming = t.state.cutIncoming = -1
      } function eu(t, e) { var u = t.clipboardData && t.clipboardData.getData("Text"); if (u) return t.preventDefault(), !e.isReadOnly() && !e.options.disableInput && e.hasFocus() && He(e, function () { return Is(e, u, 0, null, "paste") }), !0 } function iu(t, e) { if (!(!t.options.electricChars || !t.options.smartIndent)) for (var u = t.doc.sel, s = u.ranges.length - 1; s >= 0; s--) { var g = u.ranges[s]; if (!(g.head.ch > 100 || s && u.ranges[s - 1].head.line == g.head.line)) { var A = t.getModeAt(g.head), w = !1; if (A.electricChars) { for (var T = 0; T < A.electricChars.length; T++)if (e.indexOf(A.electricChars.charAt(T)) > -1) { w = pn(t, g.head.line, "smart"); break } } else A.electricInput && A.electricInput.test(Wt(t.doc, g.head.line).text.slice(0, g.head.ch)) && (w = pn(t, g.head.line, "smart")); w && Se(t, "electricInput", t, g.head.line) } } } function ru(t) { for (var e = [], u = [], s = 0; s < t.doc.sel.ranges.length; s++) { var g = t.doc.sel.ranges[s].head.line, A = { anchor: Z(g, 0), head: Z(g + 1, 0) }; u.push(A), e.push(t.getRange(A.anchor, A.head)) } return { text: e, ranges: u } } function Bs(t, e, u, s) { t.setAttribute("autocorrect", u ? "on" : "off"), t.setAttribute("autocapitalize", s ? "on" : "off"), t.setAttribute("spellcheck", !!e) } function nu() { var t = W("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), e = W("div", [t], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); return c ? t.style.width = "1000px" : t.setAttribute("wrap", "off"), y && (t.style.border = "1px solid black"), e } function yc(t) { var e = t.optionHandlers, u = t.helpers = {}; t.prototype = { constructor: t, focus: function () { H(this).focus(), this.display.input.focus() }, setOption: function (s, g) { var A = this.options, w = A[s]; A[s] == g && s != "mode" || (A[s] = g, e.hasOwnProperty(s) && Te(this, e[s])(this, g, w), ie(this, "optionChange", this, s)) }, getOption: function (s) { return this.options[s] }, getDoc: function () { return this.doc }, addKeyMap: function (s, g) { this.state.keyMaps[g ? "push" : "unshift"](aa(s)) }, removeKeyMap: function (s) { for (var g = this.state.keyMaps, A = 0; A < g.length; ++A)if (g[A] == s || g[A].name == s) return g.splice(A, 1), !0 }, addOverlay: Fe(function (s, g) { var A = s.token ? s : t.getMode(this.options, s); if (A.startState) throw new Error("Overlays may not be stateful."); L(this.state.overlays, { mode: A, modeSpec: s, opaque: g && g.opaque, priority: g && g.priority || 0 }, function (w) { return w.priority }), this.state.modeGen++, We(this) }), removeOverlay: Fe(function (s) { for (var g = this.state.overlays, A = 0; A < g.length; ++A) { var w = g[A].modeSpec; if (w == s || typeof s == "string" && w.name == s) { g.splice(A, 1), this.state.modeGen++, We(this); return } } }), indentLine: Fe(function (s, g, A) { typeof g != "string" && typeof g != "number" && (g == null ? g = this.options.smartIndent ? "smart" : "prev" : g = g ? "add" : "subtract"), F(this.doc, s) && pn(this, s, g, A) }), indentSelection: Fe(function (s) { for (var g = this.doc.sel.ranges, A = -1, w = 0; w < g.length; w++) { var T = g[w]; if (T.empty()) T.head.line > A && (pn(this, T.head.line, s, !0), A = T.head.line, w == this.doc.sel.primIndex && Cr(this)); else { var B = T.from(), M = T.to(), Y = Math.max(A, B.line); A = Math.min(this.lastLine(), M.line - (M.ch ? 0 : 1)) + 1; for (var j = Y; j < A; ++j)pn(this, j, s); var ot = this.doc.sel.ranges; B.ch == 0 && g.length == ot.length && ot[w].from().ch > 0 && Cs(this.doc, w, new te(B, ot[w].to()), St) } } }), getTokenAt: function (s, g) { return go(this, s, g) }, getLineTokens: function (s, g) { return go(this, Z(s), g, !0) }, getTokenTypeAt: function (s) { s = Ht(this.doc, s); var g = fo(this, Wt(this.doc, s.line)), A = 0, w = (g.length - 1) / 2, T = s.ch, B; if (T == 0) B = g[2]; else for (; ;) { var M = A + w >> 1; if ((M ? g[M * 2 - 1] : 0) >= T) w = M; else if (g[M * 2 + 1] < T) A = M + 1; else { B = g[M * 2 + 2]; break } } var Y = B ? B.indexOf("overlay ") : -1; return Y < 0 ? B : Y == 0 ? null : B.slice(0, Y - 1) }, getModeAt: function (s) { var g = this.doc.mode; return g.innerMode ? t.innerMode(g, this.getTokenAt(s).state).mode : g }, getHelper: function (s, g) { return this.getHelpers(s, g)[0] }, getHelpers: function (s, g) { var A = []; if (!u.hasOwnProperty(g)) return A; var w = u[g], T = this.getModeAt(s); if (typeof T[g] == "string") w[T[g]] && A.push(w[T[g]]); else if (T[g]) for (var B = 0; B < T[g].length; B++) { var M = w[T[g][B]]; M && A.push(M) } else T.helperType && w[T.helperType] ? A.push(w[T.helperType]) : w[T.name] && A.push(w[T.name]); for (var Y = 0; Y < w._global.length; Y++) { var j = w._global[Y]; j.pred(T, this) && ut(A, j.val) == -1 && A.push(j.val) } return A }, getStateAfter: function (s, g) { var A = this.doc; return s = Xe(A, s ?? A.first + A.size - 1), Vr(this, s + 1, g).state }, cursorCoords: function (s, g) { var A, w = this.doc.sel.primary(); return s == null ? A = w.head : typeof s == "object" ? A = Ht(this.doc, s) : A = s ? w.from() : w.to(), ri(this, A, g || "page") }, charCoords: function (s, g) { return Un(this, Ht(this.doc, s), g || "page") }, coordsChar: function (s, g) { return s = zo(this, s, g || "page"), $a(this, s.left, s.top) }, lineAtHeight: function (s, g) { return s = zo(this, { top: s, left: 0 }, g || "page").top, di(this.doc, s + this.display.viewOffset) }, heightAtLine: function (s, g, A) { var w = !1, T; if (typeof s == "number") { var B = this.doc.first + this.doc.size - 1; s < this.doc.first ? s = this.doc.first : s > B && (s = B, w = !0), T = Wt(this.doc, s) } else T = s; return zn(this, T, { top: 0, left: 0 }, g || "page", A || w).top + (w ? this.doc.height - Ei(T) : 0) }, defaultTextHeight: function () { return mr(this.display) }, defaultCharWidth: function () { return yr(this.display) }, getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget: function (s, g, A, w, T) { var B = this.display; s = ri(this, Ht(this.doc, s)); var M = s.bottom, Y = s.left; if (g.style.position = "absolute", g.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(g), B.sizer.appendChild(g), w == "over") M = s.top; else if (w == "above" || w == "near") { var j = Math.max(B.wrapper.clientHeight, this.doc.height), ot = Math.max(B.sizer.clientWidth, B.lineSpace.clientWidth); (w == "above" || s.bottom + g.offsetHeight > j) && s.top > g.offsetHeight ? M = s.top - g.offsetHeight : s.bottom + g.offsetHeight <= j && (M = s.bottom), Y + g.offsetWidth > ot && (Y = ot - g.offsetWidth) } g.style.top = M + "px", g.style.left = g.style.right = "", T == "right" ? (Y = B.sizer.clientWidth - g.offsetWidth, g.style.right = "0px") : (T == "left" ? Y = 0 : T == "middle" && (Y = (B.sizer.clientWidth - g.offsetWidth) / 2), g.style.left = Y + "px"), A && ph(this, { left: Y, top: M, right: Y + g.offsetWidth, bottom: M + g.offsetHeight }) }, triggerOnKeyDown: Fe(Gl), triggerOnKeyPress: Fe(Xl), triggerOnKeyUp: jl, triggerOnMouseDown: Fe(Kl), execCommand: function (s) { if (hn.hasOwnProperty(s)) return hn[s].call(null, this) }, triggerElectric: Fe(function (s) { iu(this, s) }), findPosH: function (s, g, A, w) { var T = 1; g < 0 && (T = -1, g = -g); for (var B = Ht(this.doc, s), M = 0; M < g && (B = ks(this.doc, B, T, A, w), !B.hitSide); ++M); return B }, moveH: Fe(function (s, g) { var A = this; this.extendSelectionsBy(function (w) { return A.display.shift || A.doc.extend || w.empty() ? ks(A.doc, w.head, s, g, A.options.rtlMoveVisually) : s < 0 ? w.from() : w.to() }, ft) }), deleteH: Fe(function (s, g) { var A = this.doc.sel, w = this.doc; A.somethingSelected() ? w.replaceSelection("", null, "+delete") : Ir(this, function (T) { var B = ks(w, T.head, s, g, !1); return s < 0 ? { from: B, to: T.head } : { from: T.head, to: B } }) }), findPosV: function (s, g, A, w) { var T = 1, B = w; g < 0 && (T = -1, g = -g); for (var M = Ht(this.doc, s), Y = 0; Y < g; ++Y) { var j = ri(this, M, "div"); if (B == null ? B = j.left : j.left = B, M = au(this, j, T, A), M.hitSide) break } return M }, moveV: Fe(function (s, g) { var A = this, w = this.doc, T = [], B = !this.display.shift && !w.extend && w.sel.somethingSelected(); if (w.extendSelectionsBy(function (Y) { if (B) return s < 0 ? Y.from() : Y.to(); var j = ri(A, Y.head, "div"); Y.goalColumn != null && (j.left = Y.goalColumn), T.push(j.left); var ot = au(A, j, s, g); return g == "page" && Y == w.sel.primary() && us(A, Un(A, ot, "div").top - j.top), ot }, ft), T.length) for (var M = 0; M < w.sel.ranges.length; M++)w.sel.ranges[M].goalColumn = T[M] }), findWordAt: function (s) { var g = this.doc, A = Wt(g, s.line).text, w = s.ch, T = s.ch; if (A) { var B = this.getHelper(s, "wordChars"); (s.sticky == "before" || T == A.length) && w ? --w : ++T; for (var M = A.charAt(w), Y = at(M, B) ? function (j) { return at(j, B) } : /\s/.test(M) ? function (j) { return /\s/.test(j) } : function (j) { return !/\s/.test(j) && !at(j) }; w > 0 && Y(A.charAt(w - 1));)--w; for (; T < A.length && Y(A.charAt(T));)++T } return new te(Z(s.line, w), Z(s.line, T)) }, toggleOverwrite: function (s) { s != null && s == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? V(this.display.cursorDiv, "CodeMirror-overwrite") : dt(this.display.cursorDiv, "CodeMirror-overwrite"), ie(this, "overwriteToggle", this, this.state.overwrite)) }, hasFocus: function () { return this.display.input.getField() == O(lt(this)) }, isReadOnly: function () { return !!(this.options.readOnly || this.doc.cantEdit) }, scrollTo: Fe(function (s, g) { Kr(this, s, g) }), getScrollInfo: function () { var s = this.display.scroller; return { left: s.scrollLeft, top: s.scrollTop, height: s.scrollHeight - pi(this) - this.display.barHeight, width: s.scrollWidth - pi(this) - this.display.barWidth, clientHeight: Ka(this), clientWidth: Ji(this) } }, scrollIntoView: Fe(function (s, g) { s == null ? (s = { from: this.doc.sel.primary().head, to: null }, g == null && (g = this.options.cursorScrollMargin)) : typeof s == "number" ? s = { from: Z(s, 0), to: null } : s.from == null && (s = { from: s, to: null }), s.to || (s.to = s.from), s.margin = g || 0, s.from.line != null ? vh(this, s) : Zo(this, s.from, s.to, s.margin) }), setSize: Fe(function (s, g) { var A = this, w = function (B) { return typeof B == "number" || /^\d+$/.test(String(B)) ? B + "px" : B }; s != null && (this.display.wrapper.style.width = w(s)), g != null && (this.display.wrapper.style.height = w(g)), this.options.lineWrapping && No(this); var T = this.display.viewFrom; this.doc.iter(T, this.display.viewTo, function (B) { if (B.widgets) { for (var M = 0; M < B.widgets.length; M++)if (B.widgets[M].noHScroll) { Ni(A, T, "widget"); break } } ++T }), this.curOp.forceUpdate = !0, ie(this, "refresh", this) }), operation: function (s) { return He(this, s) }, startOperation: function () { return rr(this) }, endOperation: function () { return nr(this) }, refresh: Fe(function () { var s = this.display.cachedTextHeight; We(this), this.curOp.forceUpdate = !0, jr(this), Kr(this, this.doc.scrollLeft, this.doc.scrollTop), cs(this.display), (s == null || Math.abs(s - mr(this.display)) > .5 || this.options.lineWrapping) && rs(this), ie(this, "refresh", this) }), swapDoc: Fe(function (s) { var g = this.doc; return g.cm = null, this.state.selectingText && this.state.selectingText(), cl(this, s), jr(this), this.display.input.reset(), Kr(this, s.scrollLeft, s.scrollTop), this.curOp.forceScroll = !0, Se(this, "swapDoc", this, g), g }), phrase: function (s) { var g = this.options.phrases; return g && Object.prototype.hasOwnProperty.call(g, s) ? g[s] : s }, getInputField: function () { return this.display.input.getField() }, getWrapperElement: function () { return this.display.wrapper }, getScrollerElement: function () { return this.display.scroller }, getGutterElement: function () { return this.display.gutters } }, ve(t), t.registerHelper = function (s, g, A) { u.hasOwnProperty(s) || (u[s] = t[s] = { _global: [] }), u[s][g] = A }, t.registerGlobalHelper = function (s, g, A, w) { t.registerHelper(s, g, w), u[s]._global.push({ pred: A, val: w }) } } function ks(t, e, u, s, g) {
        var A = e, w = u, T = Wt(t, e.line), B = g && t.direction == "rtl" ? -u : u; function M() { var Pt = e.line + B; return Pt < t.first || Pt >= t.first + t.size ? !1 : (e = new Z(Pt, e.ch, e.sticky), T = Wt(t, Pt)) } function Y(Pt) { var Ot; if (s == "codepoint") { var Rt = T.text.charCodeAt(e.ch + (u > 0 ? 0 : -1)); if (isNaN(Rt)) Ot = null; else { var Yt = u > 0 ? Rt >= 55296 && Rt < 56320 : Rt >= 56320 && Rt < 57343; Ot = new Z(e.line, Math.max(0, Math.min(T.text.length, e.ch + u * (Yt ? 2 : 1))), -u) } } else g ? Ot = $h(t.cm, T, e, u) : Ot = ws(T, e, u); if (Ot == null) if (!Pt && M()) e = xs(g, t.cm, T, e.line, B); else return !1; else e = Ot; return !0 } if (s == "char" || s == "codepoint") Y(); else if (s == "column") Y(!0); else if (s == "word" || s == "group") for (var j = null, ot = s == "group", nt = t.cm && t.cm.getHelper(e, "wordChars"), Ct = !0; !(u < 0 && !Y(!Ct)); Ct = !1) {
          var Tt = T.text.charAt(e.ch) || `
`, Bt = at(Tt, nt) ? "w" : ot && Tt == `
`? "n" : !ot || /\s/.test(Tt) ? null : "p"; if (ot && !Ct && !Bt && (Bt = "s"), j && j != Bt) { u < 0 && (u = 1, Y(), e.sticky = "after"); break } if (Bt && (j = Bt), u > 0 && !Y(!Ct)) break
        } var Mt = ia(t, e, A, w, !0); return Ut(A, Mt) && (Mt.hitSide = !0), Mt
      } function au(t, e, u, s) { var g = t.doc, A = e.left, w; if (s == "page") { var T = Math.min(t.display.wrapper.clientHeight, H(t).innerHeight || g(t).documentElement.clientHeight), B = Math.max(T - .5 * mr(t.display), 3); w = (u > 0 ? e.bottom : e.top) + u * B } else s == "line" && (w = u > 0 ? e.bottom + 3 : e.top - 3); for (var M; M = $a(t, A, w), !!M.outside;) { if (u < 0 ? w <= 0 : w >= g.height) { M.hitSide = !0; break } w += u * 5 } return M } var re = function (t) { this.cm = t, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new ht, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null }; re.prototype.init = function (t) {
        var e = this, u = this, s = u.cm, g = u.div = t.lineDiv; g.contentEditable = !0, Bs(g, s.options.spellcheck, s.options.autocorrect, s.options.autocapitalize); function A(T) { for (var B = T.target; B; B = B.parentNode) { if (B == g) return !0; if (/\bCodeMirror-(?:line)?widget\b/.test(B.className)) break } return !1 } It(g, "paste", function (T) { !A(T) || oe(s, T) || eu(T, s) || l <= 11 && setTimeout(Te(s, function () { return e.updateFromDOM() }), 20) }), It(g, "compositionstart", function (T) { e.composing = { data: T.data, done: !1 } }), It(g, "compositionupdate", function (T) { e.composing || (e.composing = { data: T.data, done: !1 }) }), It(g, "compositionend", function (T) { e.composing && (T.data != e.composing.data && e.readFromDOMSoon(), e.composing.done = !0) }), It(g, "touchstart", function () { return u.forceCompositionEnd() }), It(g, "input", function () { e.composing || e.readFromDOMSoon() }); function w(T) {
          if (!(!A(T) || oe(s, T))) {
            if (s.somethingSelected()) la({ lineWise: !1, text: s.getSelections() }), T.type == "cut" && s.replaceSelection("", null, "cut"); else if (s.options.lineWiseCopyCut) { var B = ru(s); la({ lineWise: !0, text: B.text }), T.type == "cut" && s.operation(function () { s.setSelections(B.ranges, 0, St), s.replaceSelection("", null, "cut") }) } else return; if (T.clipboardData) {
              T.clipboardData.clearData(); var M = ai.text.join(`
`); if (T.clipboardData.setData("Text", M), T.clipboardData.getData("Text") == M) { T.preventDefault(); return }
            } var Y = nu(), j = Y.firstChild; Bs(j), s.display.lineSpace.insertBefore(Y, s.display.lineSpace.firstChild), j.value = ai.text.join(`
`); var ot = O(g.ownerDocument); U(j), setTimeout(function () { s.display.lineSpace.removeChild(Y), ot.focus(), ot == g && u.showPrimarySelection() }, 50)
          }
        } It(g, "copy", w), It(g, "cut", w)
      }, re.prototype.screenReaderLabelChanged = function (t) { t ? this.div.setAttribute("aria-label", t) : this.div.removeAttribute("aria-label") }, re.prototype.prepareSelection = function () { var t = Ko(this.cm, !1); return t.focus = O(this.div.ownerDocument) == this.div, t }, re.prototype.showSelection = function (t, e) { !t || !this.cm.display.view.length || ((t.focus || e) && this.showPrimarySelection(), this.showMultipleSelections(t)) }, re.prototype.getSelection = function () { return this.cm.display.wrapper.ownerDocument.getSelection() }, re.prototype.showPrimarySelection = function () { var t = this.getSelection(), e = this.cm, u = e.doc.sel.primary(), s = u.from(), g = u.to(); if (e.display.viewTo == e.display.viewFrom || s.line >= e.display.viewTo || g.line < e.display.viewFrom) { t.removeAllRanges(); return } var A = ua(e, t.anchorNode, t.anchorOffset), w = ua(e, t.focusNode, t.focusOffset); if (!(A && !A.bad && w && !w.bad && At(xe(A, w), s) == 0 && At(Zt(A, w), g) == 0)) { var T = e.display.view, B = s.line >= e.display.viewFrom && su(e, s) || { node: T[0].measure.map[2], offset: 0 }, M = g.line < e.display.viewTo && su(e, g); if (!M) { var Y = T[T.length - 1].measure, j = Y.maps ? Y.maps[Y.maps.length - 1] : Y.map; M = { node: j[j.length - 1], offset: j[j.length - 2] - j[j.length - 3] } } if (!B || !M) { t.removeAllRanges(); return } var ot = t.rangeCount && t.getRangeAt(0), nt; try { nt = Lt(B.node, B.offset, M.offset, M.node) } catch { } nt && (!k && e.state.focused ? (t.collapse(B.node, B.offset), nt.collapsed || (t.removeAllRanges(), t.addRange(nt))) : (t.removeAllRanges(), t.addRange(nt)), ot && t.anchorNode == null ? t.addRange(ot) : k && this.startGracePeriod()), this.rememberSelection() } }, re.prototype.startGracePeriod = function () { var t = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () { t.gracePeriod = !1, t.selectionChanged() && t.cm.operation(function () { return t.cm.curOp.selectionChanged = !0 }) }, 20) }, re.prototype.showMultipleSelections = function (t) { ct(this.cm.display.cursorDiv, t.cursors), ct(this.cm.display.selectionDiv, t.selection) }, re.prototype.rememberSelection = function () { var t = this.getSelection(); this.lastAnchorNode = t.anchorNode, this.lastAnchorOffset = t.anchorOffset, this.lastFocusNode = t.focusNode, this.lastFocusOffset = t.focusOffset }, re.prototype.selectionInEditor = function () { var t = this.getSelection(); if (!t.rangeCount) return !1; var e = t.getRangeAt(0).commonAncestorContainer; return it(this.div, e) }, re.prototype.focus = function () { this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || O(this.div.ownerDocument) != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus()) }, re.prototype.blur = function () { this.div.blur() }, re.prototype.getField = function () { return this.div }, re.prototype.supportsTouch = function () { return !0 }, re.prototype.receivedFocus = function () { var t = this, e = this; this.selectionInEditor() ? setTimeout(function () { return t.pollSelection() }, 20) : He(this.cm, function () { return e.cm.curOp.selectionChanged = !0 }); function u() { e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, u)) } this.polling.set(this.cm.options.pollInterval, u) }, re.prototype.selectionChanged = function () { var t = this.getSelection(); return t.anchorNode != this.lastAnchorNode || t.anchorOffset != this.lastAnchorOffset || t.focusNode != this.lastFocusNode || t.focusOffset != this.lastFocusOffset }, re.prototype.pollSelection = function () { if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) { var t = this.getSelection(), e = this.cm; if (C && i && this.cm.display.gutterSpecs.length && Ac(t.anchorNode)) { this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus(); return } if (!this.composing) { this.rememberSelection(); var u = ua(e, t.anchorNode, t.anchorOffset), s = ua(e, t.focusNode, t.focusOffset); u && s && He(e, function () { De(e.doc, Vi(u, s), St), (u.bad || s.bad) && (e.curOp.selectionChanged = !0) }) } } }, re.prototype.pollContent = function () { this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); var t = this.cm, e = t.display, u = t.doc.sel.primary(), s = u.from(), g = u.to(); if (s.ch == 0 && s.line > t.firstLine() && (s = Z(s.line - 1, Wt(t.doc, s.line - 1).length)), g.ch == Wt(t.doc, g.line).text.length && g.line < t.lastLine() && (g = Z(g.line + 1, 0)), s.line < e.viewFrom || g.line > e.viewTo - 1) return !1; var A, w, T; s.line == e.viewFrom || (A = tr(t, s.line)) == 0 ? (w = $t(e.view[0].line), T = e.view[0].node) : (w = $t(e.view[A].line), T = e.view[A - 1].node.nextSibling); var B = tr(t, g.line), M, Y; if (B == e.view.length - 1 ? (M = e.viewTo - 1, Y = e.lineDiv.lastChild) : (M = $t(e.view[B + 1].line) - 1, Y = e.view[B + 1].node.previousSibling), !T) return !1; for (var j = t.doc.splitLines(Cc(t, T, Y, w, M)), ot = Si(t.doc, Z(w, 0), Z(M, Wt(t.doc, M).text.length)); j.length > 1 && ot.length > 1;)if (vt(j) == vt(ot)) j.pop(), ot.pop(), M--; else if (j[0] == ot[0]) j.shift(), ot.shift(), w++; else break; for (var nt = 0, Ct = 0, Tt = j[0], Bt = ot[0], Mt = Math.min(Tt.length, Bt.length); nt < Mt && Tt.charCodeAt(nt) == Bt.charCodeAt(nt);)++nt; for (var Pt = vt(j), Ot = vt(ot), Rt = Math.min(Pt.length - (j.length == 1 ? nt : 0), Ot.length - (ot.length == 1 ? nt : 0)); Ct < Rt && Pt.charCodeAt(Pt.length - Ct - 1) == Ot.charCodeAt(Ot.length - Ct - 1);)++Ct; if (j.length == 1 && ot.length == 1 && w == s.line) for (; nt && nt > s.ch && Pt.charCodeAt(Pt.length - Ct - 1) == Ot.charCodeAt(Ot.length - Ct - 1);)nt--, Ct++; j[j.length - 1] = Pt.slice(0, Pt.length - Ct).replace(/^\u200b+/, ""), j[0] = j[0].slice(nt).replace(/\u200b+$/, ""); var Yt = Z(w, nt), Nt = Z(M, ot.length ? vt(ot).length - Ct : 0); if (j.length > 1 || j[0] || At(Yt, Nt)) return Sr(t.doc, j, Yt, Nt, "+input"), !0 }, re.prototype.ensurePolled = function () { this.forceCompositionEnd() }, re.prototype.reset = function () { this.forceCompositionEnd() }, re.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()) }, re.prototype.readFromDOMSoon = function () { var t = this; this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function () { if (t.readDOMTimeout = null, t.composing) if (t.composing.done) t.composing = null; else return; t.updateFromDOM() }, 80)) }, re.prototype.updateFromDOM = function () { var t = this; (this.cm.isReadOnly() || !this.pollContent()) && He(this.cm, function () { return We(t.cm) }) }, re.prototype.setUneditable = function (t) { t.contentEditable = "false" }, re.prototype.onKeyPress = function (t) { t.charCode == 0 || this.composing || (t.preventDefault(), this.cm.isReadOnly() || Te(this.cm, Is)(this.cm, String.fromCharCode(t.charCode == null ? t.keyCode : t.charCode), 0)) }, re.prototype.readOnlyChanged = function (t) { this.div.contentEditable = String(t != "nocursor") }, re.prototype.onContextMenu = function () { }, re.prototype.resetPosition = function () { }, re.prototype.needsContentAttribute = !0; function su(t, e) { var u = qa(t, e.line); if (!u || u.hidden) return null; var s = Wt(t.doc, e.line), g = Fo(u, s, e.line), A = ee(s, t.doc.direction), w = "left"; if (A) { var T = Kt(A, e.ch); w = T % 2 ? "right" : "left" } var B = Qo(g.map, e.ch, w); return B.offset = B.collapse == "right" ? B.end : B.start, B } function Ac(t) { for (var e = t; e; e = e.parentNode)if (/CodeMirror-gutter-wrapper/.test(e.className)) return !0; return !1 } function kr(t, e) { return e && (t.bad = !0), t } function Cc(t, e, u, s, g) { var A = "", w = !1, T = t.doc.lineSeparator(), B = !1; function M(nt) { return function (Ct) { return Ct.id == nt } } function Y() { w && (A += T, B && (A += T), w = B = !1) } function j(nt) { nt && (Y(), A += nt) } function ot(nt) { if (nt.nodeType == 1) { var Ct = nt.getAttribute("cm-text"); if (Ct) { j(Ct); return } var Tt = nt.getAttribute("cm-marker"), Bt; if (Tt) { var Mt = t.findMarks(Z(s, 0), Z(g + 1, 0), M(+Tt)); Mt.length && (Bt = Mt[0].find(0)) && j(Si(t.doc, Bt.from, Bt.to).join(T)); return } if (nt.getAttribute("contenteditable") == "false") return; var Pt = /^(pre|div|p|li|table|br)$/i.test(nt.nodeName); if (!/^br$/i.test(nt.nodeName) && nt.textContent.length == 0) return; Pt && Y(); for (var Ot = 0; Ot < nt.childNodes.length; Ot++)ot(nt.childNodes[Ot]); /^(pre|p)$/i.test(nt.nodeName) && (B = !0), Pt && (w = !0) } else nt.nodeType == 3 && j(nt.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " ")) } for (; ot(e), e != u;)e = e.nextSibling, B = !1; return A } function ua(t, e, u) { var s; if (e == t.display.lineDiv) { if (s = t.display.lineDiv.childNodes[u], !s) return kr(t.clipPos(Z(t.display.viewTo - 1)), !0); e = null, u = 0 } else for (s = e; ; s = s.parentNode) { if (!s || s == t.display.lineDiv) return null; if (s.parentNode && s.parentNode == t.display.lineDiv) break } for (var g = 0; g < t.display.view.length; g++) { var A = t.display.view[g]; if (A.node == s) return bc(A, e, u) } } function bc(t, e, u) { var s = t.text.firstChild, g = !1; if (!e || !it(s, e)) return kr(Z($t(t.line), 0), !0); if (e == s && (g = !0, e = s.childNodes[u], u = 0, !e)) { var A = t.rest ? vt(t.rest) : t.line; return kr(Z($t(A), A.text.length), g) } var w = e.nodeType == 3 ? e : null, T = e; for (!w && e.childNodes.length == 1 && e.firstChild.nodeType == 3 && (w = e.firstChild, u && (u = w.nodeValue.length)); T.parentNode != s;)T = T.parentNode; var B = t.measure, M = B.maps; function Y(Bt, Mt, Pt) { for (var Ot = -1; Ot < (M ? M.length : 0); Ot++)for (var Rt = Ot < 0 ? B.map : M[Ot], Yt = 0; Yt < Rt.length; Yt += 3) { var Nt = Rt[Yt + 2]; if (Nt == Bt || Nt == Mt) { var Xt = $t(Ot < 0 ? t.line : t.rest[Ot]), se = Rt[Yt] + Pt; return (Pt < 0 || Nt != Bt) && (se = Rt[Yt + (Pt ? 1 : 0)]), Z(Xt, se) } } } var j = Y(w, T, u); if (j) return kr(j, g); for (var ot = T.nextSibling, nt = w ? w.nodeValue.length - u : 0; ot; ot = ot.nextSibling) { if (j = Y(ot, ot.firstChild, 0), j) return kr(Z(j.line, j.ch - nt), g); nt += ot.textContent.length } for (var Ct = T.previousSibling, Tt = u; Ct; Ct = Ct.previousSibling) { if (j = Y(Ct, Ct.firstChild, -1), j) return kr(Z(j.line, j.ch + Tt), g); Tt += Ct.textContent.length } } var me = function (t) { this.cm = t, this.prevInput = "", this.pollingFast = !1, this.polling = new ht, this.hasSelection = !1, this.composing = null, this.resetting = !1 }; me.prototype.init = function (t) {
        var e = this, u = this, s = this.cm; this.createField(t); var g = this.textarea; t.wrapper.insertBefore(this.wrapper, t.wrapper.firstChild), y && (g.style.width = "0px"), It(g, "input", function () { a && l >= 9 && e.hasSelection && (e.hasSelection = null), u.poll() }), It(g, "paste", function (w) { oe(s, w) || eu(w, s) || (s.state.pasteIncoming = +new Date, u.fastPoll()) }); function A(w) {
          if (!oe(s, w)) {
            if (s.somethingSelected()) la({ lineWise: !1, text: s.getSelections() }); else if (s.options.lineWiseCopyCut) {
              var T = ru(s); la({ lineWise: !0, text: T.text }), w.type == "cut" ? s.setSelections(T.ranges, null, St) : (u.prevInput = "", g.value = T.text.join(`
`), U(g))
            } else return; w.type == "cut" && (s.state.cutIncoming = +new Date)
          }
        } It(g, "cut", A), It(g, "copy", A), It(t.scroller, "paste", function (w) { if (!(Ii(t, w) || oe(s, w))) { if (!g.dispatchEvent) { s.state.pasteIncoming = +new Date, u.focus(); return } var T = new Event("paste"); T.clipboardData = w.clipboardData, g.dispatchEvent(T) } }), It(t.lineSpace, "selectstart", function (w) { Ii(t, w) || de(w) }), It(g, "compositionstart", function () { var w = s.getCursor("from"); u.composing && u.composing.range.clear(), u.composing = { start: w, range: s.markText(w, s.getCursor("to"), { className: "CodeMirror-composing" }) } }), It(g, "compositionend", function () { u.composing && (u.poll(), u.composing.range.clear(), u.composing = null) })
      }, me.prototype.createField = function (t) { this.wrapper = nu(), this.textarea = this.wrapper.firstChild; var e = this.cm.options; Bs(this.textarea, e.spellcheck, e.autocorrect, e.autocapitalize) }, me.prototype.screenReaderLabelChanged = function (t) { t ? this.textarea.setAttribute("aria-label", t) : this.textarea.removeAttribute("aria-label") }, me.prototype.prepareSelection = function () { var t = this.cm, e = t.display, u = t.doc, s = Ko(t); if (t.options.moveInputWithCursor) { var g = ri(t, u.sel.primary().head, "div"), A = e.wrapper.getBoundingClientRect(), w = e.lineDiv.getBoundingClientRect(); s.teTop = Math.max(0, Math.min(e.wrapper.clientHeight - 10, g.top + w.top - A.top)), s.teLeft = Math.max(0, Math.min(e.wrapper.clientWidth - 10, g.left + w.left - A.left)) } return s }, me.prototype.showSelection = function (t) { var e = this.cm, u = e.display; ct(u.cursorDiv, t.cursors), ct(u.selectionDiv, t.selection), t.teTop != null && (this.wrapper.style.top = t.teTop + "px", this.wrapper.style.left = t.teLeft + "px") }, me.prototype.reset = function (t) { if (!(this.contextMenuPending || this.composing && t)) { var e = this.cm; if (this.resetting = !0, e.somethingSelected()) { this.prevInput = ""; var u = e.getSelection(); this.textarea.value = u, e.state.focused && U(this.textarea), a && l >= 9 && (this.hasSelection = u) } else t || (this.prevInput = this.textarea.value = "", a && l >= 9 && (this.hasSelection = null)); this.resetting = !1 } }, me.prototype.getField = function () { return this.textarea }, me.prototype.supportsTouch = function () { return !1 }, me.prototype.focus = function () { if (this.cm.options.readOnly != "nocursor" && (!x || O(this.textarea.ownerDocument) != this.textarea)) try { this.textarea.focus() } catch { } }, me.prototype.blur = function () { this.textarea.blur() }, me.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0 }, me.prototype.receivedFocus = function () { this.slowPoll() }, me.prototype.slowPoll = function () { var t = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, function () { t.poll(), t.cm.state.focused && t.slowPoll() }) }, me.prototype.fastPoll = function () { var t = !1, e = this; e.pollingFast = !0; function u() { var s = e.poll(); !s && !t ? (t = !0, e.polling.set(60, u)) : (e.pollingFast = !1, e.slowPoll()) } e.polling.set(20, u) }, me.prototype.poll = function () {
        var t = this, e = this.cm, u = this.textarea, s = this.prevInput; if (this.contextMenuPending || this.resetting || !e.state.focused || Fi(u) && !s && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq) return !1; var g = u.value; if (g == s && !e.somethingSelected()) return !1; if (a && l >= 9 && this.hasSelection === g || I && /[\uf700-\uf7ff]/.test(g)) return e.display.input.reset(), !1; if (e.doc.sel == e.display.selForContextMenu) { var A = g.charCodeAt(0); if (A == 8203 && !s && (s = "​"), A == 8666) return this.reset(), this.cm.execCommand("undo") } for (var w = 0, T = Math.min(s.length, g.length); w < T && s.charCodeAt(w) == g.charCodeAt(w);)++w; return He(e, function () {
          Is(e, g.slice(w), s.length - w, null, t.composing ? "*compose" : null), g.length > 1e3 || g.indexOf(`
`) > -1 ? u.value = t.prevInput = "" : t.prevInput = g, t.composing && (t.composing.range.clear(), t.composing.range = e.markText(t.composing.start, e.getCursor("to"), { className: "CodeMirror-composing" }))
        }), !0
      }, me.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, me.prototype.onKeyPress = function () { a && l >= 9 && (this.hasSelection = null), this.fastPoll() }, me.prototype.onContextMenu = function (t) {
        var e = this, u = e.cm, s = u.display, g = e.textarea; e.contextMenuPending && e.contextMenuPending(); var A = $i(u, t), w = s.scroller.scrollTop; if (!A || o) return; var T = u.options.resetSelectionOnContextMenu; T && u.doc.sel.contains(A) == -1 && Te(u, De)(u.doc, Vi(A), St); var B = g.style.cssText, M = e.wrapper.style.cssText, Y = e.wrapper.offsetParent.getBoundingClientRect(); e.wrapper.style.cssText = "position: static", g.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: `+ (t.clientY - Y.top - 5) + "px; left: " + (t.clientX - Y.left - 5) + `px;
      z-index: 1000; background: `+ (a ? "rgba(255, 255, 255, .05)" : "transparent") + `;
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`; var j; c && (j = g.ownerDocument.defaultView.scrollY), s.input.focus(), c && g.ownerDocument.defaultView.scrollTo(null, j), s.input.reset(), u.somethingSelected() || (g.value = e.prevInput = " "), e.contextMenuPending = nt, s.selForContextMenu = u.doc.sel, clearTimeout(s.detectingSelectAll); function ot() { if (g.selectionStart != null) { var Tt = u.somethingSelected(), Bt = "​" + (Tt ? g.value : ""); g.value = "⇚", g.value = Bt, e.prevInput = Tt ? "" : "​", g.selectionStart = 1, g.selectionEnd = Bt.length, s.selForContextMenu = u.doc.sel } } function nt() { if (e.contextMenuPending == nt && (e.contextMenuPending = !1, e.wrapper.style.cssText = M, g.style.cssText = B, a && l < 9 && s.scrollbars.setScrollTop(s.scroller.scrollTop = w), g.selectionStart != null)) { (!a || a && l < 9) && ot(); var Tt = 0, Bt = function () { s.selForContextMenu == u.doc.sel && g.selectionStart == 0 && g.selectionEnd > 0 && e.prevInput == "​" ? Te(u, Sl)(u) : Tt++ < 10 ? s.detectingSelectAll = setTimeout(Bt, 500) : (s.selForContextMenu = null, s.input.reset()) }; s.detectingSelectAll = setTimeout(Bt, 200) } } if (a && l >= 9 && ot(), tt) { wi(t); var Ct = function () { be(window, "mouseup", Ct), setTimeout(nt, 20) }; It(window, "mouseup", Ct) } else setTimeout(nt, 50)
      }, me.prototype.readOnlyChanged = function (t) { t || this.reset(), this.textarea.disabled = t == "nocursor", this.textarea.readOnly = !!t }, me.prototype.setUneditable = function () { }, me.prototype.needsContentAttribute = !1; function wc(t, e) { if (e = e ? K(e) : {}, e.value = t.value, !e.tabindex && t.tabIndex && (e.tabindex = t.tabIndex), !e.placeholder && t.placeholder && (e.placeholder = t.placeholder), e.autofocus == null) { var u = O(t.ownerDocument); e.autofocus = u == t || t.getAttribute("autofocus") != null && u == document.body } function s() { t.value = T.getValue() } var g; if (t.form && (It(t.form, "submit", s), !e.leaveSubmitMethodAlone)) { var A = t.form; g = A.submit; try { var w = A.submit = function () { s(), A.submit = g, A.submit(), A.submit = w } } catch { } } e.finishInit = function (B) { B.save = s, B.getTextArea = function () { return t }, B.toTextArea = function () { B.toTextArea = isNaN, s(), t.parentNode.removeChild(B.getWrapperElement()), t.style.display = "", t.form && (be(t.form, "submit", s), !e.leaveSubmitMethodAlone && typeof t.form.submit == "function" && (t.form.submit = g)) } }, t.style.display = "none"; var T = ue(function (B) { return t.parentNode.insertBefore(B, t.nextSibling) }, e); return T } function xc(t) { t.off = be, t.on = It, t.wheelEventPixels = kh, t.Doc = Ne, t.splitLines = Nr, t.countColumn = J, t.findColumn = wt, t.isWordChar = rt, t.Pass = mt, t.signal = ie, t.Line = gr, t.changeEnd = zi, t.scrollbarModel = el, t.Pos = Z, t.cmpPos = At, t.modes = ei, t.mimeModes = Pi, t.resolveMode = Ue, t.getMode = xi, t.modeExtensions = Ri, t.extendMode = Ln, t.copyState = _i, t.startState = Yr, t.innerMode = Qi, t.commands = hn, t.keyMap = ki, t.keyName = Yl, t.isModifierKey = Wl, t.lookupKey = Er, t.normalizeKeyMap = Zh, t.StringStream = ge, t.SharedTextMarker = ln, t.TextMarker = Hi, t.LineWidget = on, t.e_preventDefault = de, t.e_stopPropagation = fi, t.e_stop = wi, t.addClass = V, t.contains = it, t.rmClass = dt, t.keyNames = Gi } gc(ue), yc(ue); var _c = "iter insert remove copy getEditor constructor".split(" "); for (var fa in Ne.prototype) Ne.prototype.hasOwnProperty(fa) && ut(_c, fa) < 0 && (ue.prototype[fa] = function (t) { return function () { return t.apply(this.doc, arguments) } }(Ne.prototype[fa])); return ve(Ne), ue.inputStyles = { textarea: me, contenteditable: re }, ue.defineMode = function (t) { !ue.defaults.mode && t != "null" && (ue.defaults.mode = t), Dn.apply(this, arguments) }, ue.defineMIME = cr, ue.defineMode("null", function () { return { token: function (t) { return t.skipToEnd() } } }), ue.defineMIME("text/plain", "null"), ue.defineExtension = function (t, e) { ue.prototype[t] = e }, ue.defineDocExtension = function (t, e) { Ne.prototype[t] = e }, ue.fromTextArea = wc, xc(ue), ue.version = "5.65.14", ue
    })
  }(Qs)), Qs.exports
} var u0 = kn(); const wf = Qu(u0); (function (v, h) {
  (function (b) { b(kn()) })(function (b) {
    var E = b.Pos, k = "http://www.w3.org/2000/svg"; function _(L, N) { this.mv = L, this.type = N, this.classes = N == "left" ? { chunk: "CodeMirror-merge-l-chunk", start: "CodeMirror-merge-l-chunk-start", end: "CodeMirror-merge-l-chunk-end", insert: "CodeMirror-merge-l-inserted", del: "CodeMirror-merge-l-deleted", connect: "CodeMirror-merge-l-connect" } : { chunk: "CodeMirror-merge-r-chunk", start: "CodeMirror-merge-r-chunk-start", end: "CodeMirror-merge-r-chunk-end", insert: "CodeMirror-merge-r-inserted", del: "CodeMirror-merge-r-deleted", connect: "CodeMirror-merge-r-connect" } } _.prototype = { constructor: _, init: function (L, N, Q) { this.edit = this.mv.edit, (this.edit.state.diffViews || (this.edit.state.diffViews = [])).push(this), this.orig = b(L, ht({ value: N, readOnly: !this.mv.options.allowEditingOriginals }, ht(Q))), this.mv.options.connect == "align" && (this.edit.state.trackAlignable || (this.edit.state.trackAlignable = new gt(this.edit)), this.orig.state.trackAlignable = new gt(this.orig)), this.lockButton.title = this.edit.phrase("Toggle locked scrolling"), this.lockButton.setAttribute("aria-label", this.lockButton.title), this.orig.state.diffViews = [this]; var $ = Q.chunkClassLocation || "background"; Object.prototype.toString.call($) != "[object Array]" && ($ = [$]), this.classes.classLocation = $, this.diff = Dt(ct(N), ct(Q.value), this.mv.options.ignoreWhitespace), this.chunks = Lt(this.diff), this.diffOutOfDate = this.dealigned = !1, this.needsScrollSync = null, this.showDifferences = Q.showDifferences !== !1 }, registerEvents: function (L) { this.forceUpdate = a(this), i(this, !0, !1), l(this, L) }, setShowDifferences: function (L) { L = L !== !1, L != this.showDifferences && (this.showDifferences = L, this.forceUpdate("full")) } }; function S(L) { L.diffOutOfDate && (L.diff = Dt(L.orig.getValue(), L.edit.getValue(), L.mv.options.ignoreWhitespace), L.chunks = Lt(L.diff), L.diffOutOfDate = !1, b.signal(L.edit, "updateDiff", L.diff)) } var d = !1; function a(L) { var N = { from: 0, to: 0, marked: [] }, Q = { from: 0, to: 0, marked: [] }, $, rt = !1; function at(Qt) { d = !0, rt = !1, Qt == "full" && (L.svg && K(L.svg), L.copyButtons && K(L.copyButtons), o(L.edit, N.marked, L.classes), o(L.orig, Q.marked, L.classes), N.from = N.to = Q.from = Q.to = 0), S(L), L.showDifferences && (p(L.edit, L.diff, N, DIFF_INSERT, L.classes), p(L.orig, L.diff, Q, DIFF_DELETE, L.classes)), L.mv.options.connect == "align" && P(L), y(L), L.needsScrollSync != null && c(L, L.needsScrollSync), d = !1 } function yt(Qt) { d || (L.dealigned = !0, bt(Qt)) } function bt(Qt) { d || rt || (clearTimeout($), Qt === !0 && (rt = !0), $ = setTimeout(at, Qt === !0 ? 20 : 250)) } function Et(Qt, jt) { L.diffOutOfDate || (L.diffOutOfDate = !0, N.from = N.to = Q.from = Q.to = 0), yt(jt.text.length - 1 != jt.to.line - jt.from.line) } function Ft() { L.diffOutOfDate = !0, L.dealigned = !0, at("full") } return L.edit.on("change", Et), L.orig.on("change", Et), L.edit.on("swapDoc", Ft), L.orig.on("swapDoc", Ft), L.mv.options.connect == "align" && (b.on(L.edit.state.trackAlignable, "realign", yt), b.on(L.orig.state.trackAlignable, "realign", yt)), L.edit.on("viewportChange", function () { bt(!1) }), L.orig.on("viewportChange", function () { bt(!1) }), at(), at } function l(L, N) { L.edit.on("scroll", function () { c(L, !0) && y(L) }), L.orig.on("scroll", function () { c(L, !1) && y(L), N && c(N, !0) && y(N) }) } function c(L, N) { if (L.diffOutOfDate) return L.lockScroll && L.needsScrollSync == null && (L.needsScrollSync = N), !1; if (L.needsScrollSync = null, !L.lockScroll) return !0; var Q, $, rt = +new Date; if (N ? (Q = L.edit, $ = L.orig) : (Q = L.orig, $ = L.edit), Q.state.scrollSetBy == L && (Q.state.scrollSetAt || 0) + 250 > rt) return !1; var at = Q.getScrollInfo(); if (L.mv.options.connect == "align") Kt = at.top; else { var yt = .5 * at.clientHeight, bt = at.top + yt, Et = Q.lineAtHeight(bt, "local"), Ft = V(L.chunks, Et, N), Qt = r(Q, N ? Ft.edit : Ft.orig), jt = r($, N ? Ft.orig : Ft.edit), Gt = (bt - Qt.top) / (Qt.bot - Qt.top), Kt = jt.top - yt + Gt * (jt.bot - jt.top), ae, ee; if (Kt > at.top && (ee = at.top / yt) < 1) Kt = Kt * ee + at.top * (1 - ee); else if ((ae = at.height - at.clientHeight - at.top) < yt) { var ke = $.getScrollInfo(), It = ke.height - ke.clientHeight - Kt; It > ae && (ee = ae / yt) < 1 && (Kt = Kt * ee + (ke.height - ke.clientHeight - ae) * (1 - ee)) } } return $.scrollTo(at.left, Kt), $.state.scrollSetAt = rt, $.state.scrollSetBy = L, !0 } function r(L, N) { var Q = N.after; return Q == null && (Q = L.lastLine() + 1), { top: L.heightAtLine(N.before || 0, "local"), bot: L.heightAtLine(Q, "local") } } function i(L, N, Q) { L.lockScroll = N, N && Q != !1 && c(L, DIFF_INSERT) && y(L), (N ? b.addClass : b.rmClass)(L.lockButton, "CodeMirror-merge-scrolllock-enabled") } function n(L, N, Q) { for (var $ = Q.classLocation, rt = 0; rt < $.length; rt++)L.removeLineClass(N, $[rt], Q.chunk), L.removeLineClass(N, $[rt], Q.start), L.removeLineClass(N, $[rt], Q.end) } function o(L, N, Q) { for (var $ = 0; $ < N.length; ++$) { var rt = N[$]; rt instanceof b.TextMarker ? rt.clear() : rt.parent && n(L, rt, Q) } N.length = 0 } function p(L, N, Q, $, rt) { var at = L.getViewport(); L.operation(function () { Q.from == Q.to || at.from - Q.to > 20 || Q.from - at.to > 20 ? (o(L, Q.marked, rt), m(L, N, $, Q.marked, at.from, at.to, rt), Q.from = at.from, Q.to = at.to) : (at.from < Q.from && (m(L, N, $, Q.marked, at.from, Q.from, rt), Q.from = at.from), at.to > Q.to && (m(L, N, $, Q.marked, Q.to, at.to, rt), Q.to = at.to)) }) } function f(L, N, Q, $, rt, at) { for (var yt = Q.classLocation, bt = L.getLineHandle(N), Et = 0; Et < yt.length; Et++)$ && L.addLineClass(bt, yt[Et], Q.chunk), rt && L.addLineClass(bt, yt[Et], Q.start), at && L.addLineClass(bt, yt[Et], Q.end); return bt } function m(L, N, Q, $, rt, at, yt) { var bt = E(0, 0), Et = E(rt, 0), Ft = L.clipPos(E(at - 1)), Qt = Q == DIFF_DELETE ? yt.del : yt.insert; function jt(we, ve) { for (var de = Math.max(rt, we), fi = Math.min(at, ve), ti = de; ti < fi; ++ti)$.push(f(L, ti, yt, !0, ti == we, ti == ve - 1)); we == ve && de == ve && fi == ve && (de ? $.push(f(L, de - 1, yt, !1, !1, !0)) : $.push(f(L, de, yt, !1, !0, !1))) } for (var Gt = 0, Kt = !1, ae = 0; ae < N.length; ++ae) { var ee = N[ae], ke = ee[0], It = ee[1]; if (ke == DIFF_EQUAL) { var Li = bt.line + (O(N, ae) ? 0 : 1); ut(bt, It); var be = bt.line + (it(N, ae) ? 1 : 0); be > Li && (Kt && (jt(Gt, Li), Kt = !1), Gt = be) } else if (Kt = !0, ke == Q) { var ie = ut(bt, It, !0), oe = wt(Et, bt), qi = ft(Ft, ie); xt(oe, qi) || $.push(L.markText(oe, qi, { className: Qt })), bt = ie } } Kt && jt(Gt, bt.line + 1) } function y(L) { if (L.showDifferences) { if (L.svg) { K(L.svg); var N = L.gap.offsetWidth; J(L.svg, "width", N, "height", L.gap.offsetHeight) } L.copyButtons && K(L.copyButtons); for (var Q = L.edit.getViewport(), $ = L.orig.getViewport(), rt = L.mv.wrap.getBoundingClientRect().top, at = rt - L.edit.getScrollerElement().getBoundingClientRect().top + L.edit.getScrollInfo().top, yt = rt - L.orig.getScrollerElement().getBoundingClientRect().top + L.orig.getScrollInfo().top, bt = 0; bt < L.chunks.length; bt++) { var Et = L.chunks[bt]; Et.editFrom <= Q.to && Et.editTo >= Q.from && Et.origFrom <= $.to && Et.origTo >= $.from && tt(L, Et, yt, at, N) } } } function C(L, N) { for (var Q = 0, $ = 0, rt = 0; rt < N.length; rt++) { var at = N[rt]; if (at.editTo > L && at.editFrom <= L) return null; if (at.editFrom > L) break; Q = at.editTo, $ = at.origTo } return $ + (L - Q) } function x(L, N, Q) { for (var $ = L.state.trackAlignable, rt = L.firstLine(), at = 0, yt = [], bt = 0; ; bt++) { for (var Et = N[bt], Ft = Et ? Q ? Et.origFrom : Et.editFrom : 1e9; at < $.alignable.length; at += 2) { var Qt = $.alignable[at] + 1; if (!(Qt <= rt)) if (Qt <= Ft) yt.push(Qt); else break } if (!Et) break; yt.push(rt = Q ? Et.origTo : Et.editTo) } return yt } function I(L, N, Q, $) { var rt = 0, at = 0, yt = 0, bt = 0; t: for (; ; rt++) { var Et = L[rt], Ft = N[at]; if (!Et && Ft == null) break; for (var Qt = Et ? Et[0] : 1e9, jt = Ft ?? 1e9; yt < Q.length;) { var Gt = Q[yt]; if (Gt.origFrom <= jt && Gt.origTo > jt) { at++, rt--; continue t } if (Gt.editTo > Qt) { if (Gt.editFrom <= Qt) continue t; break } bt += Gt.origTo - Gt.origFrom - (Gt.editTo - Gt.editFrom), yt++ } if (Qt == jt - bt) Et[$] = jt, at++; else if (Qt < jt - bt) Et[$] = Qt + bt; else { var Kt = [jt - bt, null, null]; Kt[$] = jt, L.splice(rt, 0, Kt), at++ } } } function D(L, N) { var Q = x(L.edit, L.chunks, !1), $ = []; if (N) for (var rt = 0, at = 0; rt < N.chunks.length; rt++) { for (var yt = N.chunks[rt].editTo; at < Q.length && Q[at] < yt;)at++; (at == Q.length || Q[at] != yt) && Q.splice(at++, 0, yt) } for (var rt = 0; rt < Q.length; rt++)$.push([Q[rt], null, null]); return I($, x(L.orig, L.chunks, !0), L.chunks, 1), N && I($, x(N.orig, N.chunks, !0), N.chunks, 2), $ } function P(L, N) { if (!(!L.dealigned && !N)) { if (!L.orig.curOp) return L.orig.operation(function () { P(L, N) }); L.dealigned = !1; var Q = L.mv.left == L ? L.mv.right : L.mv.left; Q && (S(Q), Q.dealigned = !1); for (var $ = D(L, Q), rt = L.mv.aligners, at = 0; at < rt.length; at++)rt[at].clear(); rt.length = 0; var yt = [L.edit, L.orig], bt = [], Et = []; Q && yt.push(Q.orig); for (var at = 0; at < yt.length; at++)bt.push(yt[at].getScrollInfo().top), Et.push(-yt[at].getScrollerElement().getBoundingClientRect().top); (Et[0] != Et[1] || yt.length == 3 && Et[1] != Et[2]) && z(yt, Et, [0, 0, 0], rt); for (var Ft = 0; Ft < $.length; Ft++)z(yt, Et, $[Ft], rt); for (var at = 0; at < yt.length; at++)yt[at].scrollTo(null, bt[at]) } } function z(L, N, Q, $) { for (var rt = -1e8, at = [], yt = 0; yt < L.length; yt++)if (Q[yt] != null) { var bt = L[yt].heightAtLine(Q[yt], "local") - N[yt]; at[yt] = bt, rt = Math.max(rt, bt) } for (var yt = 0; yt < L.length; yt++)if (Q[yt] != null) { var Et = rt - at[yt]; Et > 1 && $.push(et(L[yt], Q[yt], Et)) } } function et(L, N, Q) { var $ = !0; N > L.lastLine() && (N--, $ = !1); var rt = document.createElement("div"); return rt.className = "CodeMirror-merge-spacer", rt.style.height = Q + "px", rt.style.minWidth = "1px", L.addLineWidget(N, rt, { height: Q, above: $, mergeSpacer: !0, handleMouseEvents: !0 }) } function tt(L, N, Q, $, rt) { var at = L.type == "left", yt = L.orig.heightAtLine(N.origFrom, "local", !0) - Q; if (L.svg) { var bt = yt, Et = L.edit.heightAtLine(N.editFrom, "local", !0) - $; if (at) { var Ft = bt; bt = Et, Et = Ft } var Qt = L.orig.heightAtLine(N.origTo, "local", !0) - Q, jt = L.edit.heightAtLine(N.editTo, "local", !0) - $; if (at) { var Ft = Qt; Qt = jt, jt = Ft } var Gt = " C " + rt / 2 + " " + Et + " " + rt / 2 + " " + bt + " " + (rt + 2) + " " + bt, Kt = " C " + rt / 2 + " " + Qt + " " + rt / 2 + " " + jt + " -1 " + jt; J(L.svg.appendChild(document.createElementNS(k, "path")), "d", "M -1 " + Et + Gt + " L " + (rt + 2) + " " + Qt + Kt + " z", "class", L.classes.connect) } if (L.copyButtons) { var ae = L.copyButtons.appendChild(R("div", L.type == "left" ? "⇝" : "⇜", "CodeMirror-merge-copy")), ee = L.mv.options.allowEditingOriginals; if (ae.title = L.edit.phrase(ee ? "Push to left" : "Revert chunk"), ae.chunk = N, ae.style.top = (N.origTo > N.origFrom ? yt : L.edit.heightAtLine(N.editFrom, "local") - $) + "px", ae.setAttribute("role", "button"), ae.setAttribute("tabindex", "0"), ae.setAttribute("aria-label", ae.title), ee) { var ke = L.edit.heightAtLine(N.editFrom, "local") - $, It = L.copyButtons.appendChild(R("div", L.type == "right" ? "⇝" : "⇜", "CodeMirror-merge-copy-reverse")); It.title = "Push to right", It.chunk = { editFrom: N.origFrom, editTo: N.origTo, origFrom: N.editFrom, origTo: N.editTo }, It.style.top = ke + "px", L.type == "right" ? It.style.left = "2px" : It.style.right = "2px", It.setAttribute("role", "button"), It.setAttribute("tabindex", "0"), It.setAttribute("aria-label", It.title) } } } function st(L, N, Q, $) { if (!L.diffOutOfDate) { var rt = $.origTo > Q.lastLine() ? E($.origFrom - 1) : E($.origFrom, 0), at = E($.origTo, 0), yt = $.editTo > N.lastLine() ? E($.editFrom - 1) : E($.editFrom, 0), bt = E($.editTo, 0), Et = L.mv.options.revertChunk; Et ? Et(L.mv, Q, rt, at, N, yt, bt) : N.replaceRange(Q.getRange(rt, at), yt, bt) } } var dt = b.MergeView = function (L, N) { if (!(this instanceof dt)) return new dt(L, N); this.options = N; var Q = N.origLeft, $ = N.origRight == null ? N.orig : N.origRight, rt = Q != null, at = $ != null, yt = 1 + (rt ? 1 : 0) + (at ? 1 : 0), bt = [], Et = this.left = null, Ft = this.right = null, Qt = this; if (rt) { Et = this.left = new _(this, "left"); var jt = R("div", null, "CodeMirror-merge-pane CodeMirror-merge-left"); bt.push(jt), bt.push(q(Et)) } var Gt = R("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor"); if (bt.push(Gt), at) { Ft = this.right = new _(this, "right"), bt.push(q(Ft)); var Kt = R("div", null, "CodeMirror-merge-pane CodeMirror-merge-right"); bt.push(Kt) } (at ? Kt : Gt).className += " CodeMirror-merge-pane-rightmost", bt.push(R("div", null, null, "height: 0; clear: both;")); var ae = this.wrap = L.appendChild(R("div", bt, "CodeMirror-merge CodeMirror-merge-" + yt + "pane")); this.edit = b(Gt, ht(N)), Et && Et.init(jt, Q, N), Ft && Ft.init(Kt, $, N), N.collapseIdentical && this.editor().operation(function () { H(Qt, N.collapseIdentical) }), N.connect == "align" && (this.aligners = [], P(this.left || this.right, !0)), Et && Et.registerEvents(Ft), Ft && Ft.registerEvents(Et); var ee = function () { Et && y(Et), Ft && y(Ft) }; b.on(window, "resize", ee); var ke = setInterval(function () { for (var It = ae.parentNode; It && It != document.body; It = It.parentNode); It || (clearInterval(ke), b.off(window, "resize", ee)) }, 5e3) }; function q(L) { var N = L.lockButton = R("div", null, "CodeMirror-merge-scrolllock"); N.setAttribute("role", "button"), N.setAttribute("tabindex", "0"); var Q = R("div", [N], "CodeMirror-merge-scrolllock-wrap"); b.on(N, "click", function () { i(L, !L.lockScroll) }), b.on(N, "keyup", function (yt) { (yt.key === "Enter" || yt.code === "Space") && i(L, !L.lockScroll) }); var $ = [Q]; if (L.mv.options.revertButtons !== !1) { L.copyButtons = R("div", null, "CodeMirror-merge-copybuttons-" + L.type); var rt = function (yt) { var bt = yt.target || yt.srcElement; if (bt.chunk) { if (bt.className == "CodeMirror-merge-copy-reverse") { st(L, L.orig, L.edit, bt.chunk); return } st(L, L.edit, L.orig, bt.chunk) } }; b.on(L.copyButtons, "click", rt), b.on(L.copyButtons, "keyup", function (yt) { (yt.key === "Enter" || yt.code === "Space") && rt(yt) }), $.unshift(L.copyButtons) } if (L.mv.options.connect != "align") { var at = document.createElementNS && document.createElementNS(k, "svg"); at && !at.createSVGRect && (at = null), L.svg = at, at && $.push(at) } return L.gap = R("div", $, "CodeMirror-merge-gap") } dt.prototype = { constructor: dt, editor: function () { return this.edit }, rightOriginal: function () { return this.right && this.right.orig }, leftOriginal: function () { return this.left && this.left.orig }, setShowDifferences: function (L) { this.right && this.right.setShowDifferences(L), this.left && this.left.setShowDifferences(L) }, rightChunks: function () { if (this.right) return S(this.right), this.right.chunks }, leftChunks: function () { if (this.left) return S(this.left), this.left.chunks } }; function ct(L) { return typeof L == "string" ? L : L.getValue() } var W; function Dt(L, N, Q) { W || (W = new diff_match_patch); for (var $ = W.diff_main(L, N), rt = 0; rt < $.length; ++rt) { var at = $[rt]; (Q ? !/[^ \t]/.test(at[1]) : !at[1]) ? $.splice(rt--, 1) : rt && $[rt - 1][0] == at[0] && ($.splice(rt--, 1), $[rt][1] += at[1]) } return $ } function Lt(L) { var N = []; if (!L.length) return N; for (var Q = 0, $ = 0, rt = E(0, 0), at = E(0, 0), yt = 0; yt < L.length; ++yt) { var bt = L[yt], Et = bt[0]; if (Et == DIFF_EQUAL) { var Ft = !O(L, yt) || rt.line < Q || at.line < $ ? 1 : 0, Qt = rt.line + Ft, jt = at.line + Ft; ut(rt, bt[1], null, at); var Gt = it(L, yt) ? 1 : 0, Kt = rt.line + Gt, ae = at.line + Gt; Kt > Qt && (yt && N.push({ origFrom: $, origTo: jt, editFrom: Q, editTo: Qt }), Q = Kt, $ = ae) } else ut(Et == DIFF_INSERT ? rt : at, bt[1]) } return (Q <= rt.line || $ <= at.line) && N.push({ origFrom: $, origTo: at.line + 1, editFrom: Q, editTo: rt.line + 1 }), N } function it(L, N) { if (N == L.length - 1) return !0; var Q = L[N + 1][1]; return Q.length == 1 && N < L.length - 2 || Q.charCodeAt(0) != 10 ? !1 : N == L.length - 2 ? !0 : (Q = L[N + 2][1], (Q.length > 1 || N == L.length - 3) && Q.charCodeAt(0) == 10) } function O(L, N) { if (N == 0) return !0; var Q = L[N - 1][1]; return Q.charCodeAt(Q.length - 1) != 10 ? !1 : N == 1 ? !0 : (Q = L[N - 2][1], Q.charCodeAt(Q.length - 1) == 10) } function V(L, N, Q) { for (var $, rt, at, yt, bt = 0; bt < L.length; bt++) { var Et = L[bt], Ft = Q ? Et.editFrom : Et.origFrom, Qt = Q ? Et.editTo : Et.origTo; rt == null && (Ft > N ? (rt = Et.editFrom, yt = Et.origFrom) : Qt > N && (rt = Et.editTo, yt = Et.origTo)), Qt <= N ? ($ = Et.editTo, at = Et.origTo) : Ft <= N && ($ = Et.editFrom, at = Et.origFrom) } return { edit: { before: $, after: rt }, orig: { before: at, after: yt } } } function G(L, N, Q) { L.addLineClass(N, "wrap", "CodeMirror-merge-collapsed-line"); var $ = document.createElement("span"); $.className = "CodeMirror-merge-collapsed-widget", $.title = L.phrase("Identical text collapsed. Click to expand."); var rt = L.markText(E(N, 0), E(Q - 1), { inclusiveLeft: !0, inclusiveRight: !0, replacedWith: $, clearOnEnter: !0 }); function at() { rt.clear(), L.removeLineClass(N, "wrap", "CodeMirror-merge-collapsed-line") } return rt.explicitlyCleared && at(), b.on($, "click", at), rt.on("clear", at), b.on($, "click", at), { mark: rt, clear: at } } function U(L, N) { var Q = []; function $() { for (var bt = 0; bt < Q.length; bt++)Q[bt].clear() } for (var rt = 0; rt < N.length; rt++) { var at = N[rt], yt = G(at.cm, at.line, at.line + L); Q.push(yt), yt.mark.on("clear", $) } return Q[0].mark } function lt(L, N, Q, $) { for (var rt = 0; rt < L.chunks.length; rt++)for (var at = L.chunks[rt], yt = at.editFrom - N; yt < at.editTo + N; yt++) { var bt = yt + Q; bt >= 0 && bt < $.length && ($[bt] = !1) } } function H(L, N) { typeof N != "number" && (N = 2); for (var Q = [], $ = L.editor(), rt = $.firstLine(), at = rt, yt = $.lastLine(); at <= yt; at++)Q.push(!0); L.left && lt(L.left, N, rt, Q), L.right && lt(L.right, N, rt, Q); for (var bt = 0; bt < Q.length; bt++)if (Q[bt]) { for (var Et = bt + rt, Ft = 1; bt < Q.length - 1 && Q[bt + 1]; bt++, Ft++); if (Ft > N) { var Qt = [{ line: Et, cm: $ }]; L.left && Qt.push({ line: C(Et, L.left.chunks), cm: L.left.orig }), L.right && Qt.push({ line: C(Et, L.right.chunks), cm: L.right.orig }); var jt = U(Ft, Qt); L.options.onCollapse && L.options.onCollapse(L, Et, Ft, jt) } } } function R(L, N, Q, $) { var rt = document.createElement(L); if (Q && (rt.className = Q), $ && (rt.style.cssText = $), typeof N == "string") rt.appendChild(document.createTextNode(N)); else if (N) for (var at = 0; at < N.length; ++at)rt.appendChild(N[at]); return rt } function K(L) { for (var N = L.childNodes.length; N > 0; --N)L.removeChild(L.firstChild) } function J(L) { for (var N = 1; N < arguments.length; N += 2)L.setAttribute(arguments[N], arguments[N + 1]) } function ht(L, N) { N || (N = {}); for (var Q in L) L.hasOwnProperty(Q) && (N[Q] = L[Q]); return N } function ut(L, N, Q, $) {
      for (var rt = Q ? E(L.line, L.ch) : L, at = 0; ;) {
        var yt = N.indexOf(`
`, at); if (yt == -1) break; ++rt.line, $ && ++$.line, at = yt + 1
      } return rt.ch = (at ? 0 : rt.ch) + (N.length - at), $ && ($.ch = (at ? 0 : $.ch) + (N.length - at)), rt
    } var _t = 1, mt = 2, St = 4; function gt(L) { this.cm = L, this.alignable = [], this.height = L.doc.height; var N = this; L.on("markerAdded", function (Q, $) { if ($.collapsed) { var rt = $.find(1); rt != null && N.set(rt.line, St) } }), L.on("markerCleared", function (Q, $, rt, at) { at != null && $.collapsed && N.check(at, St, N.hasMarker) }), L.on("markerChanged", this.signal.bind(this)), L.on("lineWidgetAdded", function (Q, $, rt) { $.mergeSpacer || ($.above ? N.set(rt - 1, mt) : N.set(rt, _t)) }), L.on("lineWidgetCleared", function (Q, $, rt) { $.mergeSpacer || ($.above ? N.check(rt - 1, mt, N.hasWidgetBelow) : N.check(rt, _t, N.hasWidget)) }), L.on("lineWidgetChanged", this.signal.bind(this)), L.on("change", function (Q, $) { var rt = $.from.line, at = $.to.line - $.from.line, yt = $.text.length - 1, bt = rt + yt; (at || yt) && N.map(rt, at, yt), N.check(bt, St, N.hasMarker), (at || yt) && N.check($.from.line, St, N.hasMarker) }), L.on("viewportChange", function () { N.cm.doc.height != N.height && N.signal() }) } gt.prototype = { signal: function () { b.signal(this, "realign"), this.height = this.cm.doc.height }, set: function (L, N) { for (var Q = -1; Q < this.alignable.length; Q += 2) { var $ = this.alignable[Q] - L; if ($ == 0) { if ((this.alignable[Q + 1] & N) == N) return; this.alignable[Q + 1] |= N, this.signal(); return } if ($ > 0) break } this.signal(), this.alignable.splice(Q, 0, L, N) }, find: function (L) { for (var N = 0; N < this.alignable.length; N += 2)if (this.alignable[N] == L) return N; return -1 }, check: function (L, N, Q) { var $ = this.find(L); if (!($ == -1 || !(this.alignable[$ + 1] & N)) && !Q.call(this, L)) { this.signal(); var rt = this.alignable[$ + 1] & ~N; rt ? this.alignable[$ + 1] = rt : this.alignable.splice($, 2) } }, hasMarker: function (L) { var N = this.cm.getLineHandle(L); if (N.markedSpans) { for (var Q = 0; Q < N.markedSpans.length; Q++)if (N.markedSpans[Q].marker.collapsed && N.markedSpans[Q].to != null) return !0 } return !1 }, hasWidget: function (L) { var N = this.cm.getLineHandle(L); if (N.widgets) { for (var Q = 0; Q < N.widgets.length; Q++)if (!N.widgets[Q].above && !N.widgets[Q].mergeSpacer) return !0 } return !1 }, hasWidgetBelow: function (L) { if (L == this.cm.lastLine()) return !1; var N = this.cm.getLineHandle(L + 1); if (N.widgets) { for (var Q = 0; Q < N.widgets.length; Q++)if (N.widgets[Q].above && !N.widgets[Q].mergeSpacer) return !0 } return !1 }, map: function (L, N, Q) { for (var $ = Q - N, rt = L + N, at = -1, yt = -1, bt = 0; bt < this.alignable.length; bt += 2) { var Et = this.alignable[bt]; Et == L && this.alignable[bt + 1] & mt && (at = bt), Et == rt && this.alignable[bt + 1] & mt && (yt = bt), !(Et <= L) && (Et < rt ? this.alignable.splice(bt--, 2) : this.alignable[bt] += $) } if (at > -1) { var Ft = this.alignable[at + 1]; Ft == mt ? this.alignable.splice(at, 2) : this.alignable[at + 1] = Ft & ~mt } yt > -1 && Q && this.set(L + Q, mt) } }; function ft(L, N) { return (L.line - N.line || L.ch - N.ch) < 0 ? L : N } function wt(L, N) { return (L.line - N.line || L.ch - N.ch) > 0 ? L : N } function xt(L, N) { return L.line == N.line && L.ch == N.ch } function pt(L, N, Q) { for (var $ = L.length - 1; $ >= 0; $--) { var rt = L[$], at = (Q ? rt.origTo : rt.editTo) - 1; if (at < N) return at } } function vt(L, N, Q) { for (var $ = 0; $ < L.length; $++) { var rt = L[$], at = Q ? rt.origFrom : rt.editFrom; if (at > N) return at } } function kt(L, N) { var Q = null, $ = L.state.diffViews, rt = L.getCursor().line; if ($) for (var at = 0; at < $.length; at++) { var yt = $[at], bt = L == yt.orig; S(yt); var Et = N < 0 ? pt(yt.chunks, rt, bt) : vt(yt.chunks, rt, bt); Et != null && (Q == null || (N < 0 ? Et > Q : Et < Q)) && (Q = Et) } if (Q != null) L.setCursor(Q, 0); else return b.Pass } b.commands.goNextDiff = function (L) { return kt(L, 1) }, b.commands.goPrevDiff = function (L) { return kt(L, -1) }
  })
})(); var xf = { exports: {} }; (function (v) {
  var h = function () { this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = .5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = .5, this.Patch_Margin = 4, this.Match_MaxBits = 32 }, b = -1, E = 1, k = 0; h.Diff = function (_, S) { return [_, S] }, h.prototype.diff_main = function (_, S, d, a) { typeof a > "u" && (this.Diff_Timeout <= 0 ? a = Number.MAX_VALUE : a = new Date().getTime() + this.Diff_Timeout * 1e3); var l = a; if (_ == null || S == null) throw new Error("Null input. (diff_main)"); if (_ == S) return _ ? [new h.Diff(k, _)] : []; typeof d > "u" && (d = !0); var c = d, r = this.diff_commonPrefix(_, S), i = _.substring(0, r); _ = _.substring(r), S = S.substring(r), r = this.diff_commonSuffix(_, S); var n = _.substring(_.length - r); _ = _.substring(0, _.length - r), S = S.substring(0, S.length - r); var o = this.diff_compute_(_, S, c, l); return i && o.unshift(new h.Diff(k, i)), n && o.push(new h.Diff(k, n)), this.diff_cleanupMerge(o), o }, h.prototype.diff_compute_ = function (_, S, d, a) { var l; if (!_) return [new h.Diff(E, S)]; if (!S) return [new h.Diff(b, _)]; var c = _.length > S.length ? _ : S, r = _.length > S.length ? S : _, i = c.indexOf(r); if (i != -1) return l = [new h.Diff(E, c.substring(0, i)), new h.Diff(k, r), new h.Diff(E, c.substring(i + r.length))], _.length > S.length && (l[0][0] = l[2][0] = b), l; if (r.length == 1) return [new h.Diff(b, _), new h.Diff(E, S)]; var n = this.diff_halfMatch_(_, S); if (n) { var o = n[0], p = n[1], f = n[2], m = n[3], y = n[4], C = this.diff_main(o, f, d, a), x = this.diff_main(p, m, d, a); return C.concat([new h.Diff(k, y)], x) } return d && _.length > 100 && S.length > 100 ? this.diff_lineMode_(_, S, a) : this.diff_bisect_(_, S, a) }, h.prototype.diff_lineMode_ = function (_, S, d) { var a = this.diff_linesToChars_(_, S); _ = a.chars1, S = a.chars2; var l = a.lineArray, c = this.diff_main(_, S, !1, d); this.diff_charsToLines_(c, l), this.diff_cleanupSemantic(c), c.push(new h.Diff(k, "")); for (var r = 0, i = 0, n = 0, o = "", p = ""; r < c.length;) { switch (c[r][0]) { case E: n++, p += c[r][1]; break; case b: i++, o += c[r][1]; break; case k: if (i >= 1 && n >= 1) { c.splice(r - i - n, i + n), r = r - i - n; for (var f = this.diff_main(o, p, !1, d), m = f.length - 1; m >= 0; m--)c.splice(r, 0, f[m]); r = r + f.length } n = 0, i = 0, o = "", p = ""; break }r++ } return c.pop(), c }, h.prototype.diff_bisect_ = function (_, S, d) { for (var a = _.length, l = S.length, c = Math.ceil((a + l) / 2), r = c, i = 2 * c, n = new Array(i), o = new Array(i), p = 0; p < i; p++)n[p] = -1, o[p] = -1; n[r + 1] = 0, o[r + 1] = 0; for (var f = a - l, m = f % 2 != 0, y = 0, C = 0, x = 0, I = 0, D = 0; D < c && !(new Date().getTime() > d); D++) { for (var P = -D + y; P <= D - C; P += 2) { var z = r + P, et; P == -D || P != D && n[z - 1] < n[z + 1] ? et = n[z + 1] : et = n[z - 1] + 1; for (var tt = et - P; et < a && tt < l && _.charAt(et) == S.charAt(tt);)et++, tt++; if (n[z] = et, et > a) C += 2; else if (tt > l) y += 2; else if (m) { var st = r + f - P; if (st >= 0 && st < i && o[st] != -1) { var dt = a - o[st]; if (et >= dt) return this.diff_bisectSplit_(_, S, et, tt, d) } } } for (var q = -D + x; q <= D - I; q += 2) { var st = r + q, dt; q == -D || q != D && o[st - 1] < o[st + 1] ? dt = o[st + 1] : dt = o[st - 1] + 1; for (var ct = dt - q; dt < a && ct < l && _.charAt(a - dt - 1) == S.charAt(l - ct - 1);)dt++, ct++; if (o[st] = dt, dt > a) I += 2; else if (ct > l) x += 2; else if (!m) { var z = r + f - q; if (z >= 0 && z < i && n[z] != -1) { var et = n[z], tt = r + et - z; if (dt = a - dt, et >= dt) return this.diff_bisectSplit_(_, S, et, tt, d) } } } } return [new h.Diff(b, _), new h.Diff(E, S)] }, h.prototype.diff_bisectSplit_ = function (_, S, d, a, l) { var c = _.substring(0, d), r = S.substring(0, a), i = _.substring(d), n = S.substring(a), o = this.diff_main(c, r, !1, l), p = this.diff_main(i, n, !1, l); return o.concat(p) }, h.prototype.diff_linesToChars_ = function (_, S) {
    var d = [], a = {}; d[0] = ""; function l(n) {
      for (var o = "", p = 0, f = -1, m = d.length; f < n.length - 1;) {
        f = n.indexOf(`
`, p), f == -1 && (f = n.length - 1); var y = n.substring(p, f + 1); (a.hasOwnProperty ? a.hasOwnProperty(y) : a[y] !== void 0) ? o += String.fromCharCode(a[y]) : (m == c && (y = n.substring(p), f = n.length), o += String.fromCharCode(m), a[y] = m, d[m++] = y), p = f + 1
      } return o
    } var c = 4e4, r = l(_); c = 65535; var i = l(S); return { chars1: r, chars2: i, lineArray: d }
  }, h.prototype.diff_charsToLines_ = function (_, S) { for (var d = 0; d < _.length; d++) { for (var a = _[d][1], l = [], c = 0; c < a.length; c++)l[c] = S[a.charCodeAt(c)]; _[d][1] = l.join("") } }, h.prototype.diff_commonPrefix = function (_, S) { if (!_ || !S || _.charAt(0) != S.charAt(0)) return 0; for (var d = 0, a = Math.min(_.length, S.length), l = a, c = 0; d < l;)_.substring(c, l) == S.substring(c, l) ? (d = l, c = d) : a = l, l = Math.floor((a - d) / 2 + d); return l }, h.prototype.diff_commonSuffix = function (_, S) { if (!_ || !S || _.charAt(_.length - 1) != S.charAt(S.length - 1)) return 0; for (var d = 0, a = Math.min(_.length, S.length), l = a, c = 0; d < l;)_.substring(_.length - l, _.length - c) == S.substring(S.length - l, S.length - c) ? (d = l, c = d) : a = l, l = Math.floor((a - d) / 2 + d); return l }, h.prototype.diff_commonOverlap_ = function (_, S) { var d = _.length, a = S.length; if (d == 0 || a == 0) return 0; d > a ? _ = _.substring(d - a) : d < a && (S = S.substring(0, d)); var l = Math.min(d, a); if (_ == S) return l; for (var c = 0, r = 1; ;) { var i = _.substring(l - r), n = S.indexOf(i); if (n == -1) return c; r += n, (n == 0 || _.substring(l - r) == S.substring(0, r)) && (c = r, r++) } }, h.prototype.diff_halfMatch_ = function (_, S) { if (this.Diff_Timeout <= 0) return null; var d = _.length > S.length ? _ : S, a = _.length > S.length ? S : _; if (d.length < 4 || a.length * 2 < d.length) return null; var l = this; function c(C, x, I) { for (var D = C.substring(I, I + Math.floor(C.length / 4)), P = -1, z = "", et, tt, st, dt; (P = x.indexOf(D, P + 1)) != -1;) { var q = l.diff_commonPrefix(C.substring(I), x.substring(P)), ct = l.diff_commonSuffix(C.substring(0, I), x.substring(0, P)); z.length < ct + q && (z = x.substring(P - ct, P) + x.substring(P, P + q), et = C.substring(0, I - ct), tt = C.substring(I + q), st = x.substring(0, P - ct), dt = x.substring(P + q)) } return z.length * 2 >= C.length ? [et, tt, st, dt, z] : null } var r = c(d, a, Math.ceil(d.length / 4)), i = c(d, a, Math.ceil(d.length / 2)), n; if (!r && !i) return null; i ? r ? n = r[4].length > i[4].length ? r : i : n = i : n = r; var o, p, f, m; _.length > S.length ? (o = n[0], p = n[1], f = n[2], m = n[3]) : (f = n[0], m = n[1], o = n[2], p = n[3]); var y = n[4]; return [o, p, f, m, y] }, h.prototype.diff_cleanupSemantic = function (_) { for (var S = !1, d = [], a = 0, l = null, c = 0, r = 0, i = 0, n = 0, o = 0; c < _.length;)_[c][0] == k ? (d[a++] = c, r = n, i = o, n = 0, o = 0, l = _[c][1]) : (_[c][0] == E ? n += _[c][1].length : o += _[c][1].length, l && l.length <= Math.max(r, i) && l.length <= Math.max(n, o) && (_.splice(d[a - 1], 0, new h.Diff(b, l)), _[d[a - 1] + 1][0] = E, a--, a--, c = a > 0 ? d[a - 1] : -1, r = 0, i = 0, n = 0, o = 0, l = null, S = !0)), c++; for (S && this.diff_cleanupMerge(_), this.diff_cleanupSemanticLossless(_), c = 1; c < _.length;) { if (_[c - 1][0] == b && _[c][0] == E) { var p = _[c - 1][1], f = _[c][1], m = this.diff_commonOverlap_(p, f), y = this.diff_commonOverlap_(f, p); m >= y ? (m >= p.length / 2 || m >= f.length / 2) && (_.splice(c, 0, new h.Diff(k, f.substring(0, m))), _[c - 1][1] = p.substring(0, p.length - m), _[c + 1][1] = f.substring(m), c++) : (y >= p.length / 2 || y >= f.length / 2) && (_.splice(c, 0, new h.Diff(k, p.substring(0, y))), _[c - 1][0] = E, _[c - 1][1] = f.substring(0, f.length - y), _[c + 1][0] = b, _[c + 1][1] = p.substring(y), c++), c++ } c++ } }, h.prototype.diff_cleanupSemanticLossless = function (_) { function S(y, C) { if (!y || !C) return 6; var x = y.charAt(y.length - 1), I = C.charAt(0), D = x.match(h.nonAlphaNumericRegex_), P = I.match(h.nonAlphaNumericRegex_), z = D && x.match(h.whitespaceRegex_), et = P && I.match(h.whitespaceRegex_), tt = z && x.match(h.linebreakRegex_), st = et && I.match(h.linebreakRegex_), dt = tt && y.match(h.blanklineEndRegex_), q = st && C.match(h.blanklineStartRegex_); return dt || q ? 5 : tt || st ? 4 : D && !z && et ? 3 : z || et ? 2 : D || P ? 1 : 0 } for (var d = 1; d < _.length - 1;) { if (_[d - 1][0] == k && _[d + 1][0] == k) { var a = _[d - 1][1], l = _[d][1], c = _[d + 1][1], r = this.diff_commonSuffix(a, l); if (r) { var i = l.substring(l.length - r); a = a.substring(0, a.length - r), l = i + l.substring(0, l.length - r), c = i + c } for (var n = a, o = l, p = c, f = S(a, l) + S(l, c); l.charAt(0) === c.charAt(0);) { a += l.charAt(0), l = l.substring(1) + c.charAt(0), c = c.substring(1); var m = S(a, l) + S(l, c); m >= f && (f = m, n = a, o = l, p = c) } _[d - 1][1] != n && (n ? _[d - 1][1] = n : (_.splice(d - 1, 1), d--), _[d][1] = o, p ? _[d + 1][1] = p : (_.splice(d + 1, 1), d--)) } d++ } }, h.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, h.whitespaceRegex_ = /\s/, h.linebreakRegex_ = /[\r\n]/, h.blanklineEndRegex_ = /\n\r?\n$/, h.blanklineStartRegex_ = /^\r?\n\r?\n/, h.prototype.diff_cleanupEfficiency = function (_) { for (var S = !1, d = [], a = 0, l = null, c = 0, r = !1, i = !1, n = !1, o = !1; c < _.length;)_[c][0] == k ? (_[c][1].length < this.Diff_EditCost && (n || o) ? (d[a++] = c, r = n, i = o, l = _[c][1]) : (a = 0, l = null), n = o = !1) : (_[c][0] == b ? o = !0 : n = !0, l && (r && i && n && o || l.length < this.Diff_EditCost / 2 && r + i + n + o == 3) && (_.splice(d[a - 1], 0, new h.Diff(b, l)), _[d[a - 1] + 1][0] = E, a--, l = null, r && i ? (n = o = !0, a = 0) : (a--, c = a > 0 ? d[a - 1] : -1, n = o = !1), S = !0)), c++; S && this.diff_cleanupMerge(_) }, h.prototype.diff_cleanupMerge = function (_) { _.push(new h.Diff(k, "")); for (var S = 0, d = 0, a = 0, l = "", c = "", r; S < _.length;)switch (_[S][0]) { case E: a++, c += _[S][1], S++; break; case b: d++, l += _[S][1], S++; break; case k: d + a > 1 ? (d !== 0 && a !== 0 && (r = this.diff_commonPrefix(c, l), r !== 0 && (S - d - a > 0 && _[S - d - a - 1][0] == k ? _[S - d - a - 1][1] += c.substring(0, r) : (_.splice(0, 0, new h.Diff(k, c.substring(0, r))), S++), c = c.substring(r), l = l.substring(r)), r = this.diff_commonSuffix(c, l), r !== 0 && (_[S][1] = c.substring(c.length - r) + _[S][1], c = c.substring(0, c.length - r), l = l.substring(0, l.length - r))), S -= d + a, _.splice(S, d + a), l.length && (_.splice(S, 0, new h.Diff(b, l)), S++), c.length && (_.splice(S, 0, new h.Diff(E, c)), S++), S++) : S !== 0 && _[S - 1][0] == k ? (_[S - 1][1] += _[S][1], _.splice(S, 1)) : S++, a = 0, d = 0, l = "", c = ""; break }_[_.length - 1][1] === "" && _.pop(); var i = !1; for (S = 1; S < _.length - 1;)_[S - 1][0] == k && _[S + 1][0] == k && (_[S][1].substring(_[S][1].length - _[S - 1][1].length) == _[S - 1][1] ? (_[S][1] = _[S - 1][1] + _[S][1].substring(0, _[S][1].length - _[S - 1][1].length), _[S + 1][1] = _[S - 1][1] + _[S + 1][1], _.splice(S - 1, 1), i = !0) : _[S][1].substring(0, _[S + 1][1].length) == _[S + 1][1] && (_[S - 1][1] += _[S + 1][1], _[S][1] = _[S][1].substring(_[S + 1][1].length) + _[S + 1][1], _.splice(S + 1, 1), i = !0)), S++; i && this.diff_cleanupMerge(_) }, h.prototype.diff_xIndex = function (_, S) { var d = 0, a = 0, l = 0, c = 0, r; for (r = 0; r < _.length && (_[r][0] !== E && (d += _[r][1].length), _[r][0] !== b && (a += _[r][1].length), !(d > S)); r++)l = d, c = a; return _.length != r && _[r][0] === b ? c : c + (S - l) }, h.prototype.diff_prettyHtml = function (_) { for (var S = [], d = /&/g, a = /</g, l = />/g, c = /\n/g, r = 0; r < _.length; r++) { var i = _[r][0], n = _[r][1], o = n.replace(d, "&amp;").replace(a, "&lt;").replace(l, "&gt;").replace(c, "&para;<br>"); switch (i) { case E: S[r] = '<ins style="background:#e6ffe6;">' + o + "</ins>"; break; case b: S[r] = '<del style="background:#ffe6e6;">' + o + "</del>"; break; case k: S[r] = "<span>" + o + "</span>"; break } } return S.join("") }, h.prototype.diff_text1 = function (_) { for (var S = [], d = 0; d < _.length; d++)_[d][0] !== E && (S[d] = _[d][1]); return S.join("") }, h.prototype.diff_text2 = function (_) { for (var S = [], d = 0; d < _.length; d++)_[d][0] !== b && (S[d] = _[d][1]); return S.join("") }, h.prototype.diff_levenshtein = function (_) { for (var S = 0, d = 0, a = 0, l = 0; l < _.length; l++) { var c = _[l][0], r = _[l][1]; switch (c) { case E: d += r.length; break; case b: a += r.length; break; case k: S += Math.max(d, a), d = 0, a = 0; break } } return S += Math.max(d, a), S }, h.prototype.diff_toDelta = function (_) { for (var S = [], d = 0; d < _.length; d++)switch (_[d][0]) { case E: S[d] = "+" + encodeURI(_[d][1]); break; case b: S[d] = "-" + _[d][1].length; break; case k: S[d] = "=" + _[d][1].length; break }return S.join("	").replace(/%20/g, " ") }, h.prototype.diff_fromDelta = function (_, S) { for (var d = [], a = 0, l = 0, c = S.split(/\t/g), r = 0; r < c.length; r++) { var i = c[r].substring(1); switch (c[r].charAt(0)) { case "+": try { d[a++] = new h.Diff(E, decodeURI(i)) } catch { throw new Error("Illegal escape in diff_fromDelta: " + i) } break; case "-": case "=": var n = parseInt(i, 10); if (isNaN(n) || n < 0) throw new Error("Invalid number in diff_fromDelta: " + i); var o = _.substring(l, l += n); c[r].charAt(0) == "=" ? d[a++] = new h.Diff(k, o) : d[a++] = new h.Diff(b, o); break; default: if (c[r]) throw new Error("Invalid diff operation in diff_fromDelta: " + c[r]) } } if (l != _.length) throw new Error("Delta length (" + l + ") does not equal source text length (" + _.length + ")."); return d }, h.prototype.match_main = function (_, S, d) { if (_ == null || S == null || d == null) throw new Error("Null input. (match_main)"); return d = Math.max(0, Math.min(d, _.length)), _ == S ? 0 : _.length ? _.substring(d, d + S.length) == S ? d : this.match_bitap_(_, S, d) : -1 }, h.prototype.match_bitap_ = function (_, S, d) { if (S.length > this.Match_MaxBits) throw new Error("Pattern too long for this browser."); var a = this.match_alphabet_(S), l = this; function c(et, tt) { var st = et / S.length, dt = Math.abs(d - tt); return l.Match_Distance ? st + dt / l.Match_Distance : dt ? 1 : st } var r = this.Match_Threshold, i = _.indexOf(S, d); i != -1 && (r = Math.min(c(0, i), r), i = _.lastIndexOf(S, d + S.length), i != -1 && (r = Math.min(c(0, i), r))); var n = 1 << S.length - 1; i = -1; for (var o, p, f = S.length + _.length, m, y = 0; y < S.length; y++) { for (o = 0, p = f; o < p;)c(y, d + p) <= r ? o = p : f = p, p = Math.floor((f - o) / 2 + o); f = p; var C = Math.max(1, d - p + 1), x = Math.min(d + p, _.length) + S.length, I = Array(x + 2); I[x + 1] = (1 << y) - 1; for (var D = x; D >= C; D--) { var P = a[_.charAt(D - 1)]; if (y === 0 ? I[D] = (I[D + 1] << 1 | 1) & P : I[D] = (I[D + 1] << 1 | 1) & P | ((m[D + 1] | m[D]) << 1 | 1) | m[D + 1], I[D] & n) { var z = c(y, D - 1); if (z <= r) if (r = z, i = D - 1, i > d) C = Math.max(1, 2 * d - i); else break } } if (c(y + 1, d) > r) break; m = I } return i }, h.prototype.match_alphabet_ = function (_) { for (var S = {}, d = 0; d < _.length; d++)S[_.charAt(d)] = 0; for (var d = 0; d < _.length; d++)S[_.charAt(d)] |= 1 << _.length - d - 1; return S }, h.prototype.patch_addContext_ = function (_, S) { if (S.length != 0) { if (_.start2 === null) throw Error("patch not initialized"); for (var d = S.substring(_.start2, _.start2 + _.length1), a = 0; S.indexOf(d) != S.lastIndexOf(d) && d.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin;)a += this.Patch_Margin, d = S.substring(_.start2 - a, _.start2 + _.length1 + a); a += this.Patch_Margin; var l = S.substring(_.start2 - a, _.start2); l && _.diffs.unshift(new h.Diff(k, l)); var c = S.substring(_.start2 + _.length1, _.start2 + _.length1 + a); c && _.diffs.push(new h.Diff(k, c)), _.start1 -= l.length, _.start2 -= l.length, _.length1 += l.length + c.length, _.length2 += l.length + c.length } }, h.prototype.patch_make = function (_, S, d) { var a, l; if (typeof _ == "string" && typeof S == "string" && typeof d > "u") a = _, l = this.diff_main(a, S, !0), l.length > 2 && (this.diff_cleanupSemantic(l), this.diff_cleanupEfficiency(l)); else if (_ && typeof _ == "object" && typeof S > "u" && typeof d > "u") l = _, a = this.diff_text1(l); else if (typeof _ == "string" && S && typeof S == "object" && typeof d > "u") a = _, l = S; else if (typeof _ == "string" && typeof S == "string" && d && typeof d == "object") a = _, l = d; else throw new Error("Unknown call format to patch_make."); if (l.length === 0) return []; for (var c = [], r = new h.patch_obj, i = 0, n = 0, o = 0, p = a, f = a, m = 0; m < l.length; m++) { var y = l[m][0], C = l[m][1]; switch (!i && y !== k && (r.start1 = n, r.start2 = o), y) { case E: r.diffs[i++] = l[m], r.length2 += C.length, f = f.substring(0, o) + C + f.substring(o); break; case b: r.length1 += C.length, r.diffs[i++] = l[m], f = f.substring(0, o) + f.substring(o + C.length); break; case k: C.length <= 2 * this.Patch_Margin && i && l.length != m + 1 ? (r.diffs[i++] = l[m], r.length1 += C.length, r.length2 += C.length) : C.length >= 2 * this.Patch_Margin && i && (this.patch_addContext_(r, p), c.push(r), r = new h.patch_obj, i = 0, p = f, n = o); break }y !== E && (n += C.length), y !== b && (o += C.length) } return i && (this.patch_addContext_(r, p), c.push(r)), c }, h.prototype.patch_deepCopy = function (_) { for (var S = [], d = 0; d < _.length; d++) { var a = _[d], l = new h.patch_obj; l.diffs = []; for (var c = 0; c < a.diffs.length; c++)l.diffs[c] = new h.Diff(a.diffs[c][0], a.diffs[c][1]); l.start1 = a.start1, l.start2 = a.start2, l.length1 = a.length1, l.length2 = a.length2, S[d] = l } return S }, h.prototype.patch_apply = function (_, S) { if (_.length == 0) return [S, []]; _ = this.patch_deepCopy(_); var d = this.patch_addPadding(_); S = d + S + d, this.patch_splitMax(_); for (var a = 0, l = [], c = 0; c < _.length; c++) { var r = _[c].start2 + a, i = this.diff_text1(_[c].diffs), n, o = -1; if (i.length > this.Match_MaxBits ? (n = this.match_main(S, i.substring(0, this.Match_MaxBits), r), n != -1 && (o = this.match_main(S, i.substring(i.length - this.Match_MaxBits), r + i.length - this.Match_MaxBits), (o == -1 || n >= o) && (n = -1))) : n = this.match_main(S, i, r), n == -1) l[c] = !1, a -= _[c].length2 - _[c].length1; else { l[c] = !0, a = n - r; var p; if (o == -1 ? p = S.substring(n, n + i.length) : p = S.substring(n, o + this.Match_MaxBits), i == p) S = S.substring(0, n) + this.diff_text2(_[c].diffs) + S.substring(n + i.length); else { var f = this.diff_main(i, p, !1); if (i.length > this.Match_MaxBits && this.diff_levenshtein(f) / i.length > this.Patch_DeleteThreshold) l[c] = !1; else { this.diff_cleanupSemanticLossless(f); for (var m = 0, y, C = 0; C < _[c].diffs.length; C++) { var x = _[c].diffs[C]; x[0] !== k && (y = this.diff_xIndex(f, m)), x[0] === E ? S = S.substring(0, n + y) + x[1] + S.substring(n + y) : x[0] === b && (S = S.substring(0, n + y) + S.substring(n + this.diff_xIndex(f, m + x[1].length))), x[0] !== b && (m += x[1].length) } } } } } return S = S.substring(d.length, S.length - d.length), [S, l] }, h.prototype.patch_addPadding = function (_) { for (var S = this.Patch_Margin, d = "", a = 1; a <= S; a++)d += String.fromCharCode(a); for (var a = 0; a < _.length; a++)_[a].start1 += S, _[a].start2 += S; var l = _[0], c = l.diffs; if (c.length == 0 || c[0][0] != k) c.unshift(new h.Diff(k, d)), l.start1 -= S, l.start2 -= S, l.length1 += S, l.length2 += S; else if (S > c[0][1].length) { var r = S - c[0][1].length; c[0][1] = d.substring(c[0][1].length) + c[0][1], l.start1 -= r, l.start2 -= r, l.length1 += r, l.length2 += r } if (l = _[_.length - 1], c = l.diffs, c.length == 0 || c[c.length - 1][0] != k) c.push(new h.Diff(k, d)), l.length1 += S, l.length2 += S; else if (S > c[c.length - 1][1].length) { var r = S - c[c.length - 1][1].length; c[c.length - 1][1] += d.substring(0, r), l.length1 += r, l.length2 += r } return d }, h.prototype.patch_splitMax = function (_) { for (var S = this.Match_MaxBits, d = 0; d < _.length; d++)if (!(_[d].length1 <= S)) { var a = _[d]; _.splice(d--, 1); for (var l = a.start1, c = a.start2, r = ""; a.diffs.length !== 0;) { var i = new h.patch_obj, n = !0; for (i.start1 = l - r.length, i.start2 = c - r.length, r !== "" && (i.length1 = i.length2 = r.length, i.diffs.push(new h.Diff(k, r))); a.diffs.length !== 0 && i.length1 < S - this.Patch_Margin;) { var o = a.diffs[0][0], p = a.diffs[0][1]; o === E ? (i.length2 += p.length, c += p.length, i.diffs.push(a.diffs.shift()), n = !1) : o === b && i.diffs.length == 1 && i.diffs[0][0] == k && p.length > 2 * S ? (i.length1 += p.length, l += p.length, n = !1, i.diffs.push(new h.Diff(o, p)), a.diffs.shift()) : (p = p.substring(0, S - i.length1 - this.Patch_Margin), i.length1 += p.length, l += p.length, o === k ? (i.length2 += p.length, c += p.length) : n = !1, i.diffs.push(new h.Diff(o, p)), p == a.diffs[0][1] ? a.diffs.shift() : a.diffs[0][1] = a.diffs[0][1].substring(p.length)) } r = this.diff_text2(i.diffs), r = r.substring(r.length - this.Patch_Margin); var f = this.diff_text1(a.diffs).substring(0, this.Patch_Margin); f !== "" && (i.length1 += f.length, i.length2 += f.length, i.diffs.length !== 0 && i.diffs[i.diffs.length - 1][0] === k ? i.diffs[i.diffs.length - 1][1] += f : i.diffs.push(new h.Diff(k, f))), n || _.splice(++d, 0, i) } } }, h.prototype.patch_toText = function (_) { for (var S = [], d = 0; d < _.length; d++)S[d] = _[d]; return S.join("") }, h.prototype.patch_fromText = function (_) {
    var S = []; if (!_) return S; for (var d = _.split(`
`), a = 0, l = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; a < d.length;) { var c = d[a].match(l); if (!c) throw new Error("Invalid patch string: " + d[a]); var r = new h.patch_obj; for (S.push(r), r.start1 = parseInt(c[1], 10), c[2] === "" ? (r.start1--, r.length1 = 1) : c[2] == "0" ? r.length1 = 0 : (r.start1--, r.length1 = parseInt(c[2], 10)), r.start2 = parseInt(c[3], 10), c[4] === "" ? (r.start2--, r.length2 = 1) : c[4] == "0" ? r.length2 = 0 : (r.start2--, r.length2 = parseInt(c[4], 10)), a++; a < d.length;) { var i = d[a].charAt(0); try { var n = decodeURI(d[a].substring(1)) } catch { throw new Error("Illegal escape in patch_fromText: " + n) } if (i == "-") r.diffs.push(new h.Diff(b, n)); else if (i == "+") r.diffs.push(new h.Diff(E, n)); else if (i == " ") r.diffs.push(new h.Diff(k, n)); else { if (i == "@") break; if (i !== "") throw new Error('Invalid patch mode "' + i + '" in: ' + n) } a++ } } return S
  }, h.patch_obj = function () { this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0 }, h.patch_obj.prototype.toString = function () {
    var _, S; this.length1 === 0 ? _ = this.start1 + ",0" : this.length1 == 1 ? _ = this.start1 + 1 : _ = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? S = this.start2 + ",0" : this.length2 == 1 ? S = this.start2 + 1 : S = this.start2 + 1 + "," + this.length2; for (var d = ["@@ -" + _ + " +" + S + ` @@
`], a, l = 0; l < this.diffs.length; l++) {
      switch (this.diffs[l][0]) { case E: a = "+"; break; case b: a = "-"; break; case k: a = " "; break }d[l + 1] = a + encodeURI(this.diffs[l][1]) + `
`} return d.join("").replace(/%20/g, " ")
  }, v.exports = h, v.exports.diff_match_patch = h, v.exports.DIFF_DELETE = b, v.exports.DIFF_INSERT = E, v.exports.DIFF_EQUAL = k
})(xf); var f0 = xf.exports; const h0 = Qu(f0); (function (v, h) { (function (b) { b(kn()) })(function (b) { b.defineSimpleMode = function (i, n) { b.defineMode(i, function (o) { return b.simpleMode(o, n) }) }, b.simpleMode = function (i, n) { E(n, "start"); var o = {}, p = n.meta || {}, f = !1; for (var m in n) if (m != p && n.hasOwnProperty(m)) for (var y = o[m] = [], C = n[m], x = 0; x < C.length; x++) { var I = C[x]; y.push(new S(I, n)), (I.indent || I.dedent) && (f = !0) } var D = { startState: function () { return { state: "start", pending: null, local: null, localState: null, indent: f ? [] : null } }, copyState: function (z) { var et = { state: z.state, pending: z.pending, local: z.local, localState: null, indent: z.indent && z.indent.slice(0) }; z.localState && (et.localState = b.copyState(z.local.mode, z.localState)), z.stack && (et.stack = z.stack.slice(0)); for (var tt = z.persistentStates; tt; tt = tt.next)et.persistentStates = { mode: tt.mode, spec: tt.spec, state: tt.state == z.localState ? et.localState : b.copyState(tt.mode, tt.state), next: et.persistentStates }; return et }, token: d(o, i), innerMode: function (z) { return z.local && { mode: z.local.mode, state: z.localState } }, indent: r(o, p) }; if (p) for (var P in p) p.hasOwnProperty(P) && (D[P] = p[P]); return D }; function E(i, n) { if (!i.hasOwnProperty(n)) throw new Error("Undefined state " + n + " in simple mode") } function k(i, n) { if (!i) return /(?:)/; var o = ""; return i instanceof RegExp ? (i.ignoreCase && (o = "i"), i.unicode && (o += "u"), i = i.source) : i = String(i), new RegExp((n === !1 ? "" : "^") + "(?:" + i + ")", o) } function _(i) { if (!i) return null; if (i.apply) return i; if (typeof i == "string") return i.replace(/\./g, " "); for (var n = [], o = 0; o < i.length; o++)n.push(i[o] && i[o].replace(/\./g, " ")); return n } function S(i, n) { (i.next || i.push) && E(n, i.next || i.push), this.regex = k(i.regex), this.token = _(i.token), this.data = i } function d(i, n) { return function (o, p) { if (p.pending) { var f = p.pending.shift(); return p.pending.length == 0 && (p.pending = null), o.pos += f.text.length, f.token } if (p.local) if (p.local.end && o.match(p.local.end)) { var m = p.local.endToken || null; return p.local = p.localState = null, m } else { var m = p.local.mode.token(o, p.localState), y; return p.local.endScan && (y = p.local.endScan.exec(o.current())) && (o.pos = o.start + y.index), m } for (var C = i[p.state], x = 0; x < C.length; x++) { var I = C[x], D = (!I.data.sol || o.sol()) && o.match(I.regex); if (D) { I.data.next ? p.state = I.data.next : I.data.push ? ((p.stack || (p.stack = [])).push(p.state), p.state = I.data.push) : I.data.pop && p.stack && p.stack.length && (p.state = p.stack.pop()), I.data.mode && l(n, p, I.data.mode, I.token), I.data.indent && p.indent.push(o.indentation() + n.indentUnit), I.data.dedent && p.indent.pop(); var P = I.token; if (P && P.apply && (P = P(D)), D.length > 2 && I.token && typeof I.token != "string") { for (var z = 2; z < D.length; z++)D[z] && (p.pending || (p.pending = [])).push({ text: D[z], token: I.token[z - 1] }); return o.backUp(D[0].length - (D[1] ? D[1].length : 0)), P[0] } else return P && P.join ? P[0] : P } } return o.next(), null } } function a(i, n) { if (i === n) return !0; if (!i || typeof i != "object" || !n || typeof n != "object") return !1; var o = 0; for (var p in i) if (i.hasOwnProperty(p)) { if (!n.hasOwnProperty(p) || !a(i[p], n[p])) return !1; o++ } for (var p in n) n.hasOwnProperty(p) && o--; return o == 0 } function l(i, n, o, p) { var f; if (o.persistent) for (var m = n.persistentStates; m && !f; m = m.next)(o.spec ? a(o.spec, m.spec) : o.mode == m.mode) && (f = m); var y = f ? f.mode : o.mode || b.getMode(i, o.spec), C = f ? f.state : b.startState(y); o.persistent && !f && (n.persistentStates = { mode: y, spec: o.spec, state: C, next: n.persistentStates }), n.localState = C, n.local = { mode: y, end: o.end && k(o.end), endScan: o.end && o.forceEnd !== !1 && k(o.end, !1), endToken: p && p.join ? p[p.length - 1] : p } } function c(i, n) { for (var o = 0; o < n.length; o++)if (n[o] === i) return !0 } function r(i, n) { return function (o, p, f) { if (o.local && o.local.mode.indent) return o.local.mode.indent(o.localState, p, f); if (o.indent == null || o.local || n.dontIndentStates && c(o.state, n.dontIndentStates) > -1) return b.Pass; var m = o.indent.length - 1, y = i[o.state]; t: for (; ;) { for (var C = 0; C < y.length; C++) { var x = y[C]; if (x.data.dedent && x.data.dedentIfLineStart !== !1) { var I = x.regex.exec(p); if (I && I[0]) { m--, (x.next || x.push) && (y = i[x.next || x.push]), p = p.slice(I[0].length); continue t } } } break } return m < 0 ? 0 : o.indent[m] } } }) })(); !window.CodeMirror && (window.CodeMirror = wf); const _f = window.CodeMirror || wf; window.diff_match_patch = h0; window.DIFF_DELETE = -1; window.DIFF_INSERT = 1; window.DIFF_EQUAL = 0; const ma = [{ regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/, token: ["tag", "", "error.strong", "error.strong"], sol: !0 }, { regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/, token: ["tag", "", "bracket", "bracket", "hr"], sol: !0 }, { regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/, token: ["tag", "", "comment", "comment", "hr"], sol: !0 }]; _f.defineSimpleMode("fclog", { start: [...ma, { regex: /.*/, token: "hr" }], error: [...ma, { regex: /.*/, token: "error.strong" }], info: [...ma, { regex: /.*/, token: "bracket" }], warning: [...ma, { regex: /.*\[/, token: "comment" }] }); _f.defineSimpleMode("log", { start: [{ regex: /^[=]+[^=]*[=]+/, token: "strong" }, { regex: /([^\w])([A-Z][\w]*)/, token: ["", "string"] }, { regex: /(^[A-Z][\w]*)/, token: "string" }] }); function c0(v, h) { h === void 0 && (h = {}); var b = h.insertAt; if (!(!v || typeof document > "u")) { var E = document.head || document.getElementsByTagName("head")[0], k = document.createElement("style"); k.type = "text/css", b === "top" && E.firstChild ? E.insertBefore(k, E.firstChild) : E.appendChild(k), k.styleSheet ? k.styleSheet.cssText = v : k.appendChild(document.createTextNode(v)) } } c0(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 12px;
  overflow: hidden;
}
.codemirror-container.bordered {
  border-radius: 4px;
  border: 1px solid #dddddd;
}
.codemirror-container.width-auto {
  width: 100%;
}
.codemirror-container.height-auto {
  height: 100%;
}
.codemirror-container.height-auto .CodeMirror,
.codemirror-container.height-auto .cm-s-default {
  height: 100% !important;
}
.codemirror-container .editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.codemirror-container .editor_custom_link:hover {
  color: #04b4fa;
}
.codemirror-container:not(.original-style) .CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.codemirror-container:not(.original-style) .CodeMirror,
.codemirror-container:not(.original-style) .CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.codemirror-container:not(.original-style) .CodeMirror-merge,
.codemirror-container:not(.original-style) .CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.codemirror-container:not(.original-style) .c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__warning {
  color: #ee9900;
}
.codemirror-container:not(.original-style) .c-editor--log__success {
  color: #669600;
}
.codemirror-container:not(.original-style) .cm-header,
.codemirror-container:not(.original-style) .cm-strong {
  font-weight: bold;
}
`); (function (v, h) { (function (b) { b(kn()) })(function (b) { b.defineOption("placeholder", "", function (l, c, r) { var i = r && r != b.Init; if (c && !i) l.on("blur", S), l.on("change", d), l.on("swapDoc", d), b.on(l.getInputField(), "compositionupdate", l.state.placeholderCompose = function () { _(l) }), d(l); else if (!c && i) { l.off("blur", S), l.off("change", d), l.off("swapDoc", d), b.off(l.getInputField(), "compositionupdate", l.state.placeholderCompose), E(l); var n = l.getWrapperElement(); n.className = n.className.replace(" CodeMirror-empty", "") } c && !l.hasFocus() && S(l) }); function E(l) { l.state.placeholder && (l.state.placeholder.parentNode.removeChild(l.state.placeholder), l.state.placeholder = null) } function k(l) { E(l); var c = l.state.placeholder = document.createElement("pre"); c.style.cssText = "height: 0; overflow: visible", c.style.direction = l.getOption("direction"), c.className = "CodeMirror-placeholder CodeMirror-line-like"; var r = l.getOption("placeholder"); typeof r == "string" && (r = document.createTextNode(r)), c.appendChild(r), l.display.lineSpace.insertBefore(c, l.display.lineSpace.firstChild) } function _(l) { setTimeout(function () { var c = !1; if (l.lineCount() == 1) { var r = l.getInputField(); c = r.nodeName == "TEXTAREA" ? !l.getLine(0).length : !/[^\u200b]/.test(r.querySelector(".CodeMirror-line").textContent) } c ? k(l) : E(l) }, 20) } function S(l) { a(l) && k(l) } function d(l) { var c = l.getWrapperElement(), r = a(l); c.className = c.className.replace(" CodeMirror-empty", "") + (r ? " CodeMirror-empty" : ""), r ? k(l) : E(l) } function a(l) { return l.lineCount() === 1 && l.getLine(0) === "" } }) })(); (function (v, h) { (function (b) { b(kn()) })(function (b) { b.defineMode("javascript", function (E, k) { var _ = E.indentUnit, S = k.statementIndent, d = k.jsonld, a = k.json || d, l = k.trackScope !== !1, c = k.typescript, r = k.wordCharacters || /[\w$\xa1-\uffff]/, i = function () { function F(xe) { return { type: xe, style: "keyword" } } var X = F("keyword a"), Z = F("keyword b"), At = F("keyword c"), Ut = F("keyword d"), qt = F("operator"), Zt = { type: "atom", style: "atom" }; return { if: F("if"), while: X, with: X, else: Z, do: Z, try: Z, finally: Z, return: Ut, break: Ut, continue: Ut, new: F("new"), delete: At, void: At, throw: At, debugger: F("debugger"), var: F("var"), const: F("var"), let: F("var"), function: F("function"), catch: F("catch"), for: F("for"), switch: F("switch"), case: F("case"), default: F("default"), in: qt, typeof: qt, instanceof: qt, true: Zt, false: Zt, null: Zt, undefined: Zt, NaN: Zt, Infinity: Zt, this: F("this"), class: F("class"), super: F("atom"), yield: At, export: F("export"), import: F("import"), extends: At, await: At } }(), n = /[+\-*&%=<>!?|~^@]/, o = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function p(F) { for (var X = !1, Z, At = !1; (Z = F.next()) != null;) { if (!X) { if (Z == "/" && !At) return; Z == "[" ? At = !0 : At && Z == "]" && (At = !1) } X = !X && Z == "\\" } } var f, m; function y(F, X, Z) { return f = F, m = Z, X } function C(F, X) { var Z = F.next(); if (Z == '"' || Z == "'") return X.tokenize = x(Z), X.tokenize(F, X); if (Z == "." && F.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return y("number", "number"); if (Z == "." && F.match("..")) return y("spread", "meta"); if (/[\[\]{}\(\),;\:\.]/.test(Z)) return y(Z); if (Z == "=" && F.eat(">")) return y("=>", "operator"); if (Z == "0" && F.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return y("number", "number"); if (/\d/.test(Z)) return F.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), y("number", "number"); if (Z == "/") return F.eat("*") ? (X.tokenize = I, I(F, X)) : F.eat("/") ? (F.skipToEnd(), y("comment", "comment")) : di(F, X, 1) ? (p(F), F.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), y("regexp", "string-2")) : (F.eat("="), y("operator", "operator", F.current())); if (Z == "`") return X.tokenize = D, D(F, X); if (Z == "#" && F.peek() == "!") return F.skipToEnd(), y("meta", "meta"); if (Z == "#" && F.eatWhile(r)) return y("variable", "property"); if (Z == "<" && F.match("!--") || Z == "-" && F.match("->") && !/\S/.test(F.string.slice(0, F.start))) return F.skipToEnd(), y("comment", "comment"); if (n.test(Z)) return (Z != ">" || !X.lexical || X.lexical.type != ">") && (F.eat("=") ? (Z == "!" || Z == "=") && F.eat("=") : /[<>*+\-|&?]/.test(Z) && (F.eat(Z), Z == ">" && F.eat(Z))), Z == "?" && F.eat(".") ? y(".") : y("operator", "operator", F.current()); if (r.test(Z)) { F.eatWhile(r); var At = F.current(); if (X.lastType != ".") { if (i.propertyIsEnumerable(At)) { var Ut = i[At]; return y(Ut.type, Ut.style, At) } if (At == "async" && F.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return y("async", "keyword", At) } return y("variable", "variable", At) } } function x(F) { return function (X, Z) { var At = !1, Ut; if (d && X.peek() == "@" && X.match(o)) return Z.tokenize = C, y("jsonld-keyword", "meta"); for (; (Ut = X.next()) != null && !(Ut == F && !At);)At = !At && Ut == "\\"; return At || (Z.tokenize = C), y("string", "string") } } function I(F, X) { for (var Z = !1, At; At = F.next();) { if (At == "/" && Z) { X.tokenize = C; break } Z = At == "*" } return y("comment", "comment") } function D(F, X) { for (var Z = !1, At; (At = F.next()) != null;) { if (!Z && (At == "`" || At == "$" && F.eat("{"))) { X.tokenize = C; break } Z = !Z && At == "\\" } return y("quasi", "string-2", F.current()) } var P = "([{}])"; function z(F, X) { X.fatArrowAt && (X.fatArrowAt = null); var Z = F.string.indexOf("=>", F.start); if (!(Z < 0)) { if (c) { var At = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(F.string.slice(F.start, Z)); At && (Z = At.index) } for (var Ut = 0, qt = !1, Zt = Z - 1; Zt >= 0; --Zt) { var xe = F.string.charAt(Zt), Xe = P.indexOf(xe); if (Xe >= 0 && Xe < 3) { if (!Ut) { ++Zt; break } if (--Ut == 0) { xe == "(" && (qt = !0); break } } else if (Xe >= 3 && Xe < 6) ++Ut; else if (r.test(xe)) qt = !0; else if (/["'\/`]/.test(xe)) for (; ; --Zt) { if (Zt == 0) return; var Ht = F.string.charAt(Zt - 1); if (Ht == xe && F.string.charAt(Zt - 2) != "\\") { Zt--; break } } else if (qt && !Ut) { ++Zt; break } } qt && !Ut && (X.fatArrowAt = Zt) } } var et = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, import: !0, "jsonld-keyword": !0 }; function tt(F, X, Z, At, Ut, qt) { this.indented = F, this.column = X, this.type = Z, this.prev = Ut, this.info = qt, At != null && (this.align = At) } function st(F, X) { if (!l) return !1; for (var Z = F.localVars; Z; Z = Z.next)if (Z.name == X) return !0; for (var At = F.context; At; At = At.prev)for (var Z = At.vars; Z; Z = Z.next)if (Z.name == X) return !0 } function dt(F, X, Z, At, Ut) { var qt = F.cc; for (q.state = F, q.stream = Ut, q.marked = null, q.cc = qt, q.style = X, F.lexical.hasOwnProperty("align") || (F.lexical.align = !0); ;) { var Zt = qt.length ? qt.pop() : a ? mt : ut; if (Zt(Z, At)) { for (; qt.length && qt[qt.length - 1].lex;)qt.pop()(); return q.marked ? q.marked : Z == "variable" && st(F, At) ? "variable-2" : X } } } var q = { state: null, column: null, marked: null, cc: null }; function ct() { for (var F = arguments.length - 1; F >= 0; F--)q.cc.push(arguments[F]) } function W() { return ct.apply(null, arguments), !0 } function Dt(F, X) { for (var Z = X; Z; Z = Z.next)if (Z.name == F) return !0; return !1 } function Lt(F) { var X = q.state; if (q.marked = "def", !!l) { if (X.context) { if (X.lexical.info == "var" && X.context && X.context.block) { var Z = it(F, X.context); if (Z != null) { X.context = Z; return } } else if (!Dt(F, X.localVars)) { X.localVars = new G(F, X.localVars); return } } k.globalVars && !Dt(F, X.globalVars) && (X.globalVars = new G(F, X.globalVars)) } } function it(F, X) { if (X) if (X.block) { var Z = it(F, X.prev); return Z ? Z == X.prev ? X : new V(Z, X.vars, !0) : null } else return Dt(F, X.vars) ? X : new V(X.prev, new G(F, X.vars), !1); else return null } function O(F) { return F == "public" || F == "private" || F == "protected" || F == "abstract" || F == "readonly" } function V(F, X, Z) { this.prev = F, this.vars = X, this.block = Z } function G(F, X) { this.name = F, this.next = X } var U = new G("this", new G("arguments", null)); function lt() { q.state.context = new V(q.state.context, q.state.localVars, !1), q.state.localVars = U } function H() { q.state.context = new V(q.state.context, q.state.localVars, !0), q.state.localVars = null } lt.lex = H.lex = !0; function R() { q.state.localVars = q.state.context.vars, q.state.context = q.state.context.prev } R.lex = !0; function K(F, X) { var Z = function () { var At = q.state, Ut = At.indented; if (At.lexical.type == "stat") Ut = At.lexical.indented; else for (var qt = At.lexical; qt && qt.type == ")" && qt.align; qt = qt.prev)Ut = qt.indented; At.lexical = new tt(Ut, q.stream.column(), F, null, At.lexical, X) }; return Z.lex = !0, Z } function J() { var F = q.state; F.lexical.prev && (F.lexical.type == ")" && (F.indented = F.lexical.indented), F.lexical = F.lexical.prev) } J.lex = !0; function ht(F) { function X(Z) { return Z == F ? W() : F == ";" || Z == "}" || Z == ")" || Z == "]" ? ct() : W(X) } return X } function ut(F, X) { return F == "var" ? W(K("vardef", X), wi, ht(";"), J) : F == "keyword a" ? W(K("form"), gt, ut, J) : F == "keyword b" ? W(K("form"), ut, J) : F == "keyword d" ? q.stream.match(/^\s*$/, !1) ? W() : W(K("stat"), wt, ht(";"), J) : F == "debugger" ? W(ht(";")) : F == "{" ? W(K("}"), H, Gt, J, R) : F == ";" ? W() : F == "if" ? (q.state.lexical.info == "else" && q.state.cc[q.state.cc.length - 1] == J && q.state.cc.pop()(), W(K("form"), gt, ut, J, hr)) : F == "function" ? W(hi) : F == "for" ? W(K("form"), H, Mn, ut, R, J) : F == "class" || c && X == "interface" ? (q.marked = "keyword", W(K("form", F == "class" ? F : X), Dn, J)) : F == "variable" ? c && X == "declare" ? (q.marked = "keyword", W(ut)) : c && (X == "module" || X == "enum" || X == "type") && q.stream.match(/^\s*\w/, !1) ? (q.marked = "keyword", X == "enum" ? W(dr) : X == "type" ? W(On, ht("operator"), It, ht(";")) : W(K("form"), Qe, ht("{"), K("}"), Gt, J, J)) : c && X == "namespace" ? (q.marked = "keyword", W(K("form"), mt, ut, J)) : c && X == "abstract" ? (q.marked = "keyword", W(ut)) : W(K("stat"), at) : F == "switch" ? W(K("form"), gt, ht("{"), K("}", "switch"), H, Gt, J, J, R) : F == "case" ? W(mt, ht(":")) : F == "default" ? W(ht(":")) : F == "catch" ? W(K("form"), lt, _t, ut, J, R) : F == "export" ? W(K("stat"), Ri, J) : F == "import" ? W(K("stat"), _i, J) : F == "async" ? W(ut) : X == "@" ? W(mt, ut) : ct(K("stat"), mt, ht(";"), J) } function _t(F) { if (F == "(") return W(ei, ht(")")) } function mt(F, X) { return ft(F, X, !1) } function St(F, X) { return ft(F, X, !0) } function gt(F) { return F != "(" ? ct() : W(K(")"), wt, ht(")"), J) } function ft(F, X, Z) { if (q.state.fatArrowAt == q.stream.start) { var At = Z ? N : L; if (F == "(") return W(lt, K(")"), Qt(ei, ")"), J, ht("=>"), At, R); if (F == "variable") return ct(lt, Qe, ht("=>"), At, R) } var Ut = Z ? pt : xt; return et.hasOwnProperty(F) ? W(Ut) : F == "function" ? W(hi, Ut) : F == "class" || c && X == "interface" ? (q.marked = "keyword", W(K("form"), Pi, J)) : F == "keyword c" || F == "async" ? W(Z ? St : mt) : F == "(" ? W(K(")"), wt, ht(")"), J, Ut) : F == "operator" || F == "spread" ? W(Z ? St : mt) : F == "[" ? W(K("]"), Si, J, Ut) : F == "{" ? jt(bt, "}", null, Ut) : F == "quasi" ? ct(vt, Ut) : F == "new" ? W(Q(Z)) : W() } function wt(F) { return F.match(/[;\}\)\],]/) ? ct() : ct(mt) } function xt(F, X) { return F == "," ? W(wt) : pt(F, X, !1) } function pt(F, X, Z) { var At = Z == !1 ? xt : pt, Ut = Z == !1 ? mt : St; if (F == "=>") return W(lt, Z ? N : L, R); if (F == "operator") return /\+\+|--/.test(X) || c && X == "!" ? W(At) : c && X == "<" && q.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? W(K(">"), Qt(It, ">"), J, At) : X == "?" ? W(mt, ht(":"), Ut) : W(Ut); if (F == "quasi") return ct(vt, At); if (F != ";") { if (F == "(") return jt(St, ")", "call", At); if (F == ".") return W(yt, At); if (F == "[") return W(K("]"), wt, ht("]"), J, At); if (c && X == "as") return q.marked = "keyword", W(It, At); if (F == "regexp") return q.state.lastType = q.marked = "operator", q.stream.backUp(q.stream.pos - q.stream.start - 1), W(Ut) } } function vt(F, X) { return F != "quasi" ? ct() : X.slice(X.length - 2) != "${" ? W(vt) : W(wt, kt) } function kt(F) { if (F == "}") return q.marked = "string-2", q.state.tokenize = D, W(vt) } function L(F) { return z(q.stream, q.state), ct(F == "{" ? ut : mt) } function N(F) { return z(q.stream, q.state), ct(F == "{" ? ut : St) } function Q(F) { return function (X) { return X == "." ? W(F ? rt : $) : X == "variable" && c ? W(de, F ? pt : xt) : ct(F ? St : mt) } } function $(F, X) { if (X == "target") return q.marked = "keyword", W(xt) } function rt(F, X) { if (X == "target") return q.marked = "keyword", W(pt) } function at(F) { return F == ":" ? W(J, ut) : ct(xt, ht(";"), J) } function yt(F) { if (F == "variable") return q.marked = "property", W() } function bt(F, X) { if (F == "async") return q.marked = "property", W(bt); if (F == "variable" || q.style == "keyword") { if (q.marked = "property", X == "get" || X == "set") return W(Et); var Z; return c && q.state.fatArrowAt == q.stream.start && (Z = q.stream.match(/^\s*:\s*/, !1)) && (q.state.fatArrowAt = q.stream.pos + Z[0].length), W(Ft) } else { if (F == "number" || F == "string") return q.marked = d ? "property" : q.style + " property", W(Ft); if (F == "jsonld-keyword") return W(Ft); if (c && O(X)) return q.marked = "keyword", W(bt); if (F == "[") return W(mt, Kt, ht("]"), Ft); if (F == "spread") return W(St, Ft); if (X == "*") return q.marked = "keyword", W(bt); if (F == ":") return ct(Ft) } } function Et(F) { return F != "variable" ? ct(Ft) : (q.marked = "property", W(hi)) } function Ft(F) { if (F == ":") return W(St); if (F == "(") return ct(hi) } function Qt(F, X, Z) { function At(Ut, qt) { if (Z ? Z.indexOf(Ut) > -1 : Ut == ",") { var Zt = q.state.lexical; return Zt.info == "call" && (Zt.pos = (Zt.pos || 0) + 1), W(function (xe, Xe) { return xe == X || Xe == X ? ct() : ct(F) }, At) } return Ut == X || qt == X ? W() : Z && Z.indexOf(";") > -1 ? ct(F) : W(ht(X)) } return function (Ut, qt) { return Ut == X || qt == X ? W() : ct(F, At) } } function jt(F, X, Z) { for (var At = 3; At < arguments.length; At++)q.cc.push(arguments[At]); return W(K(X, Z), Qt(F, X), J) } function Gt(F) { return F == "}" ? W() : ct(ut, Gt) } function Kt(F, X) { if (c) { if (F == ":") return W(It); if (X == "?") return W(Kt) } } function ae(F, X) { if (c && (F == ":" || X == "in")) return W(It) } function ee(F) { if (c && F == ":") return q.stream.match(/^\s*\w+\s+is\b/, !1) ? W(mt, ke, It) : W(It) } function ke(F, X) { if (X == "is") return q.marked = "keyword", W() } function It(F, X) { if (X == "keyof" || X == "typeof" || X == "infer" || X == "readonly") return q.marked = "keyword", W(X == "typeof" ? St : It); if (F == "variable" || X == "void") return q.marked = "type", W(ve); if (X == "|" || X == "&") return W(It); if (F == "string" || F == "number" || F == "atom") return W(ve); if (F == "[") return W(K("]"), Qt(It, "]", ","), J, ve); if (F == "{") return W(K("}"), be, J, ve); if (F == "(") return W(Qt(we, ")"), Li, ve); if (F == "<") return W(Qt(It, ">"), It); if (F == "quasi") return ct(oe, ve) } function Li(F) { if (F == "=>") return W(It) } function be(F) { return F.match(/[\}\)\]]/) ? W() : F == "," || F == ";" ? W(be) : ct(ie, be) } function ie(F, X) { if (F == "variable" || q.style == "keyword") return q.marked = "property", W(ie); if (X == "?" || F == "number" || F == "string") return W(ie); if (F == ":") return W(It); if (F == "[") return W(ht("variable"), ae, ht("]"), ie); if (F == "(") return ct(ci, ie); if (!F.match(/[;\}\)\],]/)) return W() } function oe(F, X) { return F != "quasi" ? ct() : X.slice(X.length - 2) != "${" ? W(oe) : W(It, qi) } function qi(F) { if (F == "}") return q.marked = "string-2", q.state.tokenize = D, W(oe) } function we(F, X) { return F == "variable" && q.stream.match(/^\s*[?:]/, !1) || X == "?" ? W(we) : F == ":" ? W(It) : F == "spread" ? W(we) : ct(It) } function ve(F, X) { if (X == "<") return W(K(">"), Qt(It, ">"), J, ve); if (X == "|" || F == "." || X == "&") return W(It); if (F == "[") return W(It, ht("]"), ve); if (X == "extends" || X == "implements") return q.marked = "keyword", W(It); if (X == "?") return W(It, ht(":"), It) } function de(F, X) { if (X == "<") return W(K(">"), Qt(It, ">"), J, ve) } function fi() { return ct(It, ti) } function ti(F, X) { if (X == "=") return W(It) } function wi(F, X) { return X == "enum" ? (q.marked = "keyword", W(dr)) : ct(Qe, Kt, Ze, Wa) } function Qe(F, X) { if (c && O(X)) return q.marked = "keyword", W(Qe); if (F == "variable") return Lt(X), W(); if (F == "spread") return W(Qe); if (F == "[") return jt(Qa, "]"); if (F == "{") return jt(Wr, "}") } function Wr(F, X) { return F == "variable" && !q.stream.match(/^\s*:/, !1) ? (Lt(X), W(Ze)) : (F == "variable" && (q.marked = "property"), F == "spread" ? W(Qe) : F == "}" ? ct() : F == "[" ? W(mt, ht("]"), ht(":"), Wr) : W(ht(":"), Qe, Ze)) } function Qa() { return ct(Qe, Ze) } function Ze(F, X) { if (X == "=") return W(St) } function Wa(F) { if (F == ",") return W(wi) } function hr(F, X) { if (F == "keyword b" && X == "else") return W(K("form", "else"), ut, J) } function Mn(F, X) { if (X == "await") return W(Mn); if (F == "(") return W(K(")"), Nr, J) } function Nr(F) { return F == "var" ? W(wi, Fi) : F == "variable" ? W(Fi) : ct(Fi) } function Fi(F, X) { return F == ")" ? W() : F == ";" ? W(Fi) : X == "in" || X == "of" ? (q.marked = "keyword", W(mt, Fi)) : ct(mt, Fi) } function hi(F, X) { if (X == "*") return q.marked = "keyword", W(hi); if (F == "variable") return Lt(X), W(hi); if (F == "(") return W(lt, K(")"), Qt(ei, ")"), J, ee, ut, R); if (c && X == "<") return W(K(">"), Qt(fi, ">"), J, hi) } function ci(F, X) { if (X == "*") return q.marked = "keyword", W(ci); if (F == "variable") return Lt(X), W(ci); if (F == "(") return W(lt, K(")"), Qt(ei, ")"), J, ee, R); if (c && X == "<") return W(K(">"), Qt(fi, ">"), J, ci) } function On(F, X) { if (F == "keyword" || F == "variable") return q.marked = "type", W(On); if (X == "<") return W(K(">"), Qt(fi, ">"), J) } function ei(F, X) { return X == "@" && W(mt, ei), F == "spread" ? W(ei) : c && O(X) ? (q.marked = "keyword", W(ei)) : c && F == "this" ? W(Kt, Ze) : ct(Qe, Kt, Ze) } function Pi(F, X) { return F == "variable" ? Dn(F, X) : cr(F, X) } function Dn(F, X) { if (F == "variable") return Lt(X), W(cr) } function cr(F, X) { if (X == "<") return W(K(">"), Qt(fi, ">"), J, cr); if (X == "extends" || X == "implements" || c && F == ",") return X == "implements" && (q.marked = "keyword"), W(c ? It : mt, cr); if (F == "{") return W(K("}"), Ue, J) } function Ue(F, X) { if (F == "async" || F == "variable" && (X == "static" || X == "get" || X == "set" || c && O(X)) && q.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1)) return q.marked = "keyword", W(Ue); if (F == "variable" || q.style == "keyword") return q.marked = "property", W(xi, Ue); if (F == "number" || F == "string") return W(xi, Ue); if (F == "[") return W(mt, Kt, ht("]"), xi, Ue); if (X == "*") return q.marked = "keyword", W(Ue); if (c && F == "(") return ct(ci, Ue); if (F == ";" || F == ",") return W(Ue); if (F == "}") return W(); if (X == "@") return W(mt, Ue) } function xi(F, X) { if (X == "!" || X == "?") return W(xi); if (F == ":") return W(It, Ze); if (X == "=") return W(St); var Z = q.state.lexical.prev, At = Z && Z.info == "interface"; return ct(At ? ci : hi) } function Ri(F, X) { return X == "*" ? (q.marked = "keyword", W(Wt, ht(";"))) : X == "default" ? (q.marked = "keyword", W(mt, ht(";"))) : F == "{" ? W(Qt(Ln, "}"), Wt, ht(";")) : ct(ut) } function Ln(F, X) { if (X == "as") return q.marked = "keyword", W(ht("variable")); if (F == "variable") return ct(St, Ln) } function _i(F) { return F == "string" ? W() : F == "(" ? ct(mt) : F == "." ? ct(xt) : ct(Qi, Yr, Wt) } function Qi(F, X) { return F == "{" ? jt(Qi, "}") : (F == "variable" && Lt(X), X == "*" && (q.marked = "keyword"), W(ge)) } function Yr(F) { if (F == ",") return W(Qi, Yr) } function ge(F, X) { if (X == "as") return q.marked = "keyword", W(Qi) } function Wt(F, X) { if (X == "from") return q.marked = "keyword", W(mt) } function Si(F) { return F == "]" ? W() : ct(Qt(St, "]")) } function dr() { return ct(K("form"), Qe, ht("{"), K("}"), Qt($e, "}"), J, J) } function $e() { return ct(Qe, Ze) } function $t(F, X) { return F.lastType == "operator" || F.lastType == "," || n.test(X.charAt(0)) || /[,.]/.test(X.charAt(0)) } function di(F, X, Z) { return X.tokenize == C && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(X.lastType) || X.lastType == "quasi" && /\{\s*$/.test(F.string.slice(0, F.pos - (Z || 0))) } return { startState: function (F) { var X = { tokenize: C, lastType: "sof", cc: [], lexical: new tt((F || 0) - _, 0, "block", !1), localVars: k.localVars, context: k.localVars && new V(null, null, !1), indented: F || 0 }; return k.globalVars && typeof k.globalVars == "object" && (X.globalVars = k.globalVars), X }, token: function (F, X) { if (F.sol() && (X.lexical.hasOwnProperty("align") || (X.lexical.align = !1), X.indented = F.indentation(), z(F, X)), X.tokenize != I && F.eatSpace()) return null; var Z = X.tokenize(F, X); return f == "comment" ? Z : (X.lastType = f == "operator" && (m == "++" || m == "--") ? "incdec" : f, dt(X, Z, f, m, F)) }, indent: function (F, X) { if (F.tokenize == I || F.tokenize == D) return b.Pass; if (F.tokenize != C) return 0; var Z = X && X.charAt(0), At = F.lexical, Ut; if (!/^\s*else\b/.test(X)) for (var qt = F.cc.length - 1; qt >= 0; --qt) { var Zt = F.cc[qt]; if (Zt == J) At = At.prev; else if (Zt != hr && Zt != R) break } for (; (At.type == "stat" || At.type == "form") && (Z == "}" || (Ut = F.cc[F.cc.length - 1]) && (Ut == xt || Ut == pt) && !/^[,\.=+\-*:?[\(]/.test(X));)At = At.prev; S && At.type == ")" && At.prev.type == "stat" && (At = At.prev); var xe = At.type, Xe = Z == xe; return xe == "vardef" ? At.indented + (F.lastType == "operator" || F.lastType == "," ? At.info.length + 1 : 0) : xe == "form" && Z == "{" ? At.indented : xe == "form" ? At.indented + _ : xe == "stat" ? At.indented + ($t(F, X) ? S || _ : 0) : At.info == "switch" && !Xe && k.doubleIndentSwitch != !1 ? At.indented + (/^(?:case|default)\b/.test(X) ? _ : 2 * _) : At.align ? At.column + (Xe ? 0 : 1) : At.indented + (Xe ? 0 : _) }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: a ? null : "/*", blockCommentEnd: a ? null : "*/", blockCommentContinue: a ? null : " * ", lineComment: a ? null : "//", fold: "brace", closeBrackets: "()[]{}''\"\"``", helperType: a ? "json" : "javascript", jsonldMode: d, jsonMode: a, expressionAllowed: di, skipExpression: function (F) { dt(F, "atom", "atom", "true", new b.StringStream("", 2, null)) } } }), b.registerHelper("wordChars", "javascript", /[\w$]/), b.defineMIME("text/javascript", "javascript"), b.defineMIME("text/ecmascript", "javascript"), b.defineMIME("application/javascript", "javascript"), b.defineMIME("application/x-javascript", "javascript"), b.defineMIME("application/ecmascript", "javascript"), b.defineMIME("application/json", { name: "javascript", json: !0 }), b.defineMIME("application/x-json", { name: "javascript", json: !0 }), b.defineMIME("application/manifest+json", { name: "javascript", json: !0 }), b.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }), b.defineMIME("text/typescript", { name: "javascript", typescript: !0 }), b.defineMIME("application/typescript", { name: "javascript", typescript: !0 }) }) })(); const oo = v => (Pu("data-v-b1ab94ca"), v = v(), Ru(), v), d0 = { class: "td-editor-right" }, g0 = { class: "td-editor-right-header" }, p0 = oo(() => Vt("span", null, "属性管理", -1)), v0 = { class: "td-editor-right-main" }, m0 = { class: "td-editor-right-main-left" }, y0 = { class: "td-editor-right-main-left-item", title: "清空画布" }, A0 = oo(() => Vt("div", { class: "td-editor-right-main-left-line" }, null, -1)), C0 = oo(() => Vt("div", { class: "td-editor-right-main-left-line" }, null, -1)), b0 = { class: "td-editor-right-main-left-item", title: "页面换肤" }, w0 = { class: "td-editor-right-main-left-item", title: "页面设置" }, x0 = { __name: "index", props: { propertyTable: { type: Object, default: { attribute: [], style: [], data: {} } }, propertyData: { type: Object, default: { attribute: {}, style: {}, data: {} } }, domData: Object, selectId: Array, canvasInfo: { type: Object, required: !0 } }, setup(v) { const h = v, b = xa("updataRight", null), E = xa("updataRightIcon", null), k = ye(["A"]), _ = ye(["A"]), S = qe(() => h.canvasInfo.moveing), d = qe(() => h.selectId && h.selectId.length == 1 ? h.selectId[0] : null), a = qe(() => { if (d.value && h.domData && h.domData[d.value]) return h.domData[d.value].lockMovementX }), l = qe(() => { if (d.value && h.domData && h.domData[d.value]) return h.domData[d.value].lockMovementY }), c = () => { E.moveing() }, r = qe(() => ["td-editor-right-main-left-item", h.selectId && h.selectId.length > 0 ? "" : "is-disabled"]), i = qe(() => ["td-editor-right-main-left-item", d.value ? "" : "is-disabled"]), n = qe(() => ["td-editor-right-main-left-item", d.value ? "" : "is-disabled", d.value && a.value ? "is-active" : ""]), o = qe(() => ["td-editor-right-main-left-item", d.value ? "" : "is-disabled", d.value && l.value ? "is-active" : ""]), p = x => { switch (x) { case "topIndex": b("zIndex", h.domData[d.value].zIndex + 1, d.value, "style"); break; case "bottomIndex": if (h.domData[d.value].zIndex < 0) return; b("zIndex", h.domData[d.value].zIndex - 1, d.value, "style"); break; case "auto-height-one": b("lockMovementX", !a.value, d.value, "style"); break; case "auto-width-one": b("lockMovementY", !l.value, d.value, "style"); break; case "delete": E.deleteItem(h.selectId); break } }, f = () => { E.deleteItem() }, m = ye("style"), y = (x, I) => { }, C = x => { let I; x == "lineW" ? I = "横向参考线Y轴坐标" : I = "纵向参考线X轴坐标", Bc.prompt(`请输入${I}`, "创建参考线", { confirmButtonText: "创建", cancelButtonText: "取消", inputPattern: /^\d+$/, inputErrorMessage: "请输入数字" }).then(({ value: D }) => { E.creatLine(x, { value: D }) }).catch(() => { }) }; return (x, I) => { const D = ce("EditorIcon"), P = ce("el-popconfirm"), z = ce("el-empty"), et = ce("el-scrollbar"), tt = ce("el-tab-pane"), st = ce("el-tabs"); return zt(), fe("div", d0, [Vt("div", g0, [p0, Jt(D, { name: "right", size: "16px" })]), Vt("div", v0, [Vt("div", m0, [Vt("div", { class: si(["td-editor-right-main-left-item", S.value ? "is-active" : ""]), title: "移动画布", onClick: c }, [Jt(D, { name: "direction-adjustment-three", size: "20px" })], 2), Jt(P, { title: "确定要清空画布嘛?", width: "200", "confirm-button-text": "清空", "cancel-button-text": "取消", onConfirm: f }, { reference: Oe(() => [Vt("div", y0, [Jt(D, { name: "clear", size: "20px" })])]), _: 1 }), Vt("div", { class: "td-editor-right-main-left-item", title: "横向参考线", onClick: I[0] || (I[0] = dt => C("lineW")) }, [Jt(D, { name: "dividing-line", size: "20px" })]), Vt("div", { class: "td-editor-right-main-left-item", title: "纵向参考线", onClick: I[1] || (I[1] = dt => C("lineH")) }, [Jt(D, { name: "dividing-line", size: "20px", style: { transform: "rotate(90deg)" } })]), A0, Vt("div", { class: si(i.value), title: "图层上移", onClick: I[2] || (I[2] = dt => p("topIndex")) }, [Jt(D, { name: "to-top", size: "22px" })], 2), Vt("div", { class: si(i.value), title: "图层下移", onClick: I[3] || (I[3] = dt => p("bottomIndex")) }, [Jt(D, { name: "to-bottom", size: "22px" })], 2), Vt("div", { class: si(n.value), title: "锁定左右", onClick: I[4] || (I[4] = dt => p("auto-height-one")) }, [Jt(D, { name: "auto-height-one", size: "20px" })], 2), Vt("div", { class: si(o.value), title: "锁定上下", onClick: I[5] || (I[5] = dt => p("auto-width-one")) }, [Jt(D, { name: "auto-width-one", size: "20px" })], 2), Vt("div", { class: si(r.value), title: "图层删除", onClick: I[6] || (I[6] = dt => p("delete")) }, [Jt(D, { name: "delete", size: "20px" })], 2), C0, Vt("div", b0, [Jt(D, { name: "theme", size: "20px" })]), Vt("div", w0, [Jt(D, { name: "setting-one", size: "20px" })])]), (zt(), fe("div", { class: "td-editor-right-main-right", key: v.selectId }, [Jt(st, { modelValue: m.value, "onUpdate:modelValue": I[7] || (I[7] = dt => m.value = dt), class: "td-editor-right-main-right-tabs", onTabClick: y, stretch: !0 }, { default: Oe(() => [Jt(tt, { label: "属性", name: "attribute" }, { default: Oe(() => [Jt(et, { height: "100%" }, { default: Oe(() => [v.propertyTable.attribute.length > 0 ? (zt(), le(Mu, { key: 0, itemData: v.propertyData.attribute, itemTable: v.propertyTable.attribute, selectId: d.value, active: k.value, type: "attribute" }, null, 8, ["itemData", "itemTable", "selectId", "active"])) : (zt(), le(z, { key: 1, description: " " }, { image: Oe(() => [Ns("暂无数据")]), _: 1 }))]), _: 1 })]), _: 1 }), Jt(tt, { label: "样式", name: "style" }, { default: Oe(() => [Jt(et, { height: "100%" }, { default: Oe(() => [v.propertyTable.style.length > 0 ? (zt(), le(Mu, { key: 0, itemData: v.propertyData.style, itemTable: v.propertyTable.style, active: _.value, selectId: d.value, type: "style" }, null, 8, ["itemData", "itemTable", "active", "selectId"])) : (zt(), le(z, { key: 1, description: " " }, { image: Oe(() => [Ns("暂无数据")]), _: 1 }))]), _: 1 })]), _: 1 }), Jt(tt, { label: "数据", name: "data" })]), _: 1 }, 8, ["modelValue"])]))])]) } } }, _0 = Ci(x0, [["__scopeId", "data-v-b1ab94ca"]]), Dr = [{ name: "盒子公共样式", value: "A", children: [{ name: "组件宽度", value: 0, type: "el-input-number", min: 0, field: "width", default: 0 }, { name: "组件高度", value: 0, type: "el-input-number", min: 0, field: "height", default: 0 }, { name: "距离顶部", value: 0, type: "el-input-number", min: 0, field: "top", default: 0 }, { name: "距离左侧", value: 0, type: "el-input-number", min: 0, field: "left", default: 0 }, { name: "组件层级", value: 0, type: "el-input-number", min: 0, field: "zIndex", default: 0 }, { name: "横向对齐方式", value: 0, type: "el-select", field: "alignW", default: "flex-start", options: [{ label: "左对齐", value: "flex-start" }, { label: "居中", value: "center" }, { label: "右对齐", value: "flex-end" }] }, { name: "纵向对齐方式", value: 0, type: "el-select", field: "alignH", default: "flex-start", options: [{ label: "上对齐", value: "flex-start" }, { label: "中对齐", value: "center" }, { label: "下对齐", value: "flex-end" }] }] }, { name: "盒子内边距", value: "B", children: [{ name: "左上", value: 0, type: "el-input-number", min: 0, field: "mtl", default: 0 }, { name: "右上", value: 0, type: "el-input-number", min: 0, field: "mtr", default: 0 }, { name: "右下", value: 0, type: "el-input-number", min: 0, field: "mbr", default: 0 }, { name: "左下", value: 0, type: "el-input-number", min: 0, field: "mbr", default: 0 }] }, { name: "盒子边框角度", value: "C", children: [{ name: "左上", value: 0, type: "el-input-number", min: 0, field: "btl", default: 0 }, { name: "右上", value: 0, type: "el-input-number", min: 0, field: "btr", default: 0 }, { name: "右下", value: 0, type: "el-input-number", min: 0, field: "bbr", default: 0 }, { name: "左下", value: 0, type: "el-input-number", min: 0, field: "bbr", default: 0 }] }], S0 = { attribute: [{ name: "X轴", value: "A", children: [{ name: "轴宽", type: "el-input-number", field: "width", default: 0 }] }], style: [], data: {} }, T0 = { attribute: [], style: [], data: {} }, E0 = { attribute: [], style: [], data: {} }, I0 = { attribute: [], style: [], data: {} }, B0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, k0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, M0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, O0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }, { name: "反转", type: "el-switch", field: "reverse", default: 0 }] }], style: [], data: {} }, D0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }, { name: "反转", type: "el-switch", field: "reverse", default: 0 }] }], style: [], data: {} }, L0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, F0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, P0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }, { name: "单次动画时长(秒)", type: "el-input-number", field: "duration", default: 3, max: 0, max: 100 }, { name: "反转", type: "el-switch", field: "reverse", default: !1 }] }], style: [], data: {} }, R0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, Q0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, W0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }, { name: "边框标题", type: "el-input", field: "title", default: "" }, { name: "标题宽度", type: "el-input-number", field: "titleWidth", default: 250, max: 0, max: 1e3 }] }], style: [], data: {} }, N0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, Y0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "背景色", type: "el-color-picker", field: "backgroundColor", default: "rgba(253, 250, 250, 0)" }] }], style: [], data: {} }, V0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }] }], style: [], data: {} }, z0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }] }], style: [], data: {} }, U0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "单次动画时长(秒)", type: "el-input-number", field: "duration", default: 3, max: 0, max: 100 }] }], style: [], data: {} }, H0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }] }], style: [], data: {} }, G0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "边框标题", type: "el-input", field: "title", default: "" }] }], style: [], data: {} }, j0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "反转渲染", type: "el-switch", field: "reverse", default: !1 }] }], style: [], data: {} }, X0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "边框标题", type: "el-input", field: "title", default: "" }] }], style: [], data: {} }, K0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "边框颜色", type: "ArrayColorValue", field: "color", default: [] }, { name: "扫描动画时长(秒)", type: "el-input-number", field: "scanDuration", default: 3, max: 0, max: 100 }, { name: "光晕动画时长(秒)", type: "el-input-number", field: "haloDuration", default: 3, max: 0, max: 100 }] }], style: [], data: {} }, q0 = { attribute: [{ name: "属性配置", value: "A", children: [{ name: "文本颜色", type: "el-color-picker", field: "color", default: "#fff" }, { name: "文字大小", type: "el-input-number", field: "fontSize", default: 12, max: 12, max: 100 }, { name: "文本内容", type: "el-input", field: "content", default: "文件组件" }, { name: "字体类型", type: "el-select", field: "fontStyle", default: "normal", options: [{ label: "默认值", value: "normal" }, { label: "斜体字体", value: "italic" }, { label: "倾斜字体", value: "oblique" }] }, { name: "字重", type: "el-select", field: "fontWeight", default: "normal", options: [{ label: "默认值", value: "normal" }, { label: "粗体", value: "bold" }, { label: "超粗体", value: "bolder" }, { label: "超细体", value: "lighter" }] }, { name: "横向对齐", type: "el-select", field: "justifyContent", default: "center", options: [{ label: "左对齐", value: "flex-start" }, { label: "居中", value: "center" }, { label: "右对齐", value: "flex-end" }] }, { name: "纵向对齐", type: "el-select", field: "alignItems", default: "center", options: [{ label: "上对齐", value: "flex-start" }, { label: "居中", value: "center" }, { label: "下对齐", value: "flex-end" }] }, { name: "文字间距", type: "el-input-number", field: "letterSpacing", default: 0, max: 0, max: 100 }, { name: "溢出隐藏", type: "el-switch", field: "overflow", default: !1 }] }], style: [], data: {} }; let Sf = { Map1: I0, elButton: S0, BarChart1: T0, LineChart2: E0, BorderBox1: B0, BorderBox2: k0, BorderBox3: M0, BorderBox4: O0, BorderBox5: D0, BorderBox6: L0, BorderBox7: F0, BorderBox8: P0, BorderBox9: R0, BorderBox10: Q0, BorderBox11: W0, BorderBox12: N0, BorderBox13: Y0, Decoration1: V0, Decoration3: z0, Decoration5: U0, Decoration6: H0, Decoration7: G0, Decoration8: j0, Decoration11: X0, Decoration12: K0, apWviewText1: q0 }; const J0 = v => { let h = {}; return h = { ...JSON.parse(JSON.stringify(Sf[v])) }, h.style.unshift(...Dr), { ...h } }, Du = (v, h) => { let b = { attribute: {}, style: {}, data: {} }, E = { ...Sf[v] }, k = {}; for (let _ = 0; _ < Dr.length; _++)for (let S = 0; S < Dr[_].children.length; S++)k[Dr[_].children[S].field] = h[Dr[_].children[S].field] || Dr[_].children[S].default; b.style = { ...k }; for (let _ = 0; _ < E.attribute.length; _++)for (let S = 0; S < E.attribute[_].children.length; S++)b.attribute[E.attribute[_].children[S].field] = h.attribute[E.attribute[_].children[S].field] || E.attribute[_].children[S].default; for (let _ = 0; _ < E.style.length; _++)for (let S = 0; S < E.style[_].children.length; S++)b.style[E.style[_].children[S].field] = h.style[E.style[_].children[S].field] || E.style[_].children[S].default; return b }; const Z0 = { class: "td-editorMain" }, $0 = { class: "td-editorMain-topBox" }, ty = { class: "td-editorMain-main" }, ey = { class: "td-editorMain-main-left" }, iy = { class: "td-editorMain-main-middle" }, ry = { class: "td-editorMain-main-right" }, ny = Oc({ name: "td-editor" }), ay = Object.assign(ny, { setup(v) { const h = kc(), b = Lu(), { indexDBUpdata: E, indexDBSearch: k } = Mc().appContext.config.globalProperties, _ = ye(null), S = ye(null); let d = Js({}), a = ye({}); const l = ye(null), c = ye({ moveing: !1, lineH: !1, lineW: !1 }), r = tt => { tt.uuid && (d[tt.uuid] = tt) }, i = tt => { tt.uuid && (d[tt.uuid] = { ...d[tt.uuid], ...tt }) }, n = tt => { if (tt) for (let st = 0; st < tt.length; st++)tt[st].uuid && (d[tt[st].uuid] = { ...d[tt[st].uuid], ...tt[st] }) }, o = tt => { delete d[tt] }, p = ye({ attribute: {}, style: {}, data: {} }), f = ye({ attribute: [], style: [], data: {} }), m = tt => { if (l.value = tt, tt && tt.length == 1) { let st = d[tt[0]]; p.value = { ...Du(st.mark, st) }, f.value = { ...J0(st.mark) } } else p.value = { attribute: {}, style: {}, data: {} }, f.value = { attribute: [], style: [], data: {} } }, y = tt => { _.value.selectCanvas(tt) }; wn(() => d, tt => { if (!(Object.keys(tt).length === 0) && l.value && l.value.length == 1) { let dt = tt[l.value]; dt ? p.value = { ...Du(dt.mark, dt) } : (p.value = { attribute: {}, style: {}, data: {} }, f.value = { attribute: [], style: [], data: {} }) } }, { deep: !0 }); let C = ["width", "height", "zIndex", "left", "top", "lockMovementY", "lockMovementX"], x = ["mbl", "mbr", "mtl", "mtr", "bbl", "bbr", "btl", "btr", "alignH", "alignW"]; const I = (tt, st, dt, q) => { q == "style" && C.includes(tt) ? _.value.updataFiles(tt, st, dt) : q == "style" && x.includes(tt) ? d[dt][tt] = st : q == "style" ? d[dt].style[tt] = st : q == "attribute" && (d[dt].attribute[tt] = st) }, D = tt => { S.value = tt }; Ds("updataRight", I), Ds("draggable", D), Ds("updataRightIcon", { moveing: () => { c.value.moveing = !c.value.moveing }, deleteItem: tt => { _.value.deleteItem(tt) }, redo: () => { _.value.redo() }, undo: () => { _.value.undo() }, creatLine: (tt, st) => { _.value.creatLine(tt, st) } }); const P = async () => { let tt = await k("project", h.params.id); E("project", { ...tt, uuid: h.params.id, domData: JSON.stringify(d) }), Ws({ type: "success", message: "保存成功" }) }, z = () => { b.push({ name: "preview", params: { id: h.params.id } }) }, et = () => { k("project", h.params.id).then(tt => { if (!tt) { Ws.error("查询项目不存在"), b.replace("/"); return } let st = tt.domData ? JSON.parse(tt.domData) : null; st && _.value.setCanvas(st), tt.width = tt.ratio.split("*")[0] + "px", tt.height = tt.ratio.split("*")[1] + "px", tt.backgroundColor = tt.backgroundColor ? tt.backgroundColor : "transparent", a.value = { ...tt } }) }; return La(() => { if (!h.params.id) { b.replace("/"); return } et() }), (tt, st) => (zt(), fe("div", Z0, [Vt("div", $0, [Jt(zc, { onSaveItem: P, onPreviewItem: z, domInfo: yi(a) }, null, 8, ["domInfo"])]), Vt("div", ty, [Vt("div", ey, [Jt(Pd, { domData: yi(d), onSelectItem: y, selectId: l.value }, null, 8, ["domData", "selectId"])]), Vt("div", iy, [Jt(r0, { domData: yi(d), onAddDOM: r, onUpdataDOM: i, onUpdataDOMArray: n, onRemoveDOM: o, onSelectDom: m, draggable: S.value, ref_key: "EditorMiddleRef", ref: _, canvasInfo: c.value, domInfo: yi(a) }, null, 8, ["domData", "draggable", "canvasInfo", "domInfo"])]), Vt("div", ry, [Jt(_0, { propertyData: p.value, propertyTable: f.value, selectId: l.value, domData: yi(d), canvasInfo: c.value }, null, 8, ["propertyData", "propertyTable", "selectId", "domData", "canvasInfo"])])])])) } }), ly = Ci(ay, [["__scopeId", "data-v-de33adab"]]); export { ly as default };
